<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Frequently Asked Questions - Programming Multiple Robots with ROS 2</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="open-in.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Programming Multiple Robots with ROS 2</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/osrf/ros2multirobotbook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h1>
<h3 id="why-is-this-traffic-management-system-so-complicated"><a class="header" href="#why-is-this-traffic-management-system-so-complicated">Why is this traffic management system so complicated?</a></h3>
<p>RMF has a number of system design constraints that create unique challenges for
traffic management. The core goal of RMF is to facilitate system integration
for heterogeneous mobile robot fleets that may be provided by different vendors
and may have different technical capabilities.</p>
<p>Vendors tend to want to keep their computing systems independent from other
vendors. Since vendors are often responsible for ensuring uptime and
reliability on their computing infrastructure, they may view it as an
unacceptable liability to share computing resources with another vendor. This
means that the traffic management system must be able to function while being
distributed across different machines on a network.</p>
<p>Different robot platforms may have different capabilities. Many valuable AGV
platforms that are currently deployed are not able to change their itineraries
dynamically. Some AGV platforms can change course when instructed to, as long
as they stick to a predefined navigation graph. Some AMR platforms can
dynamically navigate themselves around unanticipated obstacles in their
environment. Since RMF is meant to be an enabling technology, it is important
that we design a system that can maximize the utility of all these different
types of systems without placing detrimental constraints on any of them.</p>
<p>These considerations led to the current design of distributed conflict
prevention and distributed schedule negotiation. There is plenty of space
within the design to create simpler and more efficient subsets for categories
of mobile robots that fit certain sets of requirements, but these optimizations
can be added later, building on top of the existing completely generalized
framework.</p>
<h3 id="who-opens-and-closes-doors-and-operates-the-lifts-the-robot-or-rmf-or-both"><a class="header" href="#who-opens-and-closes-doors-and-operates-the-lifts-the-robot-or-rmf-or-both">Who opens and closes doors and operates the lifts? The robot or RMF? Or both?</a></h3>
<p>The responsibility of knowing when a door needs to be opened and then sending
the command to open it belongs to the "fleet adapter". The basic design is:</p>
<ul>
<li>The fleet adapter keeps track of the robot's progress</li>
<li>When the robot needs to go through a door, the fleet adapter will recognize this</li>
<li>The fleet adapter will send a signal to the door to open</li>
<li>Once the door is open, the fleet adapter will command the robot to proceed</li>
<li>Once the robot is through the door, the fleet adapter will command the robot wait until the door is closed</li>
<li>The fleet adapter will command the door to close</li>
<li>Once the door is closed, the fleet adapter will command the robot to proceed</li>
</ul>
<p>The way a fleet adapter knows about the doors is by parsing the navigation
graph that is provided to it. The navigation graph is a required parameter for
the <code>full_control</code> type of fleet adapter. <code>rmf_demos</code> shows an example of
providing a navigation graph to the fleet adapter.</p>
<p>The recommended way to construct a navigation graph is to use the
<code>traffic-editor</code> tool. The <code>rmf_demos</code> repos shows some examples of
<code>traffic-editor</code> project files.</p>
<p>However, it's entirely possible to construct your own navigation graphs. They
use YAML format.</p>
<h3 id="are-lifts-supported"><a class="header" href="#are-lifts-supported">Are lifts supported?</a></h3>
<p>Proper lift support (meaning, specifying an actual lift that can move between
floors, and exporting that information into the navigation graph) is not
something that has been developed yet.</p>
<p>However, for testing and demonstration purposes, there are two special
navigation graph edge properties that can allow a RMF fleet adapter to emulate
lift usage. This is meant for demo scenarios where a "mock lift" has been
created that receives lift commands and transmits lift states but does not
actually move between any different floors in a building. For example, tape
on the floor of a lab to indicate the "lift cabin" box, to allow development
and testing without occupying the actual building lift.</p>
<p>These properties were initially included for demonstration purposes, but they
are proving useful enough that we might make them officially supported
properties. Due to the cost and scarcity of "real" lifts, there seems to be
broad interest in having single-floor hardware test setups that emulate
multi-floor scenarios.</p>
<p>The edge properties are:</p>
<ul>
<li><code>demo_mock_floor_name</code>: The name of the floor that the robot is on while traversing the edge</li>
<li><code>demo_mock_lift_name</code>: The name of the lift that is being entered or exited while the robot traverses the edge</li>
</ul>
<p>The idea is that if you have a single floor demonstration environment but want
to demonstrate interaction with a lift, then you can set up a mock "lift" and
imagine that each side of the "lift" opens to a different floor, and the robot
is only allowed to enter/exit that side of the "lift" when the "lift" believes
it is on that floor. This emulates lift cabins with two sets of doors.</p>
<p>To make this idea more concrete, imagine you have a single-floor hardware
testing area, and a box is drawn on the ground with an LED display next to it
that reads off pretend floor names. The mock lift will transmit lift state
messages that match up with whatever floor the LED is displaying. There is also
some indication of whether the lift doors are open or closed. You can further
imagine that entering or exiting from west side of the "lift" is only allowed
when the lift believes it is on floor L1 whereas entering or exiting the "lift"
from the east side is only allowed when it believes it is on floor L3.</p>
<p>In that setup, for a robot to "correctly" navigate from a waypoint on L1 to a
waypoint on L3, the robot needs to:</p>
<ul>
<li>Approach the "lift" from the west side</li>
<li>Call the "lift" down to L1</li>
<li>Wait until the lift state has it on floor L1 with the doors open</li>
<li>Move into the "lift" (i.e. the box drawn on the ground) and request that it "moves" to L3</li>
<li>Wait until the "lift" indicates that it has reached L3 and that its doors are open</li>
<li>Exit the "lift" on the east side</li>
</ul>
<p>A rough ASCII diagram would look like this (numbers are waypoints and letters
are edges):</p>
<pre><code>1 &lt;---a---&gt; 2 &lt;---b---&gt; 3
</code></pre>
<ul>
<li>Waypoint 1 is on floor L1</li>
<li>Waypoint 2 is inside the "lift" named LIFT001</li>
<li>Waypoint 3 is on floor L3</li>
<li>The properties of edge <code>a </code>are:
<ul>
<li>bidirectional: true</li>
<li>demo_mock_floor_name: L1</li>
<li>demo_mock_lift_name: LIFT001</li>
</ul>
</li>
<li>The properties of edge <code>b</code> are:
<ul>
<li>bidirectional: true</li>
<li>demo_mock_floor_name: L3</li>
<li>demo_mock_lift_name: LIFT001</li>
</ul>
</li>
</ul>
<h3 id="if-multiple-fleets-can-do-the-same-task-which-one-is-one-chosen"><a class="header" href="#if-multiple-fleets-can-do-the-same-task-which-one-is-one-chosen">If multiple fleets can do the same task, which one is one chosen?</a></h3>
<p>Though not implemented yet, there is a design worked out for a bidding system
where a task request will be converted to a bid request. The bid request will
be sent to each fleet adapter, and each fleet adapter that can perform the task
will report its best estimate for how soon it would be able to have the task
finished. The fleet adapter that offers the lowest bid will be assigned the
task.</p>
<p>The API and implementation are awaiting finalization of some critical components.</p>
<h3 id="can-some-robots-have-priority-over-other-robots"><a class="header" href="#can-some-robots-have-priority-over-other-robots">Can some robots have priority over other robots?</a></h3>
<p>The negotiation system concept does support prioritization for which robot will
accommodate the other robot(s). Any arbitrary metric or weighting system can be
used when resolving a negotiation. But in the current implementation that we
are using, we treat all vehicles as equal and choose the resolution
that minimizes the net delay across all the robots, without any prioritization
or weighting.</p>
<p>Since this codebase is open source, you can easily fork the code and modify it
to use any prioritization system that you'd like. Specifically, replace
<code>rmf_traffic::schedule::QuickestFinishEvaluator()</code> with your own
<code>Negotiation::Evaluator</code> class that behaves in whatever way you would like.</p>
<h3 id="what-distance-is-maintained-between-two-robots"><a class="header" href="#what-distance-is-maintained-between-two-robots">What distance is maintained between two robots?</a></h3>
<p>This is configurable. There are two relevant parameters: <code>footprint_radius</code> and
<code>vicinity_radius</code>. The <code>footprint_radius</code> represents an estimate of the
vehicle's physical footprint. The <code>vicinity_radius</code> represents an estimate of
the region which the robot needs other vehicles to stay clear of. A "schedule
conflict" is defined as an instance where one vehicle's "footprint" is
scheduled to enter another vehicle's "vicinity". The job of the negotiation
system is to come up with a fix to the schedule that keeps all vehicles'
"footprints" out of all other vehicles' "vicinities".</p>
<h3 id="how-is-job-dispatching-accomplished"><a class="header" href="#how-is-job-dispatching-accomplished">How is job dispatching accomplished?</a></h3>
<p>The Dispatch Planner module is currently a work-in-progress.
So far, the demo platforms that have been developed for RMF did not require a planner to dispatch tasks to different fleets, because in all demo platforms done thus far (late 2020), each task type could only be performed by one (and only one) robot fleet.
So the task dispatching has been trivial: the task gets assigned to whatever fleet is capable of performing the task, while the rest of the fleets just ignore the task request.
We are currently working on a true dispatch planner and formal task bidding system which we're aiming to include in release 1.2.0, slated for end of December 2020.
The idea is that every fleet that can perform a task request will offer a bid for how much it would "cost" them to perform a task, and the bid with the lowest "cost" will be the winner.
The "cost" will be determined by two factors:</p>
<ul>
<li>How quickly the task is finished</li>
<li>How much other tasks get delayed if the new task needs to preempt them</li>
</ul>
<h3 id="what-is-rmf_traffic-"><a class="header" href="#what-is-rmf_traffic-">What is <code>rmf_traffic</code> ?</a></h3>
<p><code>rmf_traffic</code> provides a middleware-neutral implementation of the core traffic scheduling algorithms and utilities. It does not use or depend on ROS 2.</p>
<h3 id="what-is-rmf_traffic_ros2-"><a class="header" href="#what-is-rmf_traffic_ros2-">What is <code>rmf_traffic_ros2</code> ?</a></h3>
<p><code>rmf_traffic_ros2</code> provides convenient wrappers for using the <code>rmf_traffic</code> as part of a distributed ROS 2 system.</p>
<h3 id="where-is-the-costmap"><a class="header" href="#where-is-the-costmap">Where is the costmap?</a></h3>
<p>There is no costmap representation in <code>rmf_core</code>.
Costmaps are one method that is typically used for representing volume occupancy for autonomous navigation planning.
While it's true that the traffic utilities deal with navigation planning, they are principally concerned about identifying conflicts between the intended routes of autonomous vehicles.
The traffic utilities are not responsible for the "local" navigation of vehicles around static obstacles in their environment.</p>
<p>Different robot platforms often have different representations of costmaps or other navigation algorithms, many of which may be proprietary.
On top of that, different robot platforms with the same costmap representations may still require different costmap values because of differences in robot footprints.
Because of these factors, we leave it to the robot platforms themselves to determine how they represent their costmaps. If it's important for a system integrator to take a robot's costmap into account when performing traffic planning, they can implement a custom <code>rmf_traffic::agv::RouteValidator</code> that uses the robot's custom costmap when determining whether a candidate route is valid.</p>
<h3 id="what-is-the-core-algorithm-behind-rmf_traffic-"><a class="header" href="#what-is-the-core-algorithm-behind-rmf_traffic-">What is the core algorithm behind <code>rmf_traffic</code> ?</a></h3>
<p>Conflict avoidance for AGV's in <code>rmf_traffic</code> is implemented with time-dependent extension to <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A* search</a>
This search takes time into account so that it can find paths through space and time that account for the motions of other agents that are in the traffic schedule.</p>
<h3 id="during-negotiation-how-do-fleets-compute-their-proposals"><a class="header" href="#during-negotiation-how-do-fleets-compute-their-proposals">During negotiation, how do fleets compute their proposals?</a></h3>
<p>Because the system is designed to be extensible and adaptable to a wide variety of scenarios and robot vendor combinations, including many that do not currently exist, it has many pieces and hooks for expansion. The sequence of computing a traffic proposal is as follows:</p>
<ul>
<li>First, the fleet adapter node will receive a conflict notification which tells it that it needs to participate in a negotiation to resolve a space-time conflict. This notification is received by the <code>rmf_traffic_ros2::schedule::Negotiation</code> class.</li>
<li>For this to happen, the fleet adapter creates a negotiation-notification subscription, so that it will be told whenever a particular robot under its control needs to respond to a negotiation notification.</li>
<li>When a robot needs to repond to a negotiation, its implementation gets triggered.</li>
<li>This implementation will launch a multi-threaded <code>Negotiate</code> service, whose main implementation can be found <a href="https://github.com/osrf/rmf_core/blob/master/rmf_fleet_adapter/src/rmf_fleet_adapter/services/detail/impl_Negotiate.hpp">here</a></li>
</ul>
<p>Every step in the multi-party negotiation is using the <code>Negotiate</code> service the exact same way.
The only difference between the various steps is what constraints they need to deal with.
Those constraints are described by the <code>rmf_traffic::schedule::Negotiation::Table::Viewer</code> object that gets passed to the <code>respond(~)</code> function.
Because the same object can be used to describe the constraints of all the different blocks in the diagram, we can use the same code to solve every block.</p>
<p>There are also <code>reject</code> and <code>forfeit</code> code paths that may be invoked as necessary:</p>
<ul>
<li>The "rejection" mechanism is used when it's impossible for one of the fleets to accommodate a proposal that came from another.
When a rejection is performed, the rejecting fleet will provide a set of feasible trajectories (usually anywhere from 10-200 trajectories) and the fleet that receives the rejection should try once again to find an ideal proposal for itself, but that ideal proposal must accommodate at least one of the trajectory alternatives that were provided with the rejection.</li>
<li>The "forfeit" mechanism is used when the planner is having an inordinately difficult time finding any kind of solution.
This can happen when the negotiation has numerous participants that are all actively on the move, which can lead to situations that are seemingly impossible to resolve due to inconsistencies across time.
Typically, when a forfeit is used, there will be another feasible combination of accommodations that gets found by the negotiation.
In the worst case scenario, if negotiations keep failing, the robots may experience a real-life deadlock.
When a deadlock happens, the participants will be sitting still so the negotiation will reach a steady state and will not be negatively affected by async inconsistencies.
When that happens, a successful resolution is practically assured.</li>
</ul>
<p>The preceeding explanation describes the "Full Control" style of fleet adapter. The implementation for the "Read Only" and "Traffic Light" APIs are a bit different.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/rmf-core_faq.md">Edit this page on GitHub.</a></footer>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="rmf-core.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="task.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="rmf-core.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="task.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
