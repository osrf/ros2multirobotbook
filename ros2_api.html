<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The ROS API - Programming Multiple Robots with ROS 2</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="open-in.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item "><a href="demos.html"><strong aria-hidden="true">1.2.</strong> Demos</a></li></ol></li><li class="chapter-item expanded "><a href="ros2.html"><strong aria-hidden="true">2.</strong> ROS 2</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ros2_tools_resources.html"><strong aria-hidden="true">2.1.</strong> ROS Resources</a></li><li class="chapter-item "><a href="ros2_design_patterns.html"><strong aria-hidden="true">2.2.</strong> ROS Concepts and Design Patterns</a></li><li class="chapter-item "><a href="ros2_cli.html"><strong aria-hidden="true">2.3.</strong> The ROS Command Line Interface</a></li><li class="chapter-item expanded "><a href="ros2_api.html" class="active"><strong aria-hidden="true">2.4.</strong> The ROS API</a></li></ol></li><li class="chapter-item "><a href="traffic-editor.html"><strong aria-hidden="true">3.</strong> Traffic Editor</a></li><li class="chapter-item "><a href="simulation.html"><strong aria-hidden="true">4.</strong> Simulation</a></li><li class="chapter-item "><a href="rmf-core.html"><strong aria-hidden="true">5.</strong> RMF Core Overview</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="rmf-core_faq.html"><strong aria-hidden="true">5.1.</strong> Frequently Asked Questions</a></li></ol></li><li class="chapter-item "><a href="task.html"><strong aria-hidden="true">6.</strong> Tasks in RMF</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="task_planner.html"><strong aria-hidden="true">6.1.</strong> RMF Task Allocation Planner</a></li><li class="chapter-item "><a href="task_types.html"><strong aria-hidden="true">6.2.</strong> Currently supported Tasks</a></li><li class="chapter-item "><a href="task_new.html"><strong aria-hidden="true">6.3.</strong> Supporting a new Task</a></li></ol></li><li class="chapter-item "><a href="soss.html"><strong aria-hidden="true">7.</strong> SOSS</a></li><li class="chapter-item "><a href="integration.html"><strong aria-hidden="true">8.</strong> Integration</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="integration_nav-maps.html"><strong aria-hidden="true">8.1.</strong> Navigation Maps</a></li><li class="chapter-item "><a href="integration_fleets.html"><strong aria-hidden="true">8.2.</strong> Mobile Robot Fleets</a></li><li class="chapter-item "><a href="integration_free-fleet.html"><strong aria-hidden="true">8.3.</strong> Free Fleet</a></li><li class="chapter-item "><a href="integration_read-only.html"><strong aria-hidden="true">8.4.</strong> Read-Only Fleets</a></li><li class="chapter-item "><a href="integration_doors.html"><strong aria-hidden="true">8.5.</strong> Doors</a></li><li class="chapter-item "><a href="integration_lifts.html"><strong aria-hidden="true">8.6.</strong> Lifts (Elevators)</a></li><li class="chapter-item "><a href="integration_workcells.html"><strong aria-hidden="true">8.7.</strong> Workcells</a></li></ol></li><li class="chapter-item "><a href="rmf-web.html"><strong aria-hidden="true">9.</strong> RMF Web</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ui.html"><strong aria-hidden="true">9.1.</strong> User Interfaces</a></li></ol></li><li class="chapter-item "><a href="security.html"><strong aria-hidden="true">10.</strong> Security</a></li><li class="chapter-item "><a href="roadmap.html"><strong aria-hidden="true">11.</strong> Roadmap</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Programming Multiple Robots with ROS 2</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/osrf/ros2multirobotbook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-ros-api"><a class="header" href="#the-ros-api">The ROS API</a></h1>
<p>ROS comprises many software libraries that provide a wide array of
functionality useful when building robot applications. The libraries
you need will depend on the details of your project. In this section we will
introduce two core libraries that you are likely to interact with
frequently when developing with ROS:</p>
<ul>
<li><code>rclpy</code> : Python client library</li>
<li><code>rclcpp</code> : C++ client library</li>
</ul>
<p>A ROS <em>client library</em> provides the data structures, functions, and
syntactic sugar that make it convenient to develop in a particular
programming language. Here we will cover just the Python and C++
libraries because they're the most widely used. But you can find ROS
client libraries for many other languages, from Ada to JavaScript to
Rust, and beyond.</p>
<div style="border: 1px; border-style: solid; padding: 1em">
<b>Note</b>: In this section we aim for a gentle and efficient introduction
to the ROS API. In service of that goal, we will purposefully ignore
and/or violate various conventions and patterns.
</div>
<h2 id="publishing-and-subscribing-to-topics-in-python"><a class="header" href="#publishing-and-subscribing-to-topics-in-python">Publishing and Subscribing to Topics in Python</a></h2>
<p>Publishing data with ROS is easy. Here is a complete Python program that
publishes string messages:</p>
<pre><code class="language-{.sourceCode .py}">from time import sleep
import rclpy
from std_msgs.msg import String

rclpy.init()
node = rclpy.create_node('my_publisher')
pub = node.create_publisher(String, 'chatter', 10)
msg = String()
i = 0
while rclpy.ok():
    msg.data = f'Hello World: {i}'
    i += 1
    print(f'Publishing: &quot;{msg.data}&quot;')
    pub.publish(msg)
    sleep(0.5)
</code></pre>
<p>Try it out yourself. (Make sure that in every shell used you have
sourced your ROS setup file as we discussed in the previous chapter; e.g., <code>source /opt/ros/foxy/setup.bash</code>.) Copy the code block above into a file, call
it <code>talker.py</code>, then feed it to your Python3 interpreter:</p>
<pre><code class="language-{.sourceCode .bash}">$ python3 talker.py
</code></pre>
<p>You should see:</p>
<pre><code>Publishing: &quot;Hello world: 0&quot;
Publishing: &quot;Hello world: 1&quot;
Publishing: &quot;Hello world: 2&quot;
</code></pre>
<p>It prints to console, but is the data going anywhere? We can check
our work using the <code>ros2 topic</code> tool that was introduced earlier. In
another shell (leave your talker running), run:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 topic echo chatter
</code></pre>
<p>You should see the following, though the numbers will vary depending on timing between the two
commands:</p>
<pre><code>data: 'Hello world: 13'
---
data: 'Hello world: 14'
---
data: 'Hello world: 15'
</code></pre>
<p>So we have a working talker. Now we can add our own listener to use in
place of <code>ros2 topic</code>. Here is a complete Python program that subscribes
to string messages and prints them to console:</p>
<pre><code class="language-{sourceCode .py}">import rclpy
from std_msgs.msg import String

def cb(msg):
    print(f'I heard: &quot;{msg.data}&quot;')

rclpy.init()
node = rclpy.create_node('my_subscriber')
sub = node.create_subscription(String, 'chatter', cb, 10)
rclpy.spin(node)
</code></pre>
<p>Try it out yourself. Copy the code block above into a file and call it
<code>listener.py</code>. With your talker still running in one shell, start up your
listener in another shell:</p>
<pre><code class="language-{sourceCode .bash}">$ python3 listener.py
</code></pre>
<p>You should see (again, numbers will vary depending on timing):</p>
<pre><code>I heard: &quot;Hello world: 35&quot;
I heard: &quot;Hello world: 36&quot;
I heard: &quot;Hello world: 37&quot;
</code></pre>
<h3 id="digging-into-the-python-code"><a class="header" href="#digging-into-the-python-code">Digging into the Python Code</a></h3>
<p>Now that we know these programs work, we can dig into their code. Both
programs start with the same preamble:</p>
<pre><code class="language-{sourceCode .py}">import rclpy
from std_msgs.msg import String
</code></pre>
<p>We need to import the <code>rclpy</code> client library, which gives us
much of what we need to write ROS applications in Python. But we also need
to specifically import the ROS message type(s) that we will use. In this
case we are using the simple <code>std_msgs/String</code> message, which contains a
single field called <code>data</code>, of type <code>string</code>. If we wanted to use the
<code>sensor_msgs/Image</code> message, which represents camera images, then we
would write <code>from sensor_msgs.msg import Image</code>.</p>
<p>After the imports, both programs perform common initialization:</p>
<pre><code class="language-{sourceCode .py}">rclpy.init()
node = rclpy.create_node('my_node_name')
</code></pre>
<p>We initialize the <code>rclpy</code> library and then call into it to create a
<code>Node</code> object, giving it a name. Subsequently we will operate on that
<code>Node</code> object.</p>
<p>In the talker, we use the <code>Node</code> object to create a <code>Publisher</code> object:</p>
<pre><code class="language-{sourceCode .py}">pub = node.create_publisher(String, 'chatter', 10)
</code></pre>
<p>We declare the type of data we will publish (<code>std_msgs/String</code>), the
name of the topic on which we will publish (<code>chatter</code>), and the maximum
number of outbound messages to locally queue up (10). That last
argument comes into play when we are publishing faster than subscribers
are consuming the data.</p>
<p>The equivalent step in the listener is to create a <code>Subscription</code>
object:</p>
<pre><code class="language-{sourceCode .py}">sub = node.create_subscription(String, 'chatter', cb, 10)
</code></pre>
<p>The type (<code>String</code>) and topic name (<code>chatter</code>) arguments have the same meaning
as the <code>create_publisher()</code> call, and the final argument (10) is
setting an analogous maximum queue size for inbound messages. The key
difference is the <code>cb</code> argument, which refers to this <em>callback</em>
function that we also defined in the listener:</p>
<pre><code class="language-{sourceCode .py}">def cb(msg):
    print(f'I heard: &quot;{msg.data}&quot;')
</code></pre>
<p>That function will be called whenever the listener receives a message,
and the received message will be passed in as an argument. In this case
we simply print the content to console.</p>
<p>With the callback defined and the <code>Subscription</code> created, the rest of
the listener is one line:</p>
<pre><code class="language-{sourceCode .py}">rclpy.spin(node)
</code></pre>
<p>This call hands control over to <code>rclpy</code> to wait for new messages to
arrive (and more generally for events to occur) and invoke our callback.</p>
<p>Back in the talker, we create a simple loop to use our <code>Publisher</code>:</p>
<pre><code class="language-{sourceCode .py}">msg = String()
i = 0
while rclpy.ok():
    msg.data = f'Hello World: {i}'
    i += 1
    print(f'Publishing: &quot;{msg.data}&quot;')
    pub.publish(msg)
    sleep(0.5)
</code></pre>
<p>These steps are clear enough: we create a message object and then on
each iteration of the loop, we update the message content and publish
it, sleeping briefly between iterations.</p>
<h2 id="publishing-and-subscribing-to-topics-in-c"><a class="header" href="#publishing-and-subscribing-to-topics-in-c">Publishing and Subscribing to Topics in C++</a></h2>
<p>Now we will write the same talker and listener pair, this time in C++.</p>
<p>Here is a complete C++ program that publishes string messages:</p>
<pre><code class="language-{sourceCode .cpp}">#include &lt;unistd.h&gt;
#include &lt;iostream&gt;
#include &quot;rclcpp/rclcpp.hpp&quot;
#include &quot;std_msgs/msg/string.hpp&quot;

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);
  auto node = rclcpp::Node::make_shared(&quot;minimal_publisher&quot;);
  auto pub = node-&gt;create_publisher&lt;std_msgs::msg::String&gt;(&quot;chatter&quot;, 10);
  std_msgs::msg::String message;
  auto i = 0;
  while (rclcpp::ok()) {
    message.data = &quot;Hello world: &quot; + std::to_string(i++);
    std::cout &lt;&lt; &quot;Publishing: &quot; &lt;&lt; message.data &lt;&lt; std::endl;
    pub-&gt;publish(message);
    usleep(500000);
  }
  return 0;
}
</code></pre>
<p>Of course, as for all C++, we need to compile this program. Managing the
compilation arguments for C++ is cumbersome, so we use CMake to help.
Here is the complete CMake code that allows us to build the talker
example:</p>
<pre><code>cmake_minimum_required(VERSION 3.5)
project(talker_listener)

find_package(rclcpp REQUIRED)
find_package(std_msgs REQUIRED)

add_executable(talker talker.cpp)
target_include_directories(talker PRIVATE ${rclcpp_INCLUDE_DIRS} ${std_msgs_INCLUDE_DIRS})
target_link_libraries(talker ${rclcpp_LIBRARIES} ${std_msgs_LIBRARIES})
</code></pre>
<p>Try it out yourself. Copy the C++ code into a file called <code>talker.cpp</code>
and the CMake code into a file called <code>CMakeLists.txt</code>. Have them
side-by-side in a directory and then invoke <code>cmake</code> followed by <code>make</code>:</p>
<pre><code class="language-{sourceCode .bash}">$ cmake .
$ make
</code></pre>
<p>You should end up with a compiled executable called <code>talker</code>. Run it:</p>
<pre><code class="language-{sourceCode .bash}">$ ./talker
</code></pre>
<p>You should see:</p>
<pre><code>Publishing: &quot;Hello world: 0&quot;
Publishing: &quot;Hello world: 1&quot;
Publishing: &quot;Hello world: 2&quot;
</code></pre>
<p>Keep the talker running and another shell try <code>ros2 topic</code> to listen
in:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 topic echo chatter
</code></pre>
<p>You should see (numbers will vary depending on timing between the two
commands):</p>
<pre><code>data: 'Hello world: 13'
---
data: 'Hello world: 14'
---
data: 'Hello world: 15'
</code></pre>
<p>Now we can write our own listener to use in place of <code>ros2 topic</code>. Here
is a complete C++ program that subscribes to string messages and prints
them to console:</p>
<pre><code class="language-{sourceCode .cpp}">#include &quot;rclcpp/rclcpp.hpp&quot;
#include &quot;std_msgs/msg/string.hpp&quot;

void cb(const std_msgs::msg::String::SharedPtr msg)
{
  std::cout &lt;&lt; &quot;I heard: &quot; &lt;&lt; msg-&gt;data &lt;&lt; std::endl;
}

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);
  auto node = rclcpp::Node::make_shared(&quot;my_subscriber&quot;);
  auto sub = node-&gt;create_subscription&lt;std_msgs::msg::String&gt;(&quot;chatter&quot;, 10, cb);
  rclcpp::spin(node);
  return 0;
}
</code></pre>
<p>Copy the code block into a file called <code>talker.cpp</code>. To arrange for it
to be compiled, we also need to add some corresponding CMake code to the
bottom of our <code>CMakeLists.txt</code> file from earlier:</p>
<pre><code>add_executable(listener listener.cpp)
target_include_directories(listener PRIVATE ${rclcpp_INCLUDE_DIRS} ${std_msgs_INCLUDE_DIRS})
target_link_libraries(listener ${rclcpp_LIBRARIES} ${std_msgs_LIBRARIES})
</code></pre>
<p>Configure and build again:</p>
<pre><code class="language-{sourceCode .bash}">$ cmake .
$ make
</code></pre>
<p>Now you should have also have a <code>listener</code> executable. With your talker
still running in one shell, start up your listener in another shell:</p>
<pre><code class="language-{sourceCode .bash}">$ ./listener
</code></pre>
<p>You should see (again, numbers will vary depending on timing):</p>
<pre><code>I heard: &quot;Hello world: 35&quot;
I heard: &quot;Hello world: 36&quot;
I heard: &quot;Hello world: 37&quot;
</code></pre>
<h3 id="digging-into-the-c-code"><a class="header" href="#digging-into-the-c-code">Digging into the C++ Code</a></h3>
<p>Now that we know these programs work, we can dig into their code. Both
programs start with the same preamble:</p>
<pre><code class="language-{sourceCode .cpp}">#include &quot;rclcpp/rclcpp.hpp&quot;
#include &quot;std_msgs/msg/string.hpp&quot;
</code></pre>
<p>We always need to include the <code>rclcpp</code> client library, which gives us
much of what we need to write ROS applications in C++. But we also need to
specifically import the ROS message type(s) that we will use. In this
case we are using the simple <code>std_msgs/String</code> message, which contains a
single field called <code>data</code>, of type <code>string</code>. If we wanted to use the
<code>sensor_msgs/Image</code> message, which represents camera images, then we
would <code>#include &quot;sensor_msgs/msg/image.hpp&quot;</code>.</p>
<p>After the imports, both programs perform common initialization:</p>
<pre><code class="language-{sourceCode .cpp}">  rclcpp::init(argc, argv);
  auto node = rclcpp::Node::make_shared(&quot;my_node_name&quot;);
</code></pre>
<p>We initialize the <code>rclcpp</code> library and then call into it to create a
<code>Node</code> object, giving it a name. Subsequently we will operate on that
<code>Node</code> object.</p>
<p>In the talker, we use the <code>Node</code> object to create a <code>Publisher</code> object:</p>
<pre><code class="language-{sourceCode .cpp}">  auto pub = node-&gt;create_publisher&lt;std_msgs::msg::String&gt;(&quot;chatter&quot;, 10);
</code></pre>
<p>We declare via template the type of data we will publish (<code>std_msgs/String</code>), the
name of the topic on which we will publish (<code>chatter</code>), and the maximum
number of outbound messages to locally queue up (10). That last
argument comes into play when we are publishing faster than subscribers
are consuming the data.</p>
<p>The equivalent step in the listener is to create a <code>Subscription</code>
object:</p>
<pre><code class="language-{sourceCode .cpp}">  auto sub = node-&gt;create_subscription&lt;std_msgs::msg::String&gt;(&quot;chatter&quot;, 10, cb);
</code></pre>
<p>The type (<code>String</code>) and topic name (<code>chatter</code>) arguments have the same meaning
as for the <code>create_publisher()</code> call, and the numerical argument (10) is
setting an analogous maximum queue size for inbound messages. The key
difference is the <code>cb</code> argument, which refers to this <em>callback</em>
function that we also defined in the listener:</p>
<pre><code class="language-{sourceCode .cpp}">void cb(const std_msgs::msg::String::SharedPtr msg)
{
  std::cout &lt;&lt; &quot;I heard: &quot; &lt;&lt; msg-&gt;data &lt;&lt; std::endl;
}
</code></pre>
<p>That function will be called whenever the listener receives a message,
and the received message will be passed in as an argument. In this case
we simply print the content to console.</p>
<p>With the callback defined and the <code>Subscription</code> created, the rest of
the listener is one line:</p>
<pre><code class="language-{sourceCode .cpp}">  rclcpp::spin(node);
</code></pre>
<p>This call hands control over to <code>rclcpp</code> to wait for new messages to
arrive (and more generally for events to occur) and invoke our callback.</p>
<p>Back in the talker, we create a simple loop to use our <code>Publisher</code>:</p>
<pre><code class="language-{sourceCode .cpp}">  std_msgs::msg::String message;
  auto i = 0;
  while (rclcpp::ok()) {
    message.data = &quot;Hello world: &quot; + std::to_string(i++);
    std::cout &lt;&lt; &quot;Publishing: &quot; &lt;&lt; message.data &lt;&lt; std::endl;
    pub-&gt;publish(message);
    usleep(500000);
  }
</code></pre>
<p>In these steps we create a message object, and then on
each iteration of the loop we update the message content and publish
it, sleeping briefly between iterations.</p>
<h2 id="where-to-go-from-here"><a class="header" href="#where-to-go-from-here">Where to Go From Here</a></h2>
<p>That was a very brief introduction and we only covered topics, not
services, actions, parameters, or the many other facets of ROS. Luckily,
the online <a href="https://index.ros.org/doc/ros2/Tutorials">ROS tutorials</a> are
an excellent resource for learning about the rest of ROS. We
specifically recommend the <a href="https://index.ros.org/doc/ros2/Tutorials/#beginner-client-libraries">Beginner: Client
Libraries</a>
collection as a natural next step after reading this chapter.</p>
<h2 id="regarding-the-shortcuts"><a class="header" href="#regarding-the-shortcuts">Regarding the Shortcuts</a></h2>
<p>In this section we have presented the simplest, shortest example ROS
programs that we could come up with. Such programs are easy to
understand and learn from, as they do not have unnecessary structure or
decoration. But in exchange such programs are not easily extensible,
composable, or maintainable.</p>
<p>The techniques that we used in the example code in this section are
useful for prototyping and experimentation (an important aspect of any
good robotics project!), but we do not recommend them for serious work.
As you go through the <a href="https://index.ros.org/doc/ros2/Tutorials">ROS
tutorials</a> and start reading
existing ROS code, you will learn about a number of concepts, patterns,
and conventions, such as:</p>
<ul>
<li>organizing your code into <em>packages</em></li>
<li>organizing your packages into a <em>workspace</em></li>
<li>managing <em>dependencies</em> among packages</li>
<li>using the <code>colcon</code> tool to build code in multiple packages in dependency order</li>
<li>using the <code>ament</code> module in your <code>CMakeLists.txt</code> files</li>
<li>structuring your code to allow run-time control of how nodes maps to processes</li>
<li>using the client libraries' console-logging routines for output to screen and elsewhere</li>
</ul>
<p>These techniques will serve you well when you start building your own ROS
applications, especially when you want to share your code with others, whether
on your team or out in the world.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/ros2_api.md">Edit this page on GitHub.</a></footer>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ros2_cli.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="traffic-editor.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ros2_cli.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="traffic-editor.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
