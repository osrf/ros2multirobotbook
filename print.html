<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Programming Multiple Robots with ROS 2</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="open-in.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item "><a href="demos.html"><strong aria-hidden="true">1.2.</strong> Demos</a></li></ol></li><li class="chapter-item "><a href="ros2.html"><strong aria-hidden="true">2.</strong> ROS 2</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ros2_tools_resources.html"><strong aria-hidden="true">2.1.</strong> ROS Resources</a></li><li class="chapter-item "><a href="ros2_design_patterns.html"><strong aria-hidden="true">2.2.</strong> ROS Concepts and Design Patterns</a></li><li class="chapter-item "><a href="ros2_cli.html"><strong aria-hidden="true">2.3.</strong> The ROS Command Line Interface</a></li><li class="chapter-item "><a href="ros2_api.html"><strong aria-hidden="true">2.4.</strong> The ROS API</a></li></ol></li><li class="chapter-item "><a href="traffic-editor.html"><strong aria-hidden="true">3.</strong> Traffic Editor</a></li><li class="chapter-item "><a href="simulation.html"><strong aria-hidden="true">4.</strong> Simulation</a></li><li class="chapter-item "><a href="rmf-core.html"><strong aria-hidden="true">5.</strong> RMF Core Overview</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="rmf-core_faq.html"><strong aria-hidden="true">5.1.</strong> Frequently Asked Questions</a></li></ol></li><li class="chapter-item "><a href="task.html"><strong aria-hidden="true">6.</strong> Tasks in RMF</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="task_planner.html"><strong aria-hidden="true">6.1.</strong> RMF Task Allocation Planner</a></li><li class="chapter-item "><a href="task_types.html"><strong aria-hidden="true">6.2.</strong> Currently supported Tasks</a></li><li class="chapter-item "><a href="task_new.html"><strong aria-hidden="true">6.3.</strong> Supporting a new Task</a></li></ol></li><li class="chapter-item "><a href="soss.html"><strong aria-hidden="true">7.</strong> SOSS</a></li><li class="chapter-item "><a href="integration.html"><strong aria-hidden="true">8.</strong> Integration</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="integration_nav-maps.html"><strong aria-hidden="true">8.1.</strong> Navigation Maps</a></li><li class="chapter-item "><a href="integration_fleets.html"><strong aria-hidden="true">8.2.</strong> Mobile Robot Fleets</a></li><li class="chapter-item "><a href="integration_free-fleet.html"><strong aria-hidden="true">8.3.</strong> Free Fleet</a></li><li class="chapter-item "><a href="integration_read-only.html"><strong aria-hidden="true">8.4.</strong> Read-Only Fleets</a></li><li class="chapter-item "><a href="integration_doors.html"><strong aria-hidden="true">8.5.</strong> Doors</a></li><li class="chapter-item "><a href="integration_lifts.html"><strong aria-hidden="true">8.6.</strong> Lifts (Elevators)</a></li><li class="chapter-item "><a href="integration_workcells.html"><strong aria-hidden="true">8.7.</strong> Workcells</a></li></ol></li><li class="chapter-item "><a href="rmf-web.html"><strong aria-hidden="true">9.</strong> RMF Web</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ui.html"><strong aria-hidden="true">9.1.</strong> User Interfaces</a></li></ol></li><li class="chapter-item "><a href="security.html"><strong aria-hidden="true">10.</strong> Security</a></li><li class="chapter-item "><a href="roadmap.html"><strong aria-hidden="true">11.</strong> Roadmap</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Programming Multiple Robots with ROS 2</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/osrf/ros2multirobotbook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome!
This is a book about multi-robot systems.
Why?
Because it's the future!</p>
<p>Robots are becoming more affordable, more capable, and more useful in many &quot;real life&quot; scenarios.
As a result, we are seeing more and more robots that need to share spaces and work together to accomplish tasks. In this book, we will introduce the Robot Operating System 2 (ROS 2) as well as the Robot Middleware Framework (RMF), which is built on ROS 2 and tries to simplify the creation and operation of complex multi-robot systems.</p>
<p>This chapter describes the motivation and goals for ROS 2 and the RMF system for integrating multiple robots.</p>
<h1 id="ros-2"><a class="header" href="#ros-2">ROS 2</a></h1>
<p>The Robot Operating System (ROS) is a set of software libraries and tools for building robot applications.
From drivers to state-of-the-art algorithms, and with powerful developer tools, ROS has what you need for your next robotics project.
And it’s all open source.</p>
<p>Since ROS was started in 2007, a lot has changed in the robotics and ROS community.
ROS 1, originally just &quot;ROS&quot;, began life as the development environment for the Willow Garage PR2 robot, a high-performance mobile manipulation platform intended for advanced research and development.
The original goal of ROS was to provide the software tools users would need to undertake novel research and development projects with this robot.
At the same time, the ROS 1 development team knew the PR2 would not be the only robot in the world, nor the most important, so they wanted ROS 1 to be useful on other robots, too.
The original focus was on defining levels of abstraction (usually through message interfaces) that would allow much of the software to be reused elsewhere.</p>
<p>ROS 1 satisfied the PR2 use case, but also became useful on a surprisingly wide variety of robots.
This included robots similar to the PR2, but also wheeled robots of all sizes, legged humanoids, industrial arms, outdoor ground vehicles (including self-driving cars), aerial vehicles, surface vehicles, and more.
ROS 1 adoption also took a surprising turn, happening in domains beyond the mostly academic research community that was the initial focus.
ROS-1-based products were coming to market, including manufacturing robots, agricultural robots, commercial cleaning robots, and others.
Government agencies were also looking more closely at ROS for use in their fielded systems; NASA, for example, expected to run ROS on the Robonaut 2 deployed to the International Space Station.</p>
<p>All of these applications certainly grew the ROS platform in unexpected ways.
Though it held up well, the ROS 1 team believed they could better meet the needs of the broader ROS community by tackling their new use cases head-on.
And so, ROS 2 was born.</p>
<p>The initial goal of the ROS 2 project was to adapt to the changing landscape, leveraging what was great about ROS 1 and improving what wasn’t.
But there was also a desire to preserve ROS 1 as it existed, to continue working and remain unaffected by the development of ROS 2.
So, ROS 2 was built as a parallel set of packages that can be installed alongside and interoperate with ROS 1 (for example, through message bridges).</p>
<p>At the time of writing, we have reached the 13th and last official ROS 1 release, <a href="https://www.openrobotics.org/blog/2020/5/23/noetic-ninjemys-the-last-official-ros-1-release">Noetic Ninjemys</a>, and the first LTS release of ROS 2, <a href="https://www.openrobotics.org/blog/2020/6/5/ros-2-foxy-fitzroy-release">Foxy Fitzroy</a>.</p>
<p>A large and growing amount of ROS 2 resources can be found on the web.
A great place to start is on the ROS Index page for <a href="https://index.ros.org/doc/ros2/">ROS 2</a> and further along in this book in the ROS 2 chapter.</p>
<p>Enjoy your journey!</p>
<h1 id="robotics-middleware-framework-rmf"><a class="header" href="#robotics-middleware-framework-rmf">Robotics Middleware Framework (RMF)</a></h1>
<p>For a moment, think of any large building.
It could be a shopping mall, housing complex, university building, workplace, airport, hospital, hotel, and so on.
Are items delivered within the building?
Is the building floor cleaned regularly?
For most buildings, the answer to both questions is &quot;yes.&quot;</p>
<p>Now, let's think of what happens when robots start to perform those tasks.
In today's robot marketplace, you can purchase excellent delivery robots, as well as excellent floor-cleaning robots.
However, what if the floor is being cleaned at the same time that items are being delivered in the building?
This situation is trivial when humans are performing the cleaning and delivery tasks: a quick glance between a delivery person pushing a cart and a custodian cleaning the floor is all it takes to quickly reach a compromise.
One or both people will find a way to slightly alter the timing of their task to allow both tasks to be completed.</p>
<p>Unfortunately, robots are nowhere near as capable as humans at abstract reasoning, planning, and informal communication!
This type of scenario is what the Robotics Middleware Framework (RMF) tries to help avoid.
In today's marketplace, if all robots are purchased from the same manufacturer, the robots in such a single-vendor system will know of each other's existence and will avoid conflicting with each other.
However, multi-vendor, multi-robot systems remain an open problem, and we expect that multi-vendor robot deployments will be the norm in all large buildings in the future.
To address this situation, RMF provides a set of conventions, tools, and software implementations to allow multiple fleets of robots to interoperate with each other and with shared building infrastructure, such as lifts, doors, corridors, and other natural &quot;bottlenecks&quot; to traffic flows and tasks.</p>
<p>Without a framework for multi-vendor robotics in place, there can be significant but hidden risks for building operators and end users when they are forced to commit to a single system or platform provider.
Hidden risks are likely to force an end user to limit their selection of future solutions from that a single provider to minimize operational risk and avoid redundant integration costs.
As the scope and scale of robotic deployments increase, this problem is exacerbated, leaving the customer with the perception that there are no good options except to stay with their current provider, and preventing the use of robots from newer entrants to the marketplace.</p>
<p>Beyond the increased cost risk of scaling deployment with different providers, there is also the inherent conflict over shared resources such as lifts, doorways, corridors, network bandwidth, chargers, operations-center screen “real estate,” and human resources such as IT personnel and maintenance technicians.
As robotic scale increases, it becomes more cumbersome for an operations team to consider managing a large, heterogeneous, multi-vendor robot environment.</p>
<p>These problem statements were the foundational motivations for the development of RMF.</p>
<p>In the previous &quot;cleaning and delivery&quot; scenario, RMF can act as a traffic controller to help the delivery robot and cleaning robot negotiate a way for both tasks to be accomplished, depending on the relative priority and importance of each task.
If the cleaning task is urgent (perhaps a spill occurred in a busy corridor), RMF could route the delivery task through a different set of corridors.
If the delivery task is time-critical, RMF could direct the cleaning robot to pause its work and move out of the way until the delivery robot clears the corridor.
Of course, these solutions are obvious and could be easily hand-written for this particular &quot;cleaning and delivery&quot; corridor-sharing scenario. The challenge comes from trying to be generic across many scenarios, while also trying to be &quot;future proof&quot; to allow expansion to currently-unknown robots, applications, and task domains.</p>
<p>The rest of the book will dive into these details to show how RMF tries to foresee and prevent resource conflicts and improve the efficiency of multi-vendor, multi-robot systems.
There is no magic here!
All of the implementations are open-source and available for inspection and customization.</p>
<p>We would like to acknowledge the Singapore government for their vision and support to start this ambitious research and development project, &quot;<em>Development of Standardised Robotics Middleware Framework - RMF detailed design and common services, large-scale virtual test farm infrastructure, and simulation modelling</em>&quot;. The project is supported by the Ministry of Health (MOH) and National Robotics Program (NRP).</p>
<p>Any opinions, findings and conclusions or recommendations expressed in this material are those of the author(s) and do not reflect the views of the NR2PO and MOH.</p>
<h2 id="so-what-is-rmf"><a class="header" href="#so-what-is-rmf">So what is RMF?</a></h2>
<p>RMF is a collection of reusable, scalable libraries and tools building on top of ROS 2 that enable the interoperability of heterogeneous fleets of any type of robotic systems.
RMF utilizes standardized communication protocols to infrastructure, environments and automation where robots are deployed to optimize the use of critical resources (i.e. robots, lifts, doors, passageways, etc).
It adds intelligence to the system through resource allocation and by preventing conflicts over shared resources through the RMF Core which will be described in detail later in this book.</p>
<p>RMF is flexible and robust enough to operate over virtually any communications layer and integrate with any number of IOT devices.
The architecture of RMF is designed in such a way to allow scalability as the level of automation in an environment increases.
There are various ways for systems and users to interact with RMF via APIs and customizable user interfaces.
Once deployed in an environment, RMF will save costs by allowing resources to be shared and integrations to be minimized.
It is what robotic developers and robot customers have been looking for.
In a nutshell, here is RMF:</p>
<p><img src="images/grand_unified_diagram.png" alt="RMF Book Architecture Diagram" /></p>
<h2 id="how-does-rmf-make-the-magic-happen"><a class="header" href="#how-does-rmf-make-the-magic-happen">How does RMF make the magic happen?</a></h2>
<p>We will explore each of these functional areas in more detail in later chapters of this book, but for now we'd like to also introduce some of the other utilities helpful when developing and integrating with RMF.</p>
<h3 id="rmf-demos"><a class="header" href="#rmf-demos">RMF Demos</a></h3>
<p><a href="https://github.com/open-rmf/rmf_demos">The demos</a> are demonstrations of the capabilities of RMF in various environments.
This repository serves as a starting point for working and integrating with RMF.</p>
<h3 id="traffic-editor"><a class="header" href="#traffic-editor">Traffic Editor</a></h3>
<p><a href="https://github.com/open-rmf/rmf_traffic_editor">Traffic Editor</a> is a GUI for creating and annotating floorplans for use in RMF.
Through Traffic Editor you are able to create traffic patterns for use in RMF and introduce simulation models to enhance your virtual simulation environments.
The <code>.yaml</code> files can be easily exported for use in Gazebo.</p>
<h3 id="free-fleet"><a class="header" href="#free-fleet">Free Fleet</a></h3>
<p><a href="https://github.com/open-rmf/free_fleet">Free Fleet</a> is an open-source robot fleet management system for robot developers who do not have their own fleet manager or who would prefer to use and contribute to an open-source fleet management utility.</p>
<h3 id="rmf-schedule-visualizer"><a class="header" href="#rmf-schedule-visualizer">RMF Schedule Visualizer</a></h3>
<p>This <a href="https://github.com/open-rmf/rmf_visualization">visualizer</a> is an rviz-based <code>rmf_core</code> visualizer and control panel.
It is intended to be a functional tool for RMF developers.</p>
<h3 id="rmf-web-ui"><a class="header" href="#rmf-web-ui">RMF Web UI</a></h3>
<p><a href="http://github.com/open-rmf/rmf-web">rmf-web</a> is a configurable web application that provides overall visualization and control over the RoMi-H system.
The dashboard is by design more &quot;operator-friendly&quot; compared to the previously mentioned schedule visualizer.</p>
<h3 id="rmf-simulation"><a class="header" href="#rmf-simulation">RMF Simulation</a></h3>
<p><a href="https://github.com/open-rmf/rmf_simulation">rmf_simulation</a> contains the simulation plugins to simulate RMF. Plugins are available in <code>gazebo</code> and <code>ignition</code>.</p>
<h3 id="simulation-assets"><a class="header" href="#simulation-assets">Simulation Assets</a></h3>
<p>The open-source and freely distributable <a href="https://app.ignitionrobotics.org/fuel">simulation assets</a> are created and shared to accelerate simulation efforts.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/intro.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>For the latest instructions and updates please directly check the <a href="https://github.com/open-rmf/rmf/blob/main/README.md">open-rmf/rmf repository</a>.</p>
</blockquote>
<h2 id="install-ros-2"><a class="header" href="#install-ros-2">Install ROS 2.</a></h2>
<p>First, please follow the installation instructions for ROS 2.
If you are on an Ubuntu 20.04 LTS machine (as recommended), <a href="https://docs.ros.org/en/galactic/Installation/Ubuntu-Install-Debians.html">here is the binary install page for ROS 2 Galactic on Ubuntu 20.04</a>.</p>
<h2 id="setup-gazebo-repositories"><a class="header" href="#setup-gazebo-repositories">Setup Gazebo repositories</a></h2>
<p>Setup your computer to accept Gazebo packages from packages.osrfoundation.org.</p>
<pre><code class="language-bash">sudo apt update
sudo apt install -y wget
sudo sh -c 'echo &quot;deb http://packages.osrfoundation.org/gazebo/ubuntu-stable `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/gazebo-stable.list'
wget https://packages.osrfoundation.org/gazebo.key -O - | sudo apt-key add -
</code></pre>
<h2 id="binary-install"><a class="header" href="#binary-install">Binary install</a></h2>
<p>OpenRMF binary packages are available for Ubuntu Focal 20.04 for the <code>Foxy</code>, <code>Galactic</code> and <code>Rolling</code> releases of ROS 2. Most OpenRMF packages have the prefix <code>rmf</code> on their name, therefore, you can find them by them by searching for the pattern <code>ros-&lt;ro2distro&gt;-rmf</code></p>
<pre><code class="language-bash">apt-cache search ros-&lt;ro2distro&gt;-rmf
</code></pre>
<h3 id="rmf-demos-1"><a class="header" href="#rmf-demos-1">RMF Demos</a></h3>
<p>A good way to install the <code>rmf</code> set of packages in one go is to install the one of the main <a href="https://github.com/open-rmf/rmf_demos">RMF Demos</a> packages. This will pull all the rest of the OpenRMF packages as a dependency. The core of RMF demos is contained on the <code>rmf_demos</code> package. However, if you want to install it with simulation support, you should install the <code>rmf_demos_gz</code> or <code>rmf_demos_ign</code> package which come with gazebo or ignition support respectively. To install the ROS 2 release with gazebo support package, you would run:</p>
<pre><code class="language-bash">sudo apt install ros-&lt;ro2distro&gt;-rmf-demos-gz
</code></pre>
<h2 id="building-from-sources"><a class="header" href="#building-from-sources">Building from sources</a></h2>
<p>If you want to get the latest developments you might want to install from sources and compile OpenRMF yourself.</p>
<h3 id="additional-dependencies"><a class="header" href="#additional-dependencies">Additional Dependencies</a></h3>
<p>Install all non-ROS dependencies of OpenRMF packages,</p>
<pre><code class="language-bash">sudo apt update &amp;&amp; sudo apt install \
  git cmake python3-vcstool curl \
  qt5-default \
  -y
python3 -m pip install flask-socketio
sudo apt-get install python3-colcon*
</code></pre>
<h3 id="install-rosdep"><a class="header" href="#install-rosdep">Install rosdep</a></h3>
<p><code>rosdep</code> helps install dependencies for ROS packages across various distros. It can be installed with:</p>
<pre><code class="language-bash">sudo apt install python3-rosdep
sudo rosdep init
rosdep update
</code></pre>
<h3 id="download-the-source-code"><a class="header" href="#download-the-source-code">Download the source code</a></h3>
<p>Setup a new ROS 2 workspace and pull in the demo repositories using <code>vcs</code>,</p>
<pre><code class="language-bash">mkdir -p ~/rmf_ws/src
cd ~/rmf_ws
wget https://raw.githubusercontent.com/open-rmf/rmf/main/rmf.repos
vcs import src &lt; rmf.repos
</code></pre>
<p>Ensure all ROS 2 prerequisites are fulfilled,</p>
<pre><code>cd ~/rmf_ws
rosdep install --from-paths src --ignore-src --rosdistro &lt;ro2distro&gt; -y
</code></pre>
<h3 id="compiling-instructions"><a class="header" href="#compiling-instructions">Compiling Instructions</a></h3>
<blockquote>
<p>NOTE: Due to newer changes in the source build, there might be conflicts and compilation errors with older header files installed by the binaries. Please remove the binary installations before building from source, using <code>sudo apt remove ros-&lt;ro2distro&gt;-rmf*</code>.</p>
</blockquote>
<p>Compiling on <code>Ubuntu 20.04</code>:</p>
<pre><code class="language-bash">cd ~/rmf_ws
source /opt/ros/&lt;ro2distro&gt;/setup.bash
colcon build --cmake-args -DCMAKE_BUILD_TYPE=Release
</code></pre>
<blockquote>
<p>NOTE: The first time the build occurs, many simulation models will be downloaded from Ignition Fuel to populate the scene when the simulation is run.
As a result, the first build can take a very long time depending on the server load and your Internet connection (for example, 60 minutes).</p>
</blockquote>
<h2 id="run-rmf-demos"><a class="header" href="#run-rmf-demos">Run RMF Demos</a></h2>
<p>Demonstrations of OpenRMF are shown in <a href="https://github.com/open-rmf/rmf_demos/">rmf_demos</a>.</p>
<h3 id="docker-containers"><a class="header" href="#docker-containers">Docker Containers</a></h3>
<p>Alternatively, you can run RMF Demos by using <a href="https://docs.docker.com/engine/install/ubuntu/">docker</a>.</p>
<p>Pull docker image from <code>open-rmf/rmf</code> github registry (setup refer <a href="https://docs.github.com/en/free-pro-team@latest/packages/using-github-packages-with-your-projects-ecosystem/configuring-docker-for-use-with-github-packages#authenticating-with-a-personal-access-token">here</a>).</p>
<pre><code class="language-bash">docker pull ghcr.io/open-rmf/rmf/rmf_demos:latest
docker tag ghcr.io/open-rmf/rmf/rmf_demos:latest rmf:latest
</code></pre>
<p>Run it!</p>
<pre><code class="language-bash">
docker run -it --network host rmf:latest bash -c &quot;export ROS_DOMAIN_ID=9; ros2 launch rmf_demos_gz office.launch.xml headless:=1&quot;
</code></pre>
<p>This will run <code>rmf_demos</code> in headless mode. Open <a href="https://open-rmf.github.io/rmf-panel-js/">this link</a> with a browser to start a task.</p>
<p>(Experimental) User can also run <code>rmf_demos</code> in “non-headless” graphical form, via <a href="https://github.com/osrf/rocker">rocker</a>.</p>
<h2 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h2>
<p>A near-term roadmap of the entire OpenRMF project (including and beyond <code>rmf_traffic</code>) can be found in the user manual <a href="https://osrf.github.io/ros2multirobotbook/roadmap.html">here</a>.</p>
<h2 id="integrating-with-rmf"><a class="header" href="#integrating-with-rmf">Integrating with RMF</a></h2>
<p>Instructions on how to integrate your system with OpenRMF can be found <a href="https://osrf.github.io/ros2multirobotbook/integration.html">here</a>.</p>
<h2 id="open-sourced-fleet-adapters"><a class="header" href="#open-sourced-fleet-adapters">Open sourced fleet adapters</a></h2>
<p>A number of commercial robots have been integrated with RMF and links to their adapters are available below.</p>
<ul>
<li><a href="https://github.com/open-rmf/fleet_adapter_ecobot">Gaussian Ecobots</a></li>
<li><a href="https://github.com/open-rmf/fleet_adapter_clearpath">OTTO Motors</a> (and robots running the Clearpath Autonomy stack)</li>
<li><a href="https://github.com/osrf/fleet_adapter_mir">Mobile Industrial Robots: MiR</a></li>
<li><a href="https://github.com/open-rmf/temi_fleet_adapter_python">Temi- the personal robot</a></li>
</ul>
<p>Help us add to this list!</p>
<p>A helpful starting point for integrating your fleet with RMF is the <a href="https://github.com/open-rmf/free_fleet">fleet_adapter_template</a> package.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/installation.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h2 id="demos"><a class="header" href="#demos">Demos</a></h2>
<p>In this chapter, we will briefly demonstrate the capability of RMF with <code>rmf_demos</code>. 
This will give users a brief understanding of the core features of RMF.</p>
<blockquote>
<p>For the most updated rmf_demos run instruction, please refer to <a href="https://github.com/open-rmf/rmf_demos">here</a>.</p>
</blockquote>
<p>First make sure, you have have installed the provided RMF demos from their Debian package:</p>
<pre><code class="language-bash"># Demos example with gazebo simulator, use ros-foxy-rmf-demos-ign for ignition
sudo apt-get install ros-foxy-rmf-demos-gz
</code></pre>
<p>Run your desired demo. In this case we will run the <code>airport terminal</code>:</p>
<p>Before running the demo, we can ensure all required models are downloaded locally by:</p>
<pre><code class="language-bash">ros2 run rmf_building_map_tools model_downloader rmf_demos_maps -s airport_terminal
</code></pre>
<pre><code class="language-bash">ros2 launch rmf_demos_gz airport_terminal.launch.xml
# or with ignition
ros2 launch rmf_demos_ign airport_terminal.launch.xml
</code></pre>
<p>Now you should be able to see the airport terminal with the robots in Gazebo:</p>
<p><img src="images/intro/install_run_RMF/airport_gazebo.png" alt="Airport Terminal Gazebo" /></p>
<p>The RMF Schedule Visualizer should have loaded in an rviz window. This canvas will display all integrated robots or infrastructure which are available to RMF.</p>
<p><img src="images/intro/install_run_RMF/airport_rviz.png" alt="Airport Terminal Rviz" /></p>
<p>During a task request, instead of requiring the user to specify the robot name to complete a task, RMF will assign the task to the best robot. </p>
<p>RMF currently suports 3 types of task, namely: <code>loop</code>, <code>delivery</code> or <code>clean</code> . User can submit a task via  CLI:</p>
<p><strong>Loop Task</strong></p>
<pre><code>ros2 run rmf_demos_tasks dispatch_loop -s s07 -f n12 -n 3 --use_sim_time
</code></pre>
<p><strong>Delivery Task</strong></p>
<pre><code>ros2 run rmf_demos_tasks dispatch_delivery -p mopcart_pickup -pd mopcart_dispenser -d spill -di mopcart_collector --use_sim_time
</code></pre>
<p><strong>Clean Task</strong></p>
<pre><code>ros2 run rmf_demos_tasks dispatch_clean -cs zone_3 --use_sim_time
</code></pre>
<p>Now you can observe robots roaming around the airport space!</p>
<p><strong>rmf_panel</strong>
Another way to observe and interact with RMF is via a web <code>rmf_panel</code>. Open the webpage: <code>firefox https://open-rmf.github.io/rmf-panel-js/</code> or click <a href="https://open-rmf.github.io/rmf-panel-js/">here</a></p>
<p><img src="images/intro/install_run_RMF/airport_web_RMFPanel.png" alt="Web rmf panel" /></p>
<p>You can view the status of all the robots under RMF. To request a list of tasks, first select the <code>Airport</code> tab. User can choose to submit a (1) Adhoc task or (2) Task List.</p>
<p>Copy paste this to the Task List Box. (or open a file)</p>
<pre><code class="language-json">[{&quot;task_type&quot;:&quot;Delivery&quot;, &quot;start_time&quot;:0, &quot;description&quot;: {&quot;option&quot;: &quot;mop&quot;}},
 {&quot;task_type&quot;:&quot;Loop&quot;, &quot;start_time&quot;:0, &quot;description&quot;: {&quot;num_loops&quot;:10, &quot;start_name&quot;:&quot;junction_north_west&quot;, &quot;finish_name&quot;:&quot;n14&quot;}},
 {&quot;task_type&quot;:&quot;Loop&quot;, &quot;start_time&quot;:0, &quot;description&quot;: {&quot;num_loops&quot;:10, &quot;start_name&quot;:&quot;tinyRobot_n09&quot;, &quot;finish_name&quot;:&quot;s07&quot;}},
 {&quot;task_type&quot;:&quot;Clean&quot;, &quot;start_time&quot;:0, &quot;priority&quot;:0, &quot;description&quot;:{&quot;cleaning_zone&quot;:&quot;zone_2&quot;}}
]
</code></pre>
<p>Then Click Submit to submit the list of tasks:
<img src="images/intro/install_run_RMF/airport_web_RMFPanel_tasks.png" alt="Airport Terminal RMF Panel" /></p>
<p>Now, sit back and enjoy.</p>
<h2 id="jump-in-the-water-is-fine"><a class="header" href="#jump-in-the-water-is-fine">Jump in, the water is fine!</a></h2>
<p>So now you have an idea of what RMF is all about, it's time to jump in. We would suggest if you have not already that you take the time to review the <a href="https://github.com/open-rmf/rmf_demos">RMF Demos</a> repository and if you want a really quick overview of RMF then take a look at this <a href="https://vimeo.com/405803151">Mock Airport Terminal video demo</a> (Short film Oscar nominations most welcome). We hope you find RMF to be a useful tool to help you scale your robot deployments and operations and we look forward to the many improvements and contributions to come!</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/demos.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="an-introduction-to-ros-2"><a class="header" href="#an-introduction-to-ros-2">An Introduction to ROS 2</a></h1>
<p>In this chapter we will cover the basics of Robot Operating System (ROS) and
give you all the tools you need to build, debug, and understand robotic
applications. This chapter is laid out from the most general concepts, necessary
for decision makers to make sound decisions, to specific API references needed
by engineers to develop new robotic applications. Somewhere in between high
level concepts, and low level API commands lives the knowledge necessary for
those maintaining and supporting multi-robot deployments in the field.</p>
<p>A good analogy to learning about ROS is the process of learning about motor
vehicles. At the practical, day-to-day level, most people will learn how to
start a vehicle and safely use it on a motorway. For these individuals, learning
about the high level concepts behind ROS, along with application-specific
commands is probably sufficient. Those who enjoy driving often choose to learn
how to repair and maintain their vehicle. If this is your interest level we
recommend learning the basics of the ROS command line interface. This will allow
you to &quot;check the oil&quot; of your robotic systems and make sure everything is
functioning correctly. Finally, if you are the type that would like to swap out
the engine of your vehicle with something more powerful, or potentially build a
wholly new vehicle from scratch, then the ROS API is the set of tools that will
make this possible. Generally speaking, automotive engineers don't appear into
the world fully formed, and the same is true for roboticists. It is advisable to
work through each phase of understanding as you develop your skills with ROS.</p>
<p>Following from our analogy above the process of learning how to use robotic
systems built on ROS can be divided roughly into four parts. This chapter works
through these four parts of the process, using ROS 2. Subsequent chapters then
build upon this knowledge and discuss the subtleties of specific
applications. The four parts of this chapter are as follows.</p>
<ul>
<li>
<p>Meta-discussion of the tools and resources available to help you in the
learning process.</p>
</li>
<li>
<p>A high level discussion to the design patterns used in ROS. These patterns are
roughly analogous to the subsystems you would find in a vehicle (engine,
brakes, safety, climate control, etc).</p>
</li>
<li>
<p>A treatment of the command line interface (CLI) for ROS. The CLI is a set of
programs for starting, inspecting, controlling, and monitoring a ROS
robot. You can think of this topic as teaching you how check a robot's oil,
and read the instrument panel.</p>
</li>
<li>
<p>An introduction to the ROS application programming interface. This section
will show you how to create your own applications and modify existing software
for your specific application.</p>
</li>
</ul>
<p>While this book aims to cover the basics it should be made clear that ROS, like
almost all software, is a moving target. Technology moves quickly, and while
print media is helpful at delivering high fidelity instruction, that
instruction can become rapidly outdated. For this reason we start this chapter
with a meta-discussion of ROS resources that can be used to help you in your
learning process.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/ros2.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="ros-kick-off"><a class="header" href="#ros-kick-off">ROS Kick Off</a></h1>
<p>This chapter describes the avenues available for learning about and getting help
with ROS, as well as how to get started by setting up and installing ROS.</p>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<p>The most up to date information about ROS can be found on the web. There are a
myriad of resources on-line to help you out in your educational or
practical journey. One thing to keep in mind is that ROS, like most software,
has different versions, and the format and structure of commands and API calls
may differ slightly between versions (although the developers try to keep things
as stable as possible). This book is specifically written for <em>ROS 2, Eloquent
Elusor</em>, or ROS Eloquent to be terse.</p>
<p>While newer or older versions of ROS 2 will be generally similar, it is worth paying
attention to the distribution name or version number as there are changes between
versions. A major version of ROS 2 generally corresponds to a distribution, denoted by
a pair of matching letter adjectives and specific nouns related to specific genus
and species of turtles (e.g. Eloquent Elusor, or Foxy Fitzroy). It is worth noting
that ROS versions are usually pegged to specific version of Ubuntu Linux.</p>
<p>ROS grew up with the modern web, and as such it has a variety of resources and
forums to help you solve problems and learn about the API and tools. Some of our
web resources actually pre-date more widely used systems, so it helps to know
where they are and how to use them. Probably the most important resource on the
web for ROS users is <a href="http://anwers.ros.org">answers.ros.org</a>. Answers is a Q&amp;A
website similar to StackOverflow. Once you register for Answers you can ask or
answer any ROS-related question. Be aware that asking a question well can be
difficult. You should include as much information as possible to help others
answer your question. This means you should include the ROS version, platform version,
any debugging or stack trace information you have, and the offending source code.</p>
<p>Aside from ROS Answers you should check out both the ROS 2 tutorials and API
documentation, and the ROS 1 wiki. The ROS 1 wiki can be found at
<a href="http://wiki.ros.org/">wiki.ros.org</a>. While it is specifically
dedicated to ROS 1, much of the information is still relevant to ROS 2. If you
are searching for up to date ROS 2 information, your go to source is the ROS 2 tutorials and API documents located at
<a href="https://index.ros.org/doc/ros2/">index.ros.org/doc/ros2</a>. Many of
the tutorials you will find in this book pull directly from this body of
work. If you would like to find the latest ROS news and discuss various ROS
features, the ROS Discourse forum at
<a href="https://discourse.ros.org/">discourse.ros.org</a> is your best bet. ROS
discourse is the community hub where developers discuss their latest projects
and debate the finer points of ROS development.</p>
<p>For ROS application developers there are a number of tools to help you connect
with the broader ROS developer community. Open Robotics supports
<a href="https://index.ros.org/">index.ros.org</a>, which is an extended list of ROS
packages sorted by version. If you are searching for a ROS driver for a
particular piece of hardware, then the index is a great place to start. If you
find a package with failing tests, or would like to know the build status of any
ROS package, take a look at <a href="http://build.ros.org/">build.ros.org</a>. Similarly, for un-indexed
packages <a href="https://github.com/topics/ros?o=desc&amp;s=updated">GitHub maintains a ROS code tag</a>.
This tag will allow you to search all of the tagged repositories that are publicly listed.
At the time of writing there were close to 4000 repositories listed on GitHub, so there is a
pretty good chance you'll find what you need.</p>
<p>Finally, there are a variety of unofficial resources that you should be aware of
that can be useful, particularly if you want to keep yourself up to date with
the latest ROS projects and features. Both <a href="https://twitter.com/openroboticsorg">Open Robotics</a> and
<a href="https://twitter.com/rosorg">ROS</a> maintain  twitter feeds to share the latest
news. We also have a yearly ROS developers conference called
<a href="https://roscon.ros.org/2020/">ROSCon</a>; most talks are freely available
on the web. There are a few other resources that can also be useful including the <a href="https://www.reddit.com/r/ROS/">ROS subreddit</a>
and an &quot;unofficial&quot; <a href="https://discord.com/invite/HnVcz5a">ROS Discord</a>.</p>
<h2 id="setting-up-your-computer"><a class="header" href="#setting-up-your-computer">Setting Up Your Computer</a></h2>
<p>For this chapter we assume that you are working on a modern desktop with a
discrete graphics card. While a graphics card isn't necessary for this chapter,
later chapters will be graphics intensive and having one will greatly improve
the end user experience. Moreover, this book assumes you are working with the
Ubuntu Linux 18.04 operating system. While other operating systems are supported
by ROS 2, all of the tutorials and instructions on this book assume you are
running Linux. If instead you're using a Mac or Windows PC, you can install ROS 2
Eloquent Elusor using the instructions found on the <a href="https://index.ros.org/doc/ros2/Installation/Eloquent/">ROS 2 installation instructions</a>
page. An alternative path for installation on Mac and PC is to using a virtual
machine. Roughly the process for doing so is as follows:</p>
<ol>
<li>Install virtual machine software like <a href="https://www.virtualbox.org/">Virtual
Box</a> or
<a href="https://www.vmware.com/products/workstation-pro.html">VMWare</a> on your host
machine.</li>
<li>Create a virtual machine using the software, and install <a href="https://ubuntu.com/download/desktop">Desktop Ubuntu 18.04 Bionic
Beaver from the Canonical website.</a>
Configure the installation as you wish.</li>
<li>Now start your virtual machine and log in as a user. The directions below
should be applicable.</li>
</ol>
<p>For these initial tutorials we will be working with the pre-compiled ROS 2:
Eloquent Elusor desktop version. These directions follow directly from the
installation instructions found on the [Eloquent installation
page]https://index.ros.org/doc/ros2/Installation/Eloquent/Linux-Install-Debians/). To
run these commands you'll need a terminal window. To open a terminal in Ubuntu
18.04 click on the nine dots in the bottom left hand of the screen. A dialog
should appear. Enter the word <em>terminal</em> and click on the terminal icon to open
a terminal. Alternatively, you can press the control, alt, and 't' keys
simultaneously to open a terminal (we abbreviate this <code>CTRL-ALT-T</code>).</p>
<h2 id="setup-locale"><a class="header" href="#setup-locale">Setup Locale</a></h2>
<p>The first step is to make sure you have a locale which supports <code>UTF-8</code>. What this means is that we
will check that the language used by your computer uses a particular format of
text. If you are in a minimal environment, such as a Docker container, the locale may be
something minimal like POSIX. We test with the following settings. It
should be fine if you're using a different UTF-8 supported locale.</p>
<pre><code class="language-{.sourceCode .bash}">sudo locale-gen en_US en_US.UTF-8
sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8
export LANG=en_US.UTF-8
</code></pre>
<h2 id="setup-sources"><a class="header" href="#setup-sources">Setup Sources</a></h2>
<p>You will need to add the ROS 2 apt repositories to your system. Out of the box
Ubuntu doesn't know where the ROS 2 binary programs live so we have to give it a
secure location. To do this the computer will prompt you for your root
password. For more technical readers we need to authorize the ROS GPG key with
apt by typing the following command in the terminal:</p>
<pre><code class="language-{.sourceCode .bash}">sudo apt update &amp;&amp; sudo apt install curl gnupg2 lsb-release
curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add -
</code></pre>
<h2 id="install-ros-2-packages"><a class="header" href="#install-ros-2-packages">Install ROS 2 Packages</a></h2>
<p>The next steps for installing ROS is to do a system update (i.e. check for newer
programs) and then install ROS Eloquent. To do this we run the following
commands. Be aware that these commands will download a lot of data and may take
awhile. It is best to run these commands on your home network.</p>
<pre><code class="language-{.sourceCode .bash}">sudo apt update
</code></pre>
<p>Desktop Install (Recommended): ROS, RViz, demos, tutorials.</p>
<pre><code class="language-{.sourceCode .bash}">sudo apt install ros-eloquent-desktop
</code></pre>
<p>Next we'll install a set of tutorials called <code>TurtleSim</code>. To do this we run
another apt command.</p>
<pre><code class="language-{.sourceCode .bash}">sudo apt install ros-eloquent-turtlesim
</code></pre>
<p>ROS 2 command line tools use argcomplete for autocompletion. If you
want autocompletion, installing argcomplete is necessary. We're also going to
install a few other tools to make our lives easier.</p>
<pre><code class="language-{.sourceCode .bash}">sudo apt install python3-argcomplete htop byobu
</code></pre>
<h2 id="check-your-installation"><a class="header" href="#check-your-installation">Check Your Installation</a></h2>
<p>ROS uses <code>environment variables</code> to help keep track of what version of ROS is
running and where all the programs using ROS are on the computer. To set
these environment variables we <code>source</code>, or load, a bash script file. A bash
script file isn't magic; it is a series of commands to enter into the
terminal, just like the series of commands we just entered to setup ROS. It is
possible to have different versions of ROS running on a single computer. Using
the wrong version of ROS can lead to all sorts of problems and is a common
mistake for new users! If you are having problems, try sourcing the correct ROS
bash file. From now on, whenever you open a new terminal, you will
need to tell the computer which version of ROS to use. To set the necessary
environment variables for ROS you need to <code>source</code> a bash file every time you
open a new terminal. Yes, this is annoying, but it is a sound approach as it
makes the version of ROS you are using explicit. On Ubuntu 18.04 all versions of
ROS live in <code>/opt/ros/</code>. Inside this directory will be a programs and scripts
file to run ROS. To tell the operating system that we want to use ROS Eloquent
we simply source the ROS Eloquent <code>setup.bash</code> file using the command below:</p>
<pre><code class="language-{.sourceCode .bash}">source /opt/ros/eloquent/setup.bash
</code></pre>
<p>Once that command runs, your terminal should be ready to run a ROS program. Let's
test our installation by running two small ROS programs called <code>talker</code> and
<code>listener</code>. These two programs will send data back and forth using ROS to
perform the communication. One program was written in C++ and the other in
Python. Running these two different programs is a quick and easy way to check
that your ROS system is configured correctly. To start the talker run the following command:</p>
<pre><code class="language-{.sourceCode .bash}">source /opt/ros/eloquent/setup.bash
ros2 run demo_nodes_cpp talker
</code></pre>
<p>If everything is working correctly you should see something like the following:</p>
<pre><code class="language-{.sourceCode .bash}">[INFO] [talker]: Publishing: 'Hello World: 1'
[INFO] [talker]: Publishing: 'Hello World: 2'
[INFO] [talker]: Publishing: 'Hello World: 3'
....
</code></pre>
<p>Now, let's fire up the listener. We're going to use a Python listener in this
example to make sure we installed Python correctly. First we will need a second terminal. We can
open a new terminal tab by entering <code>CTRL-SHIFT-T</code> in our terminal. We can also
create a wholly new terminal by pressing <code>CTRL-ALT-T</code>. Pick whatever works best
for you. Now in your new terminal source your bash file and run the following
command:</p>
<pre><code class="language-{.sourceCode .bash}">source /opt/ros/eloquent/setup.bash
ros2 run demo_nodes_py listener
</code></pre>
<p>If everything is working correctly you should see something like the following:</p>
<pre><code class="language-{.sourceCode .bash}">[INFO] [listener]: I heard: [Hello World: 264]
[INFO] [listener]: I heard: [Hello World: 265]
[INFO] [listener]: I heard: [Hello World: 266]
</code></pre>
<p>Now that we have tested our ROS installation we can stop these two programs. In
ROS most programs run in infinite loops until the robot is shut down. To stop
these programs we navigate to the terminal running the program and press the
<code>Ctrl</code> and <code>C</code> keys simultaneously. We call this combo <code>CTRL-C</code> and you can use
it to stop just about any program in a terminal. Use it to stop the talker and
listener programs.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/ros2_tools_resources.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="ros-concepts-and-design-patterns"><a class="header" href="#ros-concepts-and-design-patterns">ROS Concepts and Design Patterns</a></h1>
<p>As we said, learning about ROS is similar to learning about an
automobile. In fact, a car is a lot like a robot (and sometimes it
really is a robot; see the large and active self-driving vehicle
industry). A modern automobile comprises many parts that are
connected to each other. The steering wheel is connected to the front
axle, the brake pedal is connected to the brake calipers, the oxygen
sensor is connected to the fuel injectors, and so on. From this
perspective, a car is a <em>distributed system</em>: each part plays a
well-defined role, communicating (whether electrically or mechanically)
as needed with other parts, and the result of that symphony-like
coordination is a working vehicle.</p>
<p>A key philosophical tenet of ROS is that robotics software should also
be designed and developed as a distributed system. We aim to separate
the functions of a complex system into individual parts that interact
with each other to produce the desired behavior of that system. In ROS
we call those parts <em>nodes</em> and we call the interactions between them
<em>topics</em> (and sometimes <em>services</em>, but we will get to that).</p>
<h2 id="the-ros-communication-graph"><a class="header" href="#the-ros-communication-graph">The ROS Communication Graph</a></h2>
<p>Imagine we are building a wheeled robot that chases a red ball. This
robot needs a camera with which to see the ball, a vision system to
process the camera images to figure out where the ball is, a control
system to decide what direction to move, and some motors
to move the wheels to allow it to move toward the ball. Using ROS we
might construct the system like so:</p>
<p><img src="./images/ros_graph_example.png" alt="image" /></p>
<p>This design separates the software into four ROS <em>nodes</em>: two device
drivers and two algorithms. Those nodes communicate with each other as
shown, via three ROS <em>topics</em>. We call this structure a <em>ROS
communication graph</em>: the nodes are the graph vertices and the topics
are the graph edges. You can tell a lot about a ROS system by examining
its communication graph.</p>
<p>The camera driver node is responsible for handling the details of
interacting with the physical camera, which might happen through a
custom USB protocol, through a vendor-provided library, or in some other
way. Whatever those details, they are encapsulated inside the camera
driver node, which presents a standard <em>topic</em> interface to the rest of
the system. As a result, the blob finder node does not need to know
anything about the camera; it simply receives image data in a standard
format that is used for all cameras in ROS. The output of the blob
finder is the detected location of the red ball, also in a standard
format. Then the target follower node can read in the ball location and
produce the steering direction needed to move toward the ball, again in
a standard format. Finally, the motor driver node's responsibility is to
convert the desired steering direction into the specific instructions
necessary to command the robot's wheel motors accordingly.</p>
<h2 id="publish-subscribe-messaging-topics-and-types"><a class="header" href="#publish-subscribe-messaging-topics-and-types">Publish-Subscribe Messaging: Topics and Types</a></h2>
<p>With the example of the ball-chasing robot in mind, we can add some terminology
to describe what is happening as the system operates. First, the ROS
communication graph is based on a well-known pattern called <em>publish-subscribe
messaging</em>, or simply <em>pub-sub</em>. In a pub-sub system, as the name implies, data
are sent as <em>messages</em> from <em>publishers</em> to <em>subscribers</em>. A publisher may have
zero, one, or multiple subscribers listening to its published messages. Messages
may be published at any time, making the system <em>asynchronous</em>.</p>
<p>In ROS, nodes publish and subscribe via topics, each of which has a name and a
type. A publisher announces that it will be publishing data by <em>advertising</em> a
topic. For example, the camera driver node may advertise a topic named <code>/image</code>
with type <code>sensor_msgs/Image</code>. If the blob finder node subscribes to a topic
with the same name and type, then the two nodes find each other and establish a
connection over which image messages can get from the camera driver to the blob
finder (the nodes find each other and establish those connections in a process
called <em>discovery</em>, which will be covered in detail later in this book). Each
message that flows across the <code>/image</code> topic will be of type
<code>sensor_msgs/Image</code>.</p>
<p>A single node can be (and often is) both a publisher and a subscriber. In our
example, the blob finder subscribes to image messages and publishes ball
location messages. Similarly the target follower subscribes to ball location
messages and publishes steering direction messages.</p>
<p>A topic's type is very important. In fact, taken together, the ROS types are
among the most valuable aspects of the entire platform. First, a type tells you
the syntax: which fields, of which types, does the message contain? Second, it
tells you the semantics: what do those fields mean and how should they be
interpreted? For example, a thermometer and a pressure sensor might produce what
appear to be the same data: a floating-point value. But in ROS, a well-designed
thermometer driver node would publish one clearly defined type (say,
<code>sensor_msgs/Temperature</code>), while a pressure sensor driver node would publish
another (say, <code>sensor_msgs/FluidPressure</code>).</p>
<p>We always advise the use of semantically meaningful message types.
For example, ROS provides simple message types like <code>std_msgs/Float64</code>, which
contains a single 64-bit floating-point field called <code>data</code>. But you should only
use that sort of generic type for rapid prototyping and experimenting. When you
build a real system, even if something like <code>std_msgs/Float64</code> could get the job
done on syntax, you should instead find or define a message that also matches
the semantics of your application.</p>
<h2 id="why-publish-subscribe"><a class="header" href="#why-publish-subscribe">Why Publish-Subscribe?</a></h2>
<p>Given that it comes with additional complexity (nodes, topics, types, etc.), it
is reasonable to ask why ROS follows the pub-sub pattern. After more than a
decade of building and deploying ROS-based robot systems, we can identify
several key benefits:</p>
<ul>
<li><strong>Substitution</strong>: If we decide to upgrade the robot's camera, we need
only modify or replace the camera driver node. The rest of the system
never knew the details of the camera anyway. Similarly, if we find a
better blob finder node, then we can just swap it in for the old one and
nothing else changes.</li>
<li><strong>Reuse</strong>: A well-designed blob finder node can be used today on this
robot to chase the red ball, then reused tomorrow on a different robot
to chase an orange cat, and so on. Each new use of a node should require only
configuration (no code) changes.</li>
<li><strong>Collaboration</strong>: By cleanly separating concerns between nodes, we
let our blob finder expert do their work independently of the target
follower expert, with neither of them bothering the device driver
expert. It is often the case that a robot application requires the
combined expertise of many people, and it would be difficult to
overstate the importance of ensuring that they can each contribute
confidently and efficiently.</li>
<li><strong>Introspection</strong>: Because the nodes are explicitly communicating with
each other via topics, we can listen in. So when the robot fails to
chase the red ball, and we think that the problem is in the blob finder,
we can use developer tools to visualize, log, and play back that node's
inputs and outputs. The ability to introspect a running system in this
way is instrumental to being able to debug it.</li>
<li><strong>Fault tolerance</strong>: Say that the target follower node crashes because
of a bug. If it is running in its own process, then that crash will
not bring down the rest of the system, and we can get things working
again by just restarting the target follower. In general with ROS we
have the choice to run nodes in separate processes, which allows for
such fault tolerance, or run them together in a single process, which
can provide higher performance (and of course we can mix and match the
two approaches).</li>
<li><strong>Language independence</strong>: It can happen that our blob finder expert
writes their computer vision code in C++, while our target follower
expert is dedicated to Python. We can accommodate those preferences
easily by just running those nodes in separate processes. In ROS, it is
perfectly reasonable, and in fact quite common, to mix and match the use
of languages in this way.</li>
</ul>
<h2 id="beyond-topics-services-actions-and-parameters"><a class="header" href="#beyond-topics-services-actions-and-parameters">Beyond Topics: Services, Actions, and Parameters</a></h2>
<p>Most ROS data flows over topics, which we introduced in the previous
sections. Topics are best for streaming data, which includes a lot of
the common use cases in robotics. For example, going back to our
ball-chasing robot, most cameras will naturally produces a stream of
images at some rate, say, 30Hz. So it makes sense for the camera driver
to publish the ROS messages containing those images just as soon as
they're received. Then the blob finder will be receiving image messages
at 30Hz, so it might as well publish its ball location messages at the
same rate, and so on, through the target follower to the motor driver.
We might say that such a systems is <em>clocked from the camera</em>: the data
rate of the primary sensor, the camera in this case, drives the rate of
computation of the system, with each node reacting in to receipt of
messages published via topics by other nodes. This approach is fairly
common and is appropriate for systems like our ball-chasing robot. There
is no reason to do any work until you have a new camera image, and once
you have one you want to process it as quickly as possible and then
command an appropriate steering direction in response.</p>
<p>(We are making various simplifying assumptions, including that there is
sufficient computational capacity to run all the nodes fast enough to
keep up with the camera's data rate; that we do not have a way to predict
where the ball is going in between camera frames; and that the motors
can be commanded at the same rate the camera produces images.)</p>
<h3 id="services"><a class="header" href="#services">Services</a></h3>
<p>So topics get the job done for the basic ball-chasing robot. But now say
that we want to add the ability to periodically capture an
ultra-high-resolution image. The camera can do it, but it requires
interrupting the usual image stream that we rely on for the application,
so we only want it to happen on demand. This kind of interaction is a
poor fit for the publish-subscribe pattern of a topic. Fortunately, ROS
also offers a request-reply pattern in a second concept: <em>services</em>.</p>
<p>A ROS service is a form of remote procedure call (RPC), a common concept
in distributed systems. Calling a ROS service is similar to calling a
normal function in a library via a code API. But because the call may be
dispatched to another process or even another machine on the network,
there is more to it than just copying pointers around. Specifically, a
ROS service is implemented using a pair of ROS messages: a <em>request</em> and
a <em>reply</em>. The node calling the service populates the request message
and sends it to the node implementing the service, where the request is
processed, resulting in a reply message that is sent back.</p>
<p>We might implement the new high-res snapshot capability like so:</p>
<ul>
<li><strong>Define a new service type.</strong> Because services are less widely used than
topics, there are relatively few &quot;standard&quot; service types predefined.
In our case, the new service's request message might include the desired
resolution of the snapshot. The request message could be a standard
<code>sensor_msgs/Image</code>.</li>
<li><strong>Implement the service.</strong> In the camera driver, we would
advertise the newly defined service so that when a request is
received, the usual image-handling is interrupted temporarily to allow
the device interaction necessary to grab one high-res snapshot, which is
then packed into a reply message and sent back to the node that called
the service.</li>
<li><strong>Call the service.</strong> In the target follower node, we might add a
timer so that every 5 minutes, it calls the new service. The target
follower would receive the high-res snapshot in response to each call,
and could then, say, add it to a photo gallery on disk.</li>
</ul>
<p>In general, if you have a need for infrequent, on-demand interactions
among nodes, ROS services are a good choice.</p>
<h3 id="actions"><a class="header" href="#actions">Actions</a></h3>
<p>Sometimes, when building robot control systems, there is a need for an
interaction that looks like request-reply, but that can require a lot of
time between the request and the reply. Imagine that we want to wrap up
our ball-chasing control system into a black box that can be invoked as
part of a larger system that makes the robot play football. In this
case, the higher level football controller will periodically want to
say, &quot;please chase the red ball until you have it right in front of
you.&quot; Once the ball is in front of the robot, the football controller
wants to stop the ball-chasing controller and invoke the ball-catching
controller.</p>
<p>We <em>could</em> achieve this kind of interaction with a ROS service. We could
define a chase-ball service and implement it in the target follower.
Then the football controller could call that service when it wants the
ball chased. But ball-chasing may take quite some time to complete, and
it may fail to complete. Unfortunately, after calling the chase-ball
service, the football controller is stuck waiting for the reply, similar
to the situation in which you call a long-running function in code. The
football controller does not know how well (or poorly) the chase is
going, and it cannot stop the chase.</p>
<p>For such goal-oriented, time-extended tasks, ROS offers a third concept
that is similar to services but more capable: <em>actions</em>. A ROS action is
defined by three ROS messages: a goal, a result, and feedback. The goal,
sent once by the node calling the action to initiate the interaction,
indicates what the action is trying to achieve; for ball-chasing it
might be the minimum required distance to the ball. The result, sent
once by the node implementing the action after the action is complete,
indicates what happened; for ball-chasing it might be final distance to
the ball after the chase. The feedback, sent periodically by the node
implementing the action until it is complete, updates the caller on how
things are going; for ball-chasing it might be the current distance to
the ball during the chase. In addition, actions are cancelable, so the
football controller can decide to give up and move onto another tactic
if the chase is taking too long or if the feedback messages are showing
that there is little chance of success.</p>
<p>In general, if you want to support on-demand, long-running behaviors, ROS
actions are a good choice.</p>
<h3 id="parameters"><a class="header" href="#parameters">Parameters</a></h3>
<p>Any nontrivial system requires configuration, and ROS is no exception.
When we start our robot's motor driver node, how do we tell it to
connect to the motors via <code>/dev/ttyUSB1</code>? We do not want to hard-code
that information into the node, because on the next robot it might be
<code>/dev/ttyUSB0</code> instead. ROS addresses such configuration needs via a
fourth concept: <em>parameters</em>. A ROS parameter is what you might expect:
a named, typed, place to store a piece of data. For example, the motor
driver node may define a parameter called <code>serial_port</code> with type
string. When it starts up, the node would use the value of that
parameter to know which device to open to get to the motor system.</p>
<p>ROS parameters can be set in a few ways:</p>
<ul>
<li><strong>Defaults.</strong> A ROS node that uses a parameter must embed in its code
some default value for that parameter. In the case that nothing else
in the system sets the parameter value explicitly, the node needs some
value to work with.</li>
<li><strong>Command-line.</strong> There is standard syntax for setting parameter
values on the command-line when launching a node. Values set in this
manner override defaults in the code.</li>
<li><strong>Launch files.</strong> When launching nodes via the <code>launch</code> tool instead
of manually via the command-line, you can set parameter values in the
launch file. Values set in this manner override defaults in the code.</li>
<li><strong>Service calls.</strong> ROS parameters are dynamically reconfigurable via a
standard ROS service interface, allowing them to be changed on the
fly, if the node hosting the parameters allows it. Values set in this
manner override whatever previous values were set.</li>
</ul>
<p>For most nodes, parameter management is relatively simple: define a
handful of parameters, each with a reasonable default; retrieve the
parameters' values at startup, which accounts for changes made via
command-line or launch file, then begin execution and disallow future
changes. This pattern makes sense for the motor driver, which needs to
know which <code>/dev/ttyUSB</code> device file to open at startup, and does not
support changing that setting later. But there are cases that require
more sophisticated handling. For example, the blob finder node may
expose as parameters a variety of thresholds or other settings that
configure how it identifies the red ball in images. These kinds of
settings can be changed on the fly, which the target follower might want
to do, based on how well the chase is going. In this case the blob
finder needs to be sure to use the latest values for its parameters,
knowing that they may have been changed by another node.</p>
<p>In general, when you want to store stable, but possibly changeable,
configuration information in a node, ROS parameters are a good choice.</p>
<h2 id="asynchrony-in-code-callbacks"><a class="header" href="#asynchrony-in-code-callbacks">Asynchrony in Code: Callbacks</a></h2>
<p>Throughout ROS, you will see a common pattern in the code, which is the
use of <em>callback functions</em>, or simply <em>callbacks</em>. For example, when
subscribing to a topic, you supply a callback, which is a function that
will be invoked each time your node receives a message on that topic.
Similarly, when you advertise a service, you supply a callback that is
invoked when the service is called. The same goes for actions (for
handling of goals, results, and feedback) and parameters (for handling
of setting new values).</p>
<p>Programming with callbacks is not familiar to everyone. It differs from the
standard sequential presentation of programming, in which you write a <code>main()</code>
function that does A, then B, then C, and so on. By contrast, in ROS (and in
most systems that focus on data-processing and/or control), we follow an
event-based pattern. In this pattern, we do A whenever X happens, B whenever Y
happens, and so on.</p>
<p>A common structure for a ROS node is the following:</p>
<ul>
<li><strong>Get parameter values.</strong> Retrieve the node's configuration,
considering defaults and what may have been passed in from outside.</li>
<li><strong>Configure.</strong> Do whatever is necessary to configure the node, like
establish connections to hardware devices.</li>
<li><strong>Set up ROS interfaces.</strong> Advertise topics, services, and/or actions,
and subscribe to services. Each of these steps supplies a callback
function that is registered by ROS for later invocation.</li>
<li><strong>Spin.</strong> Now that everything is configured and ready to go, hand
control over to ROS. As messages flow in and out, ROS will invoke the
callbacks you registered.</li>
</ul>
<p>Following this structure, a <code>main()</code> function in a ROS node is often very
short: initialize and configure everything, then call a spin function to let
ROS take over. When you are trying to understand what is happening in a ROS
node, look in the callbacks; that is where the real work is happening.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/ros2_design_patterns.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="the-ros-command-line-interface"><a class="header" href="#the-ros-command-line-interface">The ROS Command Line Interface</a></h1>
<p>The ROS command line interface, or CLI for short, is a set of programs for
starting, inspecting, controlling, and monitoring a ROS robot. The best way to
think of the CLI is a collection of small and simple programs that allow you
perform basic tasks in ROS. Drawing from our car analogy, the CLI can be thought
of as the subsystems of a vehicle: the breaks, the transmission, the window
wipers, all of the smaller parts that are composed together to build the larger
vehicle. What we'll show you in this section is how to turn on the car, put it in
gear, turn on the radio, and perhaps check your oil to perform routine
maintenance. The ROS 2 CLI draws heavily from the Unix/Linux philosophy of small
programs that can be composed together. If you are familiar with the command
line interface found in Unix and Linux, or to a lesser extent in MacOS or
Windows, you'll feel right at home.</p>
<p>The ROS command line tools draw heavily from the design patterns mentioned in the
previous section, and directly interface with the APIs we will address in the next
section. The CLI interface is at its core just a set of simple tools built from
the ROS 2 API; this API is simply an implementation of the high-level patterns
we discussed in the previous section. If your goal is to simply interface with a
particular piece of software written using ROS, the CLI interface is the way you
will go about starting, stopping, and controlling the underlying ROS
software. For more advanced users these tools will allow you to study a ROS
system by exploring the underlying software processes in the system.</p>
<p>There are only two things you need to memorize from this section.
The first command simply tells your computer that
you are using ROS, and what version of ROS you want to use. Let's take a look at
the magic command:</p>
<pre><code class="language-{.sourceCode .bash}">source /opt/ros/eloquent/setup.bash
</code></pre>
<p>If everything is working correctly, this command should simply return. Nothing
happens that you can see, but underneath the hood you've just told this particular shell that you are using
ROS 2 Eloquent Elusor, and where all the ROS programs and files live. You should
plan on doing this every time you want to use ROS. The most common mistake new
users have is not running this command. If you're not sure if you ran the
command in a shell, that's okay. The command is idempotent; running it
twice in a row won't break anything. You can run it a million times in a row and
it won't make any difference.</p>
<p>The other command you need to commit to memory is <code>ros2</code>. Almost everything in
the ROS 2 CLI starts with <code>ros2</code>. Go ahead and try it in the same shell where you just sourced the setup file.
If everything is working correctly you should see the following:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2
usage: ros2 [-h] Call `ros2 &lt;command&gt; -h` for more detailed usage. ...

ros2 is an extensible command-line tool for ROS 2.

optional arguments:
  -h, --help            show this help message and exit

Commands:
  action     Various action related sub-commands
  component  Various component related sub-commands
  daemon     Various daemon related sub-commands
  doctor     Check ROS setup and other potential issues
  interface  Show information about ROS interfaces
  launch     Run a launch file
  lifecycle  Various lifecycle related sub-commands
  msg        Various msg related sub-commands
  multicast  Various multicast related sub-commands
  node       Various node related sub-commands
  param      Various param related sub-commands
  pkg        Various package related sub-commands
  run        Run a package specific executable
  security   Various security related sub-commands
  service    Various service related sub-commands
  srv        Various srv related sub-commands
  topic      Various topic related sub-commands
  wtf        Use `wtf` as alias to `doctor`

  Call `ros2 &lt;command&gt; -h` for more detailed usage.

</code></pre>
<p>From this one command you can figure out what every single ROS 2 CLI program does and
how to use it. The ROS 2 CLI has a syntax just like most languages. All ROS CLI commands start
with <code>ros2</code>, followed by a command. After the command any number of other things
can come; you can append <code>--help</code> or <code>-h</code> to see the documentation and find out what arguments any of the commands are expecting.
The rest of this section just walks through each of the commands one by one.</p>
<p>Writing commands using the command line is tricky and error
prone. There are a couple of tools you can use to make the process much
smoother. The first is the <code>TAB</code> key, which attempts to auto complete whatever you type.
It can't read your mind, but for common command combinations you usually only need to type the
first one or two letters. Another tool is the up arrow key. When you use the
command line sometimes you mistype a command, or need to rerun a
command. Pressing the up key will cycle through the previous commands which you
can modify and rerun as needed.</p>
<h2 id="running-your-first-ros-program"><a class="header" href="#running-your-first-ros-program">Running Your First ROS Program</a></h2>
<p>Let's get started with our first ROS CLI command. The first command we'll visit
is <code>run</code>. Let's start by looking at the documentation for the <code>run</code> command:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 run
usage: ros2 run [-h] [--prefix PREFIX] package_name executable_name ...
ros2 run: error: the following arguments are required: package_name, executable_name, argv
</code></pre>
<p>To get more complete information about a ROS 2 command, simply ask the command for help by
adding <code>--help</code> to the command. Let's try that again:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 run --help
usage: ros2 run [-h] [--prefix PREFIX] package_name executable_name ...

Run a package specific executable

positional arguments:
  package_name     Name of the ROS package
  executable_name  Name of the executable
  argv             Pass arbitrary arguments to the executable

optional arguments:
  -h, --help       show this help message and exit
  --prefix PREFIX  Prefix command, which should go before the executable.
                   Command must be wrapped in quotes if it contains spaces
                   (e.g. --prefix 'gdb -ex run --args').
</code></pre>
<p>We can see that <code>ros2 run</code> is the
command to, &quot;Run a package specific executable.&quot; In ROS 2 collections of ROS
software are gathered into logical units called <code>packages</code>. Each package
contains all of the source code for the package as a variety of other data that
tells ROS how to build and compile the package and the names of all the
programs, also called <code>executables</code>, that can be found in the package. The line
below the description then gives the <em>positional arguments</em> for the
package. Positional arguments are the words and values that come after <code>ros2</code>
and the command you run. In this case the syntax for the command sentence we
want to write is as follows:</p>
<p><code>ros2 run &lt;package name&gt; &lt;program/executable name&gt; &lt;args&gt;</code></p>
<p>There is one piece of missing information here. What is this <code>argv</code> that the
command is asking for? The <code>argv</code> element is programmer short hand for variable
arguments, and it simply means, &quot;some number of additional arguments that are
determined by the executable&quot;. It is worth noting that a program can have zero
arguments and you can just leave it blank. This is actually how a lot of
programs work. For example, say we had a package
called <em>math</em>, and an executable called <em>add</em> that takes in two numbers and
returns the result. In this case <em>argv</em> would be the two numbers to add. The
final command would look like:</p>
<p><code>ros2 run math add 1 2</code></p>
<p>Finally, below the positional arguments we have <em>optional arguments</em>.
You don't need to included them, unless you need to.</p>
<p>Now that we've looked into our help file let's run our first ROS program. For
these tutorials we're going to use a package called <code>turtlesim</code>, and the program
we want to run is <code>turtlesim_node</code>. Let's run this program (remember your tab
complete!). Your command should look like the following:</p>
<p><code>ros2 run turtlesim turtlesim_node</code></p>
<p>If everything goes smoothly you should see the following:</p>
<pre><code class="language-{.sourceCode .bash}">[INFO] [turtlesim]: Starting turtlesim with node name /turtlesim
[INFO] [turtlesim]: Spawning turtle [turtle1] at x=[5.544445], y=[5.544445], theta=[0.000000]
</code></pre>
<p>A window should also pop up with a cute little turtle that looks like the one
below:</p>
<p><img src="./images/turtlesim_start.png" alt="Turtlesim upon opening" /></p>
<p>The real power in ROS isn't that it can run a program, it is that it can run
lots of programs all at the same time, all talking together to control a robot, or
multiple robots, all working together. To illustrate this let's run a second ROS
program that makes our little turtle move around.</p>
<p>To do this we'll first open a new terminal (using <code>CTRL-SHIFT-T</code>). Next we'll
tell that terminal that we want to use ROS Eloquent by using the <code>source</code> command.
Finally, we'll run another program in the
<code>turtlesim</code> package to draw a square. See if you can find the program
yourself (hint: use <code>TAB</code>). If everything works you should have typed the following, and the
following output should be visible:</p>
<pre><code class="language-{.sourceCode .bash}">$ source /opt/ros/eloquent/setup.bash
$ ros2 run turtlesim draw_square
[INFO] [draw_square]: New goal [7.544445 5.544445, 0.000000]
[INFO] [draw_square]: Reached goal
[INFO] [draw_square]: New goal [7.448444 5.544445, 1.570796]
[INFO] [draw_square]: Reached goal
</code></pre>
<p>Your screen should look roughly like this:</p>
<p><img src="./images/turtlesim_square.png" alt="image" /></p>
<p>It is worth noting that you can stop any ROS program by pressing the <code>Ctrl</code> and
<code>C</code> keys at the same time in the terminal; we call this <code>CTRL-C</code> (note that
<code>CTRL-SHIFT-C</code> and <code>CTRL-SHIFT-V</code> are responsible for copy and paste in a Linux terminal).
Feel free to try it out. Start and stop the programs, and then
restart them before moving on.</p>
<h2 id="ros-topics"><a class="header" href="#ros-topics">ROS Topics</a></h2>
<p>We now have two ROS 2 programs running from the <code>turtlesim</code> package.
There is <code>turtle_node</code> that opens our turtle simulation, and <code>draw_square</code>
that makes the turtle in <code>turtle_node</code> move around. How are these two
programs communicating?</p>
<p>ROS programs, also called <em>nodes</em>, communicate over
<em>topics</em> on the ROS <em>message bus</em>. ROS <em>topics</em> use namespaces to distinguish themselves.
For example, in a vehicle running ROS, the positions of each wheel may be
organized as follows:</p>
<pre><code>/wheels/front/driver/velocity
/wheels/front/passenger/velocity
/wheels/rear/driver/velocity
/wheels/rear/passenger/velocity
</code></pre>
<p>The key thing to realize about topics is that the data they contain is dynamic, meaning it changes
constantly. In our vehicle example the velocity of each wheel might be measured
one thousand times a second or more. Since the data in a ROS topic is constantly
changing, an important distinction for a topic is whether the topic is &quot;creating&quot;
or as we like to say in ROS <code>publishing</code>, or if it is reading the data, what we call
<code>subscribing</code> to the topic. Many ROS nodes subscribe to one set of topics,
process that input data, and then publish to another set of topics.</p>
<p>Let's return to our turtlesim example and see if we can use the ROS CLI to
understand the topics, publishers, and subscribers.
To see sub commands and syntax for the <code>topic</code> command, we'll run: <code>ros2 topic --help</code>.</p>
<p>This command outputs the following:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 topic --help
usage: ros2 topic [-h] [--include-hidden-topics]
                  Call `ros2 topic &lt;command&gt; -h` for more detailed usage. ...

Various topic related sub-commands

optional arguments:
  -h, --help            show this help message and exit
  --include-hidden-topics
                        Consider hidden topics as well

Commands:
  bw     Display bandwidth used by topic
  delay  Display delay of topic from timestamp in header
  echo   Output messages from a topic
  find   Output a list of available topics of a given type
  hz     Print the average publishing rate to screen
  info   Print information about a topic
  list   Output a list of available topics
  pub    Publish a message to a topic
  type   Print a topic's type

  Call `ros2 topic &lt;command&gt; -h` for more detailed usage.
</code></pre>
<p>There are quite a
few sub commands; we won't discuss all of them, but let's look closely at a few.
Sub commands have their
own help command. Why don't we examine the <code>list</code> command. Repeating our command
pattern let's try running <code>ros2 topic list --help</code>.</p>
<pre><code class="language-{.sourceCode .bash}">usage: ros2 topic list [-h] [--spin-time SPIN_TIME] [-t] [-c]
                       [--include-hidden-topics]

Output a list of available topics

optional arguments:
  -h, --help            show this help message and exit
  --spin-time SPIN_TIME
                        Spin time in seconds to wait for discovery (only
                        applies when not using an already running daemon)
  -t, --show-types      Additionally show the topic type
  -c, --count-topics    Only display the number of topics discovered
  --include-hidden-topics
                        Consider hidden topics as well

</code></pre>
<p>As indicated at the top of this command help file, <code>ros2 topic list</code> will
&quot;Output a list of available topics.&quot; There appears to be a variety of
<em>optional</em> arguments that we don't need to include if we don't want to. However,
the <code>-t, --show-types</code> line looks interesting. It is worth noting that command
arguments, sometimes called flags, can have two types. A short form indicated
with a single dash (&quot;-&quot;), and a long form indicated by a double dash
(&quot;--&quot;). Don't worry, despite looking different both versions of the argument do
the same thing. Let's try running this command, sub command pair with the
<code>-show-types</code> argument.</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 topic list --show-types
/parameter_events [rcl_interfaces/msg/ParameterEvent]
/rosout [rcl_interfaces/msg/Log]
/turtle1/cmd_vel [geometry_msgs/msg/Twist]
/turtle1/color_sensor [turtlesim/msg/Color]
/turtle1/pose [turtlesim/msg/Pose]
</code></pre>
<p>On the left hand side we see all of the ROS topics
running on the system, each starting with <code>/</code>. We can see that most of them are gathered in the
<code>/turtle1/</code> group. This group defines all the inputs and outputs of the little
turtle on our screen. The words in brackets (<code>[]</code>) to the right of the topic
names define the messages used on the topic. Our car wheel example was
simple, we were only publishing velocity, but ROS allows you to publish more
complex data structures that are defined by a <em>message type</em>. When we added the
<code>--show-types</code> flag we told the command to include this information. We'll dig
into messages in detail a bit later.</p>
<p>One of the more commonly used topic sub commands is
<code>info</code>. Unsurprisingly, <code>info</code> provides info about a topic.  Let's peek at its
help file using <code>ros2 topic info --help</code></p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 topic info --help
usage: ros2 topic info [-h] topic_name

Print information about a topic

positional arguments:
  topic_name  Name of the ROS topic to get info (e.g. '/chatter')

optional arguments:
  -h, --help  show this help message and exit
</code></pre>
<p>That seems pretty straight forward. Let's give it a go by running it on
<code>/turtle1/pose</code></p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 topic info /turtle1/pose
Type: turtlesim/msg/Pose
Publisher count: 1
Subscriber count: 1
</code></pre>
<p>What does this command tell us? First it tells us the <em>message type</em> for the
<code>/turtle1/pose</code> topic, which is <code>/turtlesim/msg/Pose</code>. From this we can determine that the
message type comes from the <em>turtlesim</em> package, and its type is <code>Pose</code>. ROS
messages have a predefined message type that can be shared by different
programming languages and between different nodes. We can also see that this
topic has a single publisher, that is to say a single node generating data on the
topic. The topic also has a single subscriber, also called a listener, who is
processing the incoming pose data.</p>
<p>If we only wanted to know the message type of a topic
there is a sub command just for that called, <code>type</code>. Let's take a look at its
help file and its result:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 topic type --help
usage: ros2 topic type [-h] topic_name

Print a topic's type

positional arguments:
  topic_name  Name of the ROS topic to get type (e.g. '/chatter')

optional arguments:
  -h, --help  show this help message and exit
kscottz@kscottz-ratnest:~/Code/ros2multirobotbook$ ros2 topic type /turtle1/pose
turtlesim/msg/Pose
</code></pre>
<p>While it is not part of the <code>topic</code> command it is worthwhile for us to jump ahead
briefly and look at one particular command, sub command pair, namely the <code>interface</code>
command and the <code>show</code> sub command. This sub command will print all the
information related to a message type so you can better understand the data
being moved over a topic. In the previous example we saw that the <code>topic type</code>
sub command told us the <code>/turtle1/pose</code> topic has a type <code>turtlesim/msg/Pose</code>.
But what does <code>turtlesim/msg/Pose</code> data look like? We can look at the data
structure transferred by this topic by running the <code>ros2 interface show</code>
sub command and giving the message type name as an input. Let's look at the help
for this sub command and its output:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 interface show --help
usage: ros2 interface show [-h] type

Output the interface definition

positional arguments:
  type        Show an interface definition (e.g. &quot;std_msgs/msg/String&quot;)

optional arguments:
  -h, --help  show this help message and exit

$ ros2 interface show turtlesim/msg/Pose
float32 x
float32 y
float32 theta

float32 linear_velocity
float32 angular_velocity
</code></pre>
<p>We can see the values <code>x</code> and <code>y</code> which are the position coordinates of our turtle,
and that they are of type <code>float32</code>.
<code>theta</code> is the direction the head is pointing. The
next two values, <code>linear_velocity</code> and <code>angular_velocity</code>, are how
fast the turtle is moving and how quickly it is turning, respectively. To summarize, this
message tells us where a turtle is on the screen, where it is headed, and how
fast it is moving or rotating.</p>
<p>Now that we know what ROS topics are on our simple turtlesim, and their message
types, we can dig in and find out more about how everything works. If we look
back at our topic sub commands, we can see a sub command called <code>echo</code>. Echo is
computer jargon that means &quot;repeat&quot; something. If you echo a topic it means you
want the CLI to repeat what's on a topic. Let's look at the <code>echo</code> sub command's
help text:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 topic echo --help
usage: ros2 topic echo [-h]
                       [--qos-profile {system_default,sensor_data,services_default,parameters,parameter_events,action_status_default}]
                       [--qos-reliability {system_default,reliable,best_effort}]
                       [--qos-durability {system_default,transient_local,volatile}]
                       [--csv] [--full-length]
                       [--truncate-length TRUNCATE_LENGTH] [--no-arr]
                       [--no-str]
                       topic_name [message_type]

Output messages from a topic

positional arguments:
  topic_name            Name of the ROS topic to listen to (e.g. '/chatter')
  message_type          Type of the ROS message (e.g. 'std_msgs/String')

optional arguments:
  -h, --help            show this help message and exit
  --qos-profile {system_default,sensor_data,services_default,parameters,parameter_events,action_status_default}
                        Quality of service preset profile to subscribe with
                        (default: sensor_data)
  --qos-reliability {system_default,reliable,best_effort}
                        Quality of service reliability setting to subscribe
                        with (overrides reliability value of --qos-profile
                        option, default: best_effort)
  --qos-durability {system_default,transient_local,volatile}
                        Quality of service durability setting to subscribe
                        with (overrides durability value of --qos-profile
                        option, default: volatile)
  --csv                 Output all recursive fields separated by commas (e.g.
                        for plotting)
  --full-length, -f     Output all elements for arrays, bytes, and string with
                        a length &gt; '--truncate-length', by default they are
                        truncated after '--truncate-length' elements with
                        '...''
  --truncate-length TRUNCATE_LENGTH, -l TRUNCATE_LENGTH
                        The length to truncate arrays, bytes, and string to
                        (default: 128)
  --no-arr              Don't print array fields of messages
  --no-str              Don't print string fields of messages
</code></pre>
<p>Wow, that's a lot of features. The top of the help files says that this CLI
program &quot;output[s] messages from a topic.&quot; As we scan the positional arguments we see one
required argument, a topic name, and an optional message type. We know the
message type is optional because it has square brackets (<code>[]</code>) around it. Let's
give the simple case a whirl before we address some of the optional
elements. Two things to keep in mind: first is that topics are long and easy to mess
up, so use the <code>TAB</code> key. Second is that this will print a lot of data, fast. You can
use <code>CTRL-C</code> to stop the command and stop all the output. Let's take a look at the
<code>/turtle1/pose</code> topic.</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 topic echo /turtle1/pose
x: 5.4078755378723145
y: 7.081490516662598
theta: -1.0670461654663086
linear_velocity: 1.0
angular_velocity: 0.0
---
x: 5.4155988693237305
y: 7.067478179931641
theta: -1.0670461654663086
linear_velocity: 1.0
angular_velocity: 0.0
---
x: 5.423322677612305
y: 7.053465843200684
theta: -1.0670461654663086
linear_velocity: 1.0
angular_velocity: 0.0
---
&lt;&lt;GOING ON FOREVER&gt;&gt;
</code></pre>
<p>Let's examine what is going on. Between the
dashes (<code>---</code>) is a single ROS message on our topic. If you examine the numbers
closely you can see that they are changing, and doing so in relation to the
movement of the turtle. Going back to our car example you can see how this would
be useful for understanding the instantaneous velocity of each of our wheels.</p>
<p>Now that we have the basics down let's dig into a few of the optional
arguments. We see a variety of commands that start with <code>--qos</code>. &quot;QOS&quot; here
means &quot;quality of service&quot; and it is a really cool feature that is only in
ROS 2. Without getting too technical, QOS is a way of asking for a certain level
of networking robustness. A ROS system can operate over a network, and just like
streaming video or video games, packets can get dropped or not get to their
destination. The OS settings help you control which packets are the most
important and should get the highest priority.</p>
<p>Most of the other commands deal with changing the output format of this CLI
program, but there is one in particular that is super handy, and it is also new
in ROS 2. The <code>--csv</code> flag stands for &quot;comma separated values&quot; and it a very
simple way of defining a spreadsheet. What this argument does is make the topic
echo command output data in the comma separate value format. Many command lines
allow you send data from the screen to a file, saving the data for later
review or analysis. To do this file saving in Linux we use the <code>&gt;</code> character
followed by a file name. Below are two examples of using the <code>--csv</code> argument:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 topic echo /turtle1/pose --csv
7.097168922424316,8.498645782470703,2.442624092102051,0.0,0.4000000059604645
7.097168922424316,8.498645782470703,2.449024200439453,0.0,0.4000000059604645
...
&lt;&lt;CTRL-C&gt;&gt;
$ ros2 topic echo /turtle1/pose --csv &gt; mydata.csv
&lt;&lt;nothing happens&gt;&gt;
&lt;&lt;CTRL-C&gt;&gt;
</code></pre>
<p>The second command above creates a file called <code>mydata.csv</code>. You can look at it
using a CLI utility called <code>less</code> (press q to quit), or open it with your
favorite spreadsheet tool.</p>
<p>Now that we've looked at <code>ros2 topic echo</code> let's take a look at a few other
topic sub commands. One thing you may have noticed is that topics can output a lot
of data! More complex robots, like a self driving car, can saturate a high
speed internet connection with how much data it produces. There are two topic
sub commands that can be used to diagnose performance issues. The first
sub command is <code>topic hz</code> which is the abbreviation of Hertz, the unit of
frequency. The <code>Hz</code> sub command will
tell you how often a particular topic produces a message. Similarly there is
the <code>topic bw</code> sub command, where <code>bw</code> stands for bandwidth, which is a
engineering term related to the <em>volume</em> of data being produced. A high
bandwidth connection can move more data, like high definition video, than a low
bandwidth data, which might move a radio show. Let's take a look at the help
for these two commands:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 topic hz --help
usage: ros2 topic hz [-h] [--window WINDOW] [--filter EXPR] [--wall-time]
                     topic_name

Print the average publishing rate to screen

positional arguments:
  topic_name            Name of the ROS topic to listen to (e.g. '/chatter')

optional arguments:
  -h, --help            show this help message and exit
  --window WINDOW, -w WINDOW
                        window size, in # of messages, for calculating rate
                        (default: 10000)
  --filter EXPR         only measure messages matching the specified Python
                        expression
  --wall-time           calculates rate using wall time which can be helpful
                        when clock is not published during simulation
$ ros2 topic bw --help
usage: ros2 topic bw [-h] [--window WINDOW] topic

Display bandwidth used by topic

positional arguments:
  topic                 Topic name to monitor for bandwidth utilization

optional arguments:
  -h, --help            show this help message and exit
  --window WINDOW, -w WINDOW
                        window size, in # of messages, for calculating rate
                        (default: 100)
</code></pre>
<p>Both <code>bw</code> and <code>hz</code> follow the same pattern, they simply take in a topic name
followed by a few optional arguments. The only argument worth noting is the
<code>window</code> argument. Both of these commands calculate statistics for a series of
messages; how many messages to use in calculating those statistics is the window
size. The default value for <code>window</code> is 100, so when you call <code>ros2 topic bw</code> it
will first collect 100 messages then use that data to calculate the average
message size. Let's give it a shot (use <code>TAB</code> to complete and <code>CTRL-C</code> to exit).</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 topic hz /turtle1/pose
average rate: 60.021
	min: 0.001s max: 0.073s std dev: 0.00731s window: 65
average rate: 61.235
	min: 0.001s max: 0.073s std dev: 0.00523s window: 128
$ ros2 topic bw /turtle1/pose
Subscribed to [/turtle1/pose]
average: 1.44KB/s
	mean: 0.02KB/s min: 0.02KB/s max: 0.02KB/s window: 46
average: 1.52KB/s
	mean: 0.02KB/s min: 0.02KB/s max: 0.02KB/s window: 100
</code></pre>
<p>As we can see above, the <code>hz</code> command says that the topic is publishing messages
at 60.021, where the unit is hz, or 60.021 times a second. Notice that the
command gives the publishing frequency as an average, followed by the minimum,
maximum, and standard deviation, in seconds. The bandwidth sub command is very
similar; and we can see that the topic is producing 1.44 kilobytes of data per
second. This command has similar outputs around the minimum, maximum, and mean.</p>
<p>One tool that is handy when exploring topics is understanding their type. While
we have already looked at the <code>interface</code> command to see what integral types make up
a topic, the <code>topic</code> command has both a tool to query the type of a topic, and a
means to search all topics for a specific type. If all you want to know is a
topic's type you can use the <code>type</code> command which will return a type that can
then be further explored with the <code>interface</code> command. If instead you would like
to know what topics use a particular message type you can use the <code>topic find</code>
command, sub command pair. Both the <code>topic type</code> and <code>topic interface</code> command,
sub command pairs have a very limited set of optional arguments, so we simply
provide them with our desired topic or message type. Let's take a look at these two commands together:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 topic type --help
usage: ros2 topic type [-h] topic_name
Print a topic's type

positional arguments:
  topic_name  Name of the ROS topic to get type (e.g. '/chatter')

optional arguments:
  -h, --help  show this help message and exit
$ ros2 topic type /turtle1/pose
turtlesim/msg/Pose
$ ros2 topic find --help
usage: ros2 topic find [-h] [-c] [--include-hidden-topics] topic_type

Output a list of available topics of a given type

positional arguments:
  topic_type            Name of the ROS topic type to filter for (e.g.
                        'std_msg/msg/String')

optional arguments:
  -h, --help            show this help message and exit
  -c, --count-topics    Only display the number of topics discovered
  --include-hidden-topics
                        Consider hidden topics as wel
$ ros2 topic find  turtlesim/msg/Pose
/turtle1/pose
</code></pre>
<p>The last sub command for the topic command is <code>pub</code>, which simply means publish.
It allows you to publish a command to any ROS topic from the command
line. While you shouldn't need to use this command regularly it can be
particularly handy for testing and debugging when you are building a robot
system. The <code>pub</code> command has a number of optional arguments that allow you to
send one or more messages, and with different quality of service (QoS)
presets. The format of the command is <code>ros2 topic pub TOPIC_NAME MESSAGE_TYPE VALUES</code>, which means for it to work successfully you must include a
target topic, the topic's message type, and finally the message's values. The
values for the message are specified in the YAML format and we can use the
<code>interface show</code> command to understand the format. To illustrate the utility of this
command we'll issue a message to rotate and stop  our turtle by publishing
to the <code>/turtle1/cmd_vel/</code> topic. Let's first take a look at the <code>topic pub</code>
documentation before we construct our command:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 topic pub --help
usage: ros2 topic pub [-h] [-r N] [-p N] [-1] [-n NODE_NAME]
                      [--qos-profile {system_default,sensor_data,services_default,parameters,parameter_events,action_status_default}]
                      [--qos-reliability {system_default,reliable,best_effort}]
                      [--qos-durability {system_default,transient_local,volatile}]
                      topic_name message_type [values]

Publish a message to a topic

positional arguments:
  topic_name            Name of the ROS topic to publish to (e.g. '/chatter')
  message_type          Type of the ROS message (e.g. 'std_msgs/String')
  values                Values to fill the message with in YAML format (e.g.
                        &quot;data: Hello World&quot;), otherwise the message will be
                        published with default values

optional arguments:
  -h, --help            show this help message and exit
  -r N, --rate N        Publishing rate in Hz (default: 1)
  -p N, --print N       Only print every N-th published message (default: 1)
  -1, --once            Publish one message and exit
  -n NODE_NAME, --node-name NODE_NAME
                        Name of the created publishing node
  --qos-profile {system_default,sensor_data,services_default,parameters,parameter_events,action_status_default}
                        Quality of service preset profile to publish with
                        (default: system_default)
  --qos-reliability {system_default,reliable,best_effort}
                        Quality of service reliability setting to publish with
                        (overrides reliability value of --qos-profile option,
                        default: system_default)
  --qos-durability {system_default,transient_local,volatile}
                        Quality of service durability setting to publish with
                        (overrides durability value of --qos-profile option,
                        default: system_default)

</code></pre>
<p>Since we want to manually move our turtle we will use the <code>--once</code>
flag to issue our command once. It is worth noting that the message type used to
command the velocity of the turtle is complex in that it is made up of other
message types so we'll have to query the base message type. Here's a rough summary of what we will do:</p>
<ul>
<li>Print the <code>cmd_vel</code> topic type using <code>ros2 topic type</code>, which is <code>geometry_msgs/msg/Twist</code></li>
<li>Determine the structure of the <code>Twist</code> message type using <code>interface show</code>.</li>
<li>Determine the structure of the <code>Vector3</code>, which is part of the <code>Twist</code> message
type using <code>inteface show</code> command a second time.</li>
<li>Create the YAML syntax for our command. Note the YAML syntax below as it is
rather tricky! The YAML is wrapped in single quotes and a top level set of
curly braces, while subsequent levels follow the
pattern of <code>name:value</code>, and <code>name:{name1:val1,name2:val2}</code> for nested types
like the <code>Twist</code> command.</li>
<li>Issue the command using <code>ros2 pub</code>.</li>
</ul>
<pre><code class="language-{.sourceCode .bash}">$ ros2 topic type /turtle1/cmd_vel
geometry_msgs/msg/Twist
$ ros2 interface show geometry_msgs/msg/Twist
# This expresses velocity in free space broken into its linear and angular parts.

Vector3  linear
Vector3  angular
$ ros2 interface show geometry_msgs/msg/Vector3
# This represents a vector in free space.

float64 x
float64 y
float64 z

$ ros2 topic pub --once /turtle1/cmd_vel geometry_msgs/msg/Twist '{linear: {x: 4.0,y: 4.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}'

</code></pre>
<p>If you did everything correctly you should have moved around the turtle on the
screen. Try changing the command to draw a small picture.</p>
<h2 id="ros-2-services-and-actions"><a class="header" href="#ros-2-services-and-actions">ROS 2 Services and Actions</a></h2>
<p>As discussed previously, services are the name given to short,
synchronous robot behaviors that can be done quickly, like turning on lights
and switching components on or off. Actions are longer term,
asynchronous, tasks that may have intermediate steps. A classic example of an
action is navigation: a robot is provided a goal position and asked to navigate
to that goal. Try as the robot might, since it cannot move infinitely fast, it
takes time to move to a goal and sometimes its path may become blocked.</p>
<p>These two primitives are the backbone of most robotic systems using ROS, and learning
how to use them via the command line will allow you quickly and easily command
a robot to complete a task for you. To aid in clarity of this section we'll
also touch on the <code>ros2 node</code> command to determine what node, or software
process, is conducting a particular action or service.</p>
<p>Let's get nodes out of the way quickly. ROS nodes are
small programs, running in their own process. A ROS system can have ten,
hundreds, or even thousands of nodes running concurrently. Moreover, a ROS
system can have multiple copies of the same node running concurrently on the
same system. In the case of our turtle simulation we can actually create
multiple turtles, each with their own node, all running the exact same
program. ROS Nodes, like ROS topics, have namespaces so that you can address
specific nodes in the case where multiple copies of the same node (program) are
running. Let's dig in a bit by restarting our turtle simulation in a terminal
using <code>ros2 run turtlesim turtlesim_node</code>. Now in a new terminal let's first
examine what <code>ros2 node</code> has to offer by asking for help.</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 node --help
usage: ros2 node [-h]
                 Call `ros2 node &lt;command&gt; -h` for more detailed usage. ...

Various node related sub-commands

optional arguments:
  -h, --help            show this help message and exit

Commands:
  info  Output information about a node
  list  Output a list of available nodes

  Call `ros2 node &lt;command&gt; -h` for more detailed usage.
</code></pre>
<p>Much like topics, we see two sub commands, <code>info</code> and <code>list</code>. <code>node list</code> works much the
same as <code>topic list</code> and simply prints a list of all running nodes. Let's see what
is running on our system:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 node list
/turtlesim
</code></pre>
<p>We have a single node running called &quot;turtlesim&quot;. <code>node info</code> works in a way
very similar to <code>topic info</code> except that it lists information about the nodes we
give it. Let's call it with our single ROS Node <code>/turtlesim</code> as its
argument:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 node info /turtlesim
/turtlesim
  Subscribers:
    /parameter_events: rcl_interfaces/msg/ParameterEvent
    /turtle1/cmd_vel: geometry_msgs/msg/Twist
  Publishers:
    /parameter_events: rcl_interfaces/msg/ParameterEvent
    /rosout: rcl_interfaces/msg/Log
    /turtle1/color_sensor: turtlesim/msg/Color
    /turtle1/pose: turtlesim/msg/Pose
  Service Servers:
    /clear: std_srvs/srv/Empty
    /kill: turtlesim/srv/Kill
    /reset: std_srvs/srv/Empty
    /spawn: turtlesim/srv/Spawn
    /turtle1/set_pen: turtlesim/srv/SetPen
    /turtle1/teleport_absolute: turtlesim/srv/TeleportAbsolute
    /turtle1/teleport_relative: turtlesim/srv/TeleportRelative
    /turtlesim/describe_parameters: rcl_interfaces/srv/DescribeParameters
    /turtlesim/get_parameter_types: rcl_interfaces/srv/GetParameterTypes
    /turtlesim/get_parameters: rcl_interfaces/srv/GetParameters
    /turtlesim/list_parameters: rcl_interfaces/srv/ListParameters
    /turtlesim/set_parameters: rcl_interfaces/srv/SetParameters
    /turtlesim/set_parameters_atomically: rcl_interfaces/srv/SetParametersAtomically
  Service Clients:

  Action Servers:
    /turtle1/rotate_absolute: turtlesim/action/RotateAbsolute
  Action Clients:
</code></pre>
<p>Wow, that's a lot of information, some of which looks familiar. We can see all
the topics that the node subscribes to, as well as all the nodes it publishes
to. We can also see a number of &quot;action servers&quot; and &quot;service servers&quot;. It is
worth noting the client and server relationship here. Since ROS may have
multiple nodes running some nodes may offer services (these are servers), and
other ROS nodes may call those servers (these are the clients). The clients can
be other ROS nodes, or for these examples, a human using the CLI.</p>
<p>The command line interface for services and actions are very similar, in fact
they both have only four sub commands. Let's run the <code>action</code> and <code>service</code>
commands and compare them:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 action --help
usage: ros2 action [-h]
                   Call `ros2 action &lt;command&gt; -h` for more detailed usage.
                   ...

Various action related sub-commands

optional arguments:
-h, --help            show this help message and exit

Commands:
  info       Print information about an action
  list       Output a list of action names
  send_goal  Send an action goal
  show       Output the action definition

  Call `ros2 action &lt;command&gt; -h` for more detailed usage.
</code></pre>
<pre><code class="language-{.sourceCode .bash}">$ ros2 service --help
usage: ros2 service [-h] [--include-hidden-services]
                    Call `ros2 service &lt;command&gt; -h` for more detailed usage.
                    ...

Various service related sub-commands

optional arguments:
  -h, --help            show this help message and exit
  --include-hidden-services
                        Consider hidden services as well

Commands:
  call  Call a service
  find  Output a list of available services of a given type
  list  Output a list of available services
  type  Output a service's type

  Call `ros2 service &lt;command&gt; -h` for more detailed usage.
</code></pre>
<p>We can see that both commands have a <code>list</code> command that gives a list of
available services or actions. If we had multiple nodes running and wanted to
see every service offered, calling <code>ros2 node info</code> on each node would be very
inefficient, particularly if we had tens, or even hundreds of nodes running.
In this case it would be much more efficient to use the list commands for the
action and service commands. We can run these commands below and see that we get
roughly the same list of actions and services listed in our single nodes:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 service list
/clear
/kill
/reset
/spawn
/turtle1/set_pen
/turtle1/teleport_absolute
/turtle1/teleport_relative
/turtlesim/describe_parameters
/turtlesim/get_parameter_types
/turtlesim/get_parameters
/turtlesim/list_parameters
/turtlesim/set_parameters
/turtlesim/set_parameters_atomically
kscottz@kscottz-ratnest:~$ ros2 action list
/turtle1/rotate_absolute
</code></pre>
<p>Let's begin digging into services. There seem to be quite a few services
listed. Let's take a look at the <code>/spawn</code> service, which will create more
turtles. ROS services and actions use messages similar to those used in topics
to communicate. In fact, actions and services are built on top of messages.
We can use the <code>service type</code> sub command to determine the message type
used by a particular service. We can find specifics of the message by using the
<code>interface show</code> command. Let's see this in practice with the <code>spawn</code> service:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 service type /spawn
turtlesim/srv/Spawn
$ ros2 interface show turtlesim/srv/Spawn
float32 x
float32 y
float32 theta
string name # Optional.  A unique name will be created and returned if this is empty
---
string name
</code></pre>
<p>We can see from the output above that the spawn message takes three <code>float32</code>
values for its position and orientation as well a <code>string</code> for its name. The
<code>---</code> indicate the return value of the services. Unlike topics, services have
a return value, which enables them to do things like perform computations and
calculations.</p>
<p>Let's examine the help for calling a service by running <code>ros2 service call --help</code>:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 service call --help
usage: ros2 service call [-h] [-r N] service_name service_type [values]

Call a service

positional arguments:
  service_name    Name of the ROS service to call to (e.g. '/add_two_ints')
  service_type    Type of the ROS service (e.g. 'std_srvs/srv/Empty')
  values          Values to fill the service request with in YAML format (e.g.
                  &quot;{a: 1, b: 2}&quot;), otherwise the service request will be
                  published with default values

optional arguments:
  -h, --help      show this help message and exit
  -r N, --rate N  Repeat the call at a specific rate in Hz
</code></pre>
<p>The syntax here is very similar to publishing to a topic, but instead of using a
a topic name we use a service name. The service type is just like the topic type
that we used in the past, but instead of using a message type we need a service
type. Finally we give it a value in YAML format. A YAML string must be encased
in single quotes. Let's try calling a service by creating a turtle
named <code>Larry</code> at a position where all values are zero (use <code>TAB</code> complete).</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 service call /spawn turtlesim/srv/Spawn &quot;{x: 0, y: 0, theta: 0.0, name: 'Larry'}&quot;
requester: making request: turtlesim.srv.Spawn_Request(x=0.0, y=0.0, theta=0.0, name='Larry')

response:
turtlesim.srv.Spawn_Response(name='Larry')
</code></pre>
<p>If everything is working correctly you should now have a turtle named &quot;Larry&quot; in
the lower left hand corner of the screen:</p>
<p><img src="./images/larry.png" alt="Spawning a second turtle" /></p>
<p>Try exploring the other services offered, or
creating more turtles at different locations and moving them around.</p>
<p>Let's move on to actions. As mentioned
previously, actions differ from services in a few ways and offer a number of
advantages. Actions have the following advantages:</p>
<ul>
<li>Actions have a <code>goal</code>. That is to say you send them a goal, and they attempt
to complete it.</li>
<li>Actions can reject goal requests. This prevents them from becoming too busy.</li>
<li>Actions are asynchronous and can perform tasks &quot;while you wait.&quot;</li>
<li>Actions will provide you with &quot;updates&quot;  with information about
their progress while you wait.</li>
<li>Actions are preemptable, meaning you can cancel them if
you change your mind.</li>
</ul>
<p>Just like with services, we'll first figure out how to call the sole action in
our ROS system by using the <code>action list</code>, <code>action show</code>, and <code>action info</code>
commands. Recall, that when we called <code>ros2 action list</code> we got a single
service. Now that we have Larry things have changed. Let's take a look:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 action list
/Larry/rotate_absolute
/turtle1/rotate_absolute
</code></pre>
<p>Now there are two actions available, one for Larry and one for <code>turtle1</code>.
Let's rotate turtle1 to face Larry. First we'll call <code>action info</code>
using <code>/turtle1/rotate_absolute</code> as the input and see what we get:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 action info /turtle1/rotate_absolute
Action: /turtle1/rotate_absolute
Action clients: 0
Action servers: 1
    /turtlesim
</code></pre>
<p>Well, that tells us about the client and servers, but it really isn't
helpful for our goal of moving Larry. Why don't we look at the <code>action send_goal</code> help and see if we can
figure out how to use it:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 action send_goal --help
usage: ros2 action send_goal [-h] [-f] action_name action_type goal

Send an action goal

positional arguments:
  action_name     Name of the ROS action (e.g. '/fibonacci')
  action_type     Type of the ROS action (e.g.
                  'example_interfaces/action/Fibonacci')
  goal            Goal request values in YAML format (e.g. '{order: 10}')

optional arguments:
  -h, --help      show this help message and exit
  -f, --feedback  Echo feedback messages for the goal
</code></pre>
<p>This command needs an action name, an action type, and a goal in YAML. We know
the action name, and we know how to write YAML, so all we need is to determine
the action type. The best way to get the action type is the same way we
published a message.</p>
<p>We see each of our turtles have one service called <code>rotate_absolute</code>.
Let's dig into this action using the <code>info</code> sub command. This command has a <code>-t</code>
flag to list the types of messages.</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 action info /turtle1/rotate_absolute -t
Action: /turtle1/rotate_absolute
Action clients: 0
Action servers: 1
  /turtlesim [turtlesim/action/RotateAbsolute]
</code></pre>
<p>The first line lists the action
name. The second line gives the current number of clients for the
action. The <code>Action servers</code> line gives the total number of action
servers for this action. The last line gives the package and message
type for the action.</p>
<p>We can see here that we need to know the action name, the type, and the
values. Now the only problem is figuring out the format of the
action type.</p>
<p>Let's understand the <code>RotateAbsolute</code> action message</p>
<p>The <code>ros2 interface show</code> command can be used to find the type of action
message. Let's take a look:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 interface show turtlesim/action/RotateAbsolute
# The desired heading in radians
float32 theta #&lt; --- This section is the GOAL
---
# The angular displacement in radians to the starting position
float32 delta #&lt; --- This section is the final result, different from the goal.
---
# The remaining rotation in radians
float32 remaining # &lt; --- This is the current state.

</code></pre>
<p>What does this say about rotate absolute?</p>
<ul>
<li>There is a float input, <code>theta</code>, the desired heading. This first section is the actual goal.</li>
<li><code>delta</code> is the angle from the initial heading. This is the value returned when the action completes.</li>
<li><code>remaining</code> is the remaining radians to move. This is the value posted by the action while the action is being done.</li>
</ul>
<p>With this information we can create our call to the action server. We'll
use the <code>-f</code> flag to make this a bit clearer. Keep an eye on your turtle! It should move, slowly.</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 action send_goal -f /turtle1/rotate_absolute turtlesim/action/RotateAbsolute {'theta: 1.70'}
Waiting for an action server to become available...
Sending goal:
  theta: 1.7

Feedback:
  remaining: 0.11599969863891602

Goal accepted with ID: 35c40e91590047099ae5bcc3c5151121

Feedback:
 remaining: 0.09999966621398926

Feedback:
 remaining: 0.06799960136413574

Feedback:
 remaining: 0.03599953651428223

Result:
 delta: -0.09600019454956055

Goal finished with status: SUCCEEDED
</code></pre>
<p>If everything worked correctly we should see our turtle has rotated.</p>
<h2 id="ros-parameters"><a class="header" href="#ros-parameters">ROS Parameters</a></h2>
<p>In ROS, parameters are values that are shared between nodes in the
system (if you are familiar with the <a href="https://en.wikipedia.org/wiki/Blackboard_(design_pattern)">blackboard design
pattern</a> in
software engineering). Parameters are values that any node can query or
write to. Another good analogy would be global constants in normal
software programs. Parameters are best used to configure your robot. For
example, if you were building an autonomous vehicle and wanted to cap
the maximum velocity of the vehicle at 100 km/h, you could create a
parameter called &quot;MAX_SPEED&quot; that is visible to all the nodes.</p>
<p>Let's take a look at the <code>param</code> command by running <code>ros2 param --help</code>.</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 param --help
Various param related sub-commands

Commands:
  delete  Delete parameter
  get     Get parameter
  list    Output a list of available parameters
  set     Set parameter
  Call `ros2 param &lt;command&gt; -h` for more detailed usage.
</code></pre>
<p>At a high level, ROS 2's <code>param</code> command has sub commands to get and set a variable,
along with a <code>list</code> functionality, and a <code>delete</code> command. As with most of the
other commands we've worked through, it is instructive to look at <code>list</code>
first. Let's see what the docs say about the <code>list</code> command and then see what
happens when we call the sub command:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 param list --help
usage: ros2 param list [-h] [--spin-time SPIN_TIME] [--include-hidden-nodes]
                       [--param-prefixes PARAM_PREFIXES [PARAM_PREFIXES ...]]
                       [node_name]

Output a list of available parameters

positional arguments:
  node_name             Name of the ROS node

optional arguments:
  -h, --help            show this help message and exit
  --spin-time SPIN_TIME
                        Spin time in seconds to wait for discovery (only
                        applies when not using an already running daemon)
  --include-hidden-nodes
                        Consider hidden nodes as well
  --param-prefixes PARAM_PREFIXES [PARAM_PREFIXES ...]
                        Only list parameters with the provided prefixes
$ ros2 param list
/turtlesim:
  background_b
  background_g
  background_r
  use_sim_time

</code></pre>
<p>The only argument of note in this sub command is the <code>node_name</code> which allows
you to narrow the scope of <code>param list</code> to only those parameters used by a particular
node. In terms of parameters in the <code>turtlesim</code> node, we see that our call to <code>param list</code> gives us: three background color control params named
<code>background_x</code> and a <code>use_sim_time</code> parameter. To learn all about the <code>param</code>
command why don't we try to change these background color parameters using the
CLI.</p>
<p>The first step in changing the background color is to see what the current color
is. The <code>param get</code> sub command requires both a node name and a parameter
name. In our list above we can see the node name as the top level element with
the forward slash in front of it, namely <code>/turtlesim</code>. The syntax for <code>param get</code> is <code>ros2 param get &lt;node_name&gt; &lt;param&gt;</code>. Let's give it a whirl and see our
current background color values.</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 param get /turtlesim background_b
Integer value is: 255
$ ros2 param get /turtlesim background_g
Integer value is: 86
$ ros2 param get /turtlesim background_r
Integer value is: 69
</code></pre>
<p>On most computers color is represented as a triplet of &lt;R,G,B&gt; values. The color
value of &lt;69,86,255&gt; corresponds to a periwinkle blue color.
To change the color of the turtlesim we need to first set the parameter
value and then reset the turtlesim to make it apply the color changes. We
covered the basics of calling a service previously so we won't cover the steps
of constructing a service call. Let's try setting our background color's blue
component to 128.</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 param set turtlesim background_b 128
Set parameter successful
$ ros2 service call /reset std_srvs/srv/Empty
requester: making request: std_srvs.srv.Empty_Request()

response:
std_srvs.srv.Empty_Response()
</code></pre>
<p>If everything worked correctly your turtle should look like the screen below.</p>
<p><img src="./images/blue_screen.png" alt="image" /></p>
<h2 id="ros-bags"><a class="header" href="#ros-bags">ROS Bags</a></h2>
<p>ROS bags are ROS's tool for recording, and replaying data. ROS bags are like log
files that let you store data along with messages. ROS systems can generate a
lot of data, so when you bag data you must select which topics you want. Bags
are a great tool for testing and debugging your application and a great tool for
building robust unit tests.</p>
<p>Let's take a look at the root ROS Bag command by typing <code>ros2 bag --help</code> into
the terminal. If you get an error you might need to install ROS Bag as it is
often in a separate package. On Linux you can run <code>sudo apt install ros-eloquent-ros2bag</code> and it should automatically install the package for you.</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 bag -h
usage: ros2 bag [-h] Call `ros2 bag &lt;command&gt; -h` for more detailed usage. ...

Various rosbag related sub-commands

Commands:
  info    ros2 bag info
  play    ros2 bag play
  record  ros2 bag record
</code></pre>
<p>As you can see there are three sub commands, <code>record</code>, <code>play</code>, and <code>info</code>. With these
commands you can record a bag file, play/replay a file you've recorded, and find information about a bag file.</p>
<p>Let's try recording our first bag file. To do this we'll need three terminals all
running ROS. The first terminal should already have our turtlesim running. If it
isn't running you can restart it with <code>ros2 run turtlesim turtlesim_node</code>. Next
you'll need to start the <code>draw_square</code> demo again to get the default turtle
moving. To do this run <code>ros2 run turtlesim draw_square</code>. Now, in a third
terminal we can bag some data by running the bag command. Let's first look at
the record sub command by running <code>ros2 bag record -h</code></p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 bag record -h
usage: ros2 bag record [-h] [-a] [-o OUTPUT] [-s STORAGE]
                       [-f SERIALIZATION_FORMAT] [--no-discovery]
                       [-p POLLING_INTERVAL] [-b MAX_BAG_SIZE]
                       [topics [topics ...]]

ros2 bag record

positional arguments:
  topics                topics to be recorded

optional arguments:
  -h, --help            show this help message and exit
  -a, --all             recording all topics, required if no topics are listed
                        explicitly.
  -o OUTPUT, --output OUTPUT
                        destination of the bagfile to create, defaults to a
                        timestamped folder in the current directory
  -s STORAGE, --storage STORAGE
                        storage identifier to be used, defaults to &quot;sqlite3&quot;
  -f SERIALIZATION_FORMAT, --serialization-format SERIALIZATION_FORMAT
                        rmw serialization format in which the messages are
                        saved, defaults to the rmw currently in use
  --no-discovery        disables topic auto discovery during recording: only
                        topics present at startup will be recorded
  -p POLLING_INTERVAL, --polling-interval POLLING_INTERVAL
                        time in ms to wait between querying available topics
                        for recording. It has no effect if --no-discovery is
                        enabled.
  -b MAX_BAG_SIZE, --max-bag-size MAX_BAG_SIZE
                        maximum size in bytes before the bagfile will be
                        split. Default it is zero, recording written in single
                        bagfile and splitting is disabled.
</code></pre>
<p>We can see from the help file that the syntax for recording a bag is to simply
give the sub command a list of topics to record. Most of the other arguments are
for more advanced users to help configure how and when data is stored. It is
worth noting that there is a <code>-a, --all</code> command that records all the data. You
can also specify the output bag file with the <code>-o, --output command</code>.</p>
<p>Let's go ahead and run our bag command, and let's bag the pose data on the
<code>/turtle1/pose</code> topic and save it to the file <code>turtle1.bag</code> using the <code>-o</code>
flag. Be aware that the program will continue bagging data until you hit
<code>CTRL-C</code>, so give the command a good 30 seconds to collect data before you kill
it.</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 bag record /turtle1/pose -o turtle1
[INFO] [rosbag2_storage]: Opened database 'turtle1'.
[INFO] [rosbag2_transport]: Listening for topics...
[INFO] [rosbag2_transport]: Subscribed to topic '/turtle1/pose'
[INFO] [rosbag2_transport]: All requested topics are subscribed. Stopping discovery...
^C[INFO] [rclcpp]: signal_handler(signal_value=2)
</code></pre>
<p>Now that we collected our data let's inspect our bag file. You can introspect
any bag file using the <code>ros2 bag info</code> command. This command will list the
messages in the bag, the duration of file, and the number of messages.</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 bag info turtle1
Files:             turtle1.db3
Bag size:          268.4 KiB
Storage id:        sqlite3
Duration:          68.705s
Start:             May  4 2020 16:10:26.556 (1588633826.556)
End                May  4 2020 16:11:35.262 (1588633895.262)
Messages:          4249
Topic information: Topic: /turtle1/pose | Type: turtlesim/msg/Pose | Count: 4249 | Serialization Format: cdr
</code></pre>
<p>Once you have collected a bag file you can replay the file just like a running
system. Bags are a great tool for debugging and testing. You can treat a ROS bag
like a recording of a running ROS system. When you play a bag file you
can use most of the ros2 CLI tools to inspect the recorded topics.</p>
<p>To replay the bag, first use <code>CTRL-C</code> to turn off the
<code>turtlesim_node</code> and the <code>draw_square</code> node. Now in a new terminal replay the bag
file using the following command:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 bag play turtle1
[INFO] [rosbag2_storage]: Opened database 'turtle1'.
</code></pre>
<p>Nothing should happen visibly, but a lot is happening under the hood.
To see what is happening go to a second terminal. Just like a running robot,
you should be able to <code>list</code> and <code>echo</code> topics:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 topic list
/parameter_events
/rosout
/turtle1/pose

$ ros2 bag info turtle1
x: 3.8595714569091797
y: 3.6481313705444336
theta: -1.2895503044128418
linear_velocity: 1.0
angular_velocity: 0.0
---
</code></pre>
<h2 id="ros2-component-command"><a class="header" href="#ros2-component-command">ROS2 Component Command</a></h2>
<h2 id="ros2-daemon-command"><a class="header" href="#ros2-daemon-command">ROS2 Daemon Command</a></h2>
<h2 id="ros2-doctor-command"><a class="header" href="#ros2-doctor-command">ROS2 Doctor Command</a></h2>
<p>With any complex system problems can sometimes arise, and knowing how to describe your
system and what is happening can do a lot to help others help you fix your
problem. ROS 2 has a <code>doctor</code> command that you can use to print a variety of
reports that you can use to help communicate the state of your system to others
trying to provide help. Whether it is one of your co-workers, a vendor, or an
on-line forum, providing detailed and complete information about your ROS system
can go a long way to solving your problem. Let's call <code>--help</code> on the ROS 2
doctor command:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 doctor --help
usage: ros2 doctor [-h] [--report | --report-failed] [--include-warnings]

Check ROS setup and other potential issues

optional arguments:
  -h, --help            show this help message and exit
  --report, -r          Print all reports.
  --report-failed, -rf  Print reports of failed checks only.
  --include-warnings, -iw
                        Include warnings as failed checks. Warnings are
                        ignored by default.
</code></pre>
<p>As we can see from the help file we have a couple of report options. One option
is to print the full report with <code>-r</code>, or just what failed with <code>-rf</code>. If you're
running <code>ros2 doctor -r</code> you should see a fairly lengthy report generated giving
information about your computer's operating system, your networking
configuration, and your running ROS system. If you ever run into an issue you
should always include this full report.</p>
<h2 id="ros-2-interface"><a class="header" href="#ros-2-interface">ROS 2 Interface</a></h2>
<p>As you've already seen, ROS uses standard messages so that different packages and
programs, potentially written in different programming languages, can all talk
to one another. To make this all work, ROS uses standard messages, and
communication protocols built on top of those standard messages. This can make
finding type information about a particular message, service, or action
difficult. To help developers write both CLI command calls and develop client
code, the ROS CLI has the interface command. We've touched on this command
briefly in other sections, as it is the go to tool for message type
information.</p>
<p>To better understand the <code>interface</code> command let's start by looking at its high
level help command to see what sub commands are available:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 interface --help
usage: ros2 interface [-h]
                      Call `ros2 interface &lt;command&gt; -h` for more detailed
                      usage. ...

Show information about ROS interfaces

optional arguments:
  -h, --help            show this help message and exit

Commands:
  list      List all interface types available
  package   Output a list of available interface types within one package
  packages  Output a list of packages that provide interfaces
  proto     Output an interface prototype
  show      Output the interface definition

  Call `ros2 interface &lt;command&gt; -h` for more detailed usage.
</code></pre>
<p>The interface command are all geared towards helping you understand
available message types. Let's examine the <code>list</code> sub command in depth. <code>list</code>
will list all of the available messages, services, and actions on your
system. This command has flags that can help you narrow down the scope of your
search. Even a basic ROS installation has a lot of messages, so a tool you
should get familiar with is <code>grep</code>. <code>grep</code> lets you search through some text to
find what you are looking for quickly and easily. You can grep in a case
insensitive manner using the <code>-i</code> flag followed by the text you want to search
for. We can tie this CLI tool to our interface tool by using the UNIX pipe operator <code>|</code>. The example below
shows you how to use the list operation and then how to use it to search:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 interface list --only-msgs
Messages:
    action_msgs/msg/GoalInfo
    action_msgs/msg/GoalStatus
	... &lt;DOZENS OF DIFFERENT TYPES&gt; ...
	visualization_msgs/msg/MarkerArray
    visualization_msgs/msg/MenuEntry
$ ros2 interface list --only-msgs | grep -i point
    geometry_msgs/msg/Point
    geometry_msgs/msg/Point32
    geometry_msgs/msg/PointStamped
    map_msgs/msg/PointCloud2Update
    pcl_msgs/msg/PointIndices
    rcl_interfaces/msg/FloatingPointRange
    sensor_msgs/msg/PointCloud
    sensor_msgs/msg/PointCloud2
    sensor_msgs/msg/PointField
    trajectory_msgs/msg/JointTrajectoryPoint
</code></pre>
<p>Using grep to search through CLI output is a common tactic used by developers to
find just the specific information they need. The next two sub commands
<code>package</code> and <code>packages</code> can be used to first determine what ROS packages are on
your system, and then to drill down into an individual package to determine what
messages are in that package. Note that
you can use <code>grep</code> just like before to search for your specific interest. The
example below shows you how to first determine if <code>std_msgs</code> is installed and
then to find out what sort of array types it contains:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 interface packages
action_msgs
action_tutorials_interfaces
actionlib_msgs
builtin_interfaces
composition_interfaces
diagnostic_msgs
example_interfaces
geometry_msgs
lifecycle_msgs
logging_demo
map_msgs
nav_msgs
pcl_msgs
pendulum_msgs
rcl_interfaces
rosgraph_msgs
rqt_py_common
sensor_msgs
shape_msgs
std_msgs
std_srvs
stereo_msgs
tf2_msgs
trajectory_msgs
turtlesim
unique_identifier_msgs
visualization_msgs
kscottz@kscottz-ratnest:~/Code/ros2multirobotbook/src$ ros2 interface package std_msgs | grep -i array
std_msgs/msg/Int8MultiArray
std_msgs/msg/Int32MultiArray
std_msgs/msg/MultiArrayLayout
std_msgs/msg/UInt64MultiArray
std_msgs/msg/Float32MultiArray
std_msgs/msg/UInt16MultiArray
std_msgs/msg/UInt32MultiArray
std_msgs/msg/Int16MultiArray
std_msgs/msg/ByteMultiArray
std_msgs/msg/Int64MultiArray
std_msgs/msg/Float64MultiArray
std_msgs/msg/UInt8MultiArray
std_msgs/msg/MultiArrayDimension

</code></pre>
<p>The next two commands are particularly
helpful and you should remember them as they will make your life much easier. As
we have discussed previously all message publication, service calls, and action
calls in the CLI take in both the message type and data you want to transmit in
YAML format. But what if you don't know the message format, and you don't know a lot about
YAML? The <code>interface show</code> and <code>interface proto</code> commands make this process
easier by respectively telling you first the message type and then the message
format. Recall earlier in the chapter when we called the <code>spawn</code> service on
our turtle simulation. We can use <code>interface show</code> to tell us broadly about the
service and what each of the values mean. We can then use <code>interface proto</code>,
short for prototype, to then generate an empty message that we can fill
out. See the example below:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 interface show turtlesim/srv/Spawn
float32 x
float32 y
float32 theta
string name # Optional.  A unique name will be created and returned if this is empty
---
string name
$ ros2 interface proto turtlesim/srv/Spawn
&quot;x: 0.0
y: 0.0
theta: 0.0
name: ''
&quot;
$ ros2 service call /spawn turtlesim/srv/Spawn &quot;{&lt;copy and paste proto here&gt;}&quot;

</code></pre>
<p>You can see from the example above how handy these tools can be. It is worth
noting that you need to paste the prototype into a set of quotes and curly
braces for the call to work <code>&quot;{&lt;prototype&gt;}&quot;</code>.</p>
<h2 id="ros-2-launch"><a class="header" href="#ros-2-launch">ROS 2 Launch</a></h2>
<p>The <code>launch</code> command is used to run ROS launch files. Up until this point we've
been running single ROS programs by hand using the <code>run</code> command, however this
is not how larger ROS systems are generally operated and many robots command
tens if not hundreds of small programs. The ROS launch command is different from
most of the other ROS commands in that it has no sub commands and has a single
function, to start a ROS launch file that executes multiple of programs.
To illustrate this command let's take a look at
its help file.</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 launch -h
usage: ros2 launch [-h] [-d] [-p | -s] [-a]
                   package_name [launch_file_name]
                   [launch_arguments [launch_arguments ...]]

Run a launch file

positional arguments:
  package_name          Name of the ROS package which contains the launch file
  launch_file_name      Name of the launch file
  launch_arguments      Arguments to the launch file; '&lt;name&gt;:=&lt;value&gt;' (for
                        duplicates, last one wins)

optional arguments:
  -h, --help            show this help message and exit
  -d, --debug           Put the launch system in debug mode, provides more
                        verbose output.
  -p, --print, --print-description
                        Print the launch description to the console without
                        launching it.
  -s, --show-args, --show-arguments
                        Show arguments that may be given to the launch file.
  -a, --show-all-subprocesses-output
                        Show all launched subprocesses' output by overriding
                        their output configuration using the
                        OVERRIDE_LAUNCH_PROCESS_OUTPUT envvar.
</code></pre>
<p>Launch files are usually included with a ROS package and are commonly stored in a
<code>launch</code> sub directory. Modern launch files are usually written in Python and end
with the <code>*.launch.py</code> file extension. The <code>launch</code> command has two arguments,
the first one is the package name and then the launch file name. If you are unaware
of the launch files in your package you can use tab completion to list all the
available launch files. Finally, some launch files have arguments that can be
appended to the command. If you are unsure about what a launch file does, or
what arguments it needs, the <code>--print</code> and <code>--show-args</code> commands will tell you
this information. Let's read up on the <code>multisym.launch.py</code> launch file and then
run it following the example below (end the simulation with <code>CTRL-C</code>):</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 launch turtlesim multisim.launch.py --show-args
Arguments (pass arguments as '&lt;name&gt;:=&lt;value&gt;'):

  No arguments.

$ ros2 launch turtlesim multisim.launch.py --print
&lt;launch.launch_description.LaunchDescription object at 0x7f75aab63828&gt;
├── ExecuteProcess(cmd=[ExecInPkg(pkg='turtlesim', exec='turtlesim_node'), '--ros-args'], cwd=None, env=None, shell=False)
└── ExecuteProcess(cmd=[ExecInPkg(pkg='turtlesim', exec='turtlesim_node'), '--ros-args'], cwd=None, env=None, shell=False)

$ ros2 launch turtlesim multisim.launch.py
[INFO] [launch]: All log files can be found below /home/kscottz/.ros/log/2020-06-24-14-39-03-312667-kscottz-ratnest-20933
[INFO] [launch]: Default logging verbosity is set to INFO
[INFO] [turtlesim_node-1]: process started with pid [20944]
[INFO] [turtlesim_node-2]: process started with pid [20945]
^C[WARNING] [launch]: user interrupted with ctrl-c (SIGINT)
</code></pre>
<h2 id="ros-2-lifecycle"><a class="header" href="#ros-2-lifecycle">ROS 2 Lifecycle</a></h2>
<p>ROS 2 has a new feature called <code>lifecycle</code> which allows for greater control over
the state of a ROS node. Roughly, this feature allows nodes to have complex
start-up and shut-down procedures that are correctly handed. An example of such
a node would be one that controls a sensor or actuator that needs to perform a
power-on self-test or calibration procedure prior to running. <a href="http://design.ros2.org/articles/node_lifecycle.html">The ROS design
docs</a>
give a great primer on the states and transitions in a lifecycle
node. Let's look at the
<code>lifecycle</code> command to determine what sub commands are available:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 lifecycle -h
usage: ros2 lifecycle [-h]
                      Call `ros2 lifecycle &lt;command&gt; -h` for more detailed
                      usage. ...

Various lifecycle related sub-commands

optional arguments:
  -h, --help            show this help message and exit

Commands:
  get    Get lifecycle state for one or more nodes
  list   Output a list of available transitions
  nodes  Output a list of nodes with lifecycle
  set    Trigger lifecycle state transition

  Call `ros2 lifecycle &lt;command&gt; -h` for more detailed usage.
</code></pre>
<p>The <code>nodes</code> sub command will list all the lifecycle nodes on a given system.
Once you have listed the nodes, you can list each node's available
transitions using <code>ros2 lifecycle list &lt;nodename&gt;</code>. These transitions are
dictated by the node's current state with some states having more transitions
available than others. If instead of available transitions you wish to query the
current state you can use <code>lifecycle get</code> to return the current state of
your target node. Once you have satisfactorily determined the state of the node
and the available transitions, the <code>lifecycle set</code> command can be used to trigger
the node to transition to a new state. Generally, these CLI commands are used to
diagnose failure modes of systems, or to manually transition a particular
component.</p>
<h2 id="ros-2-msg-message"><a class="header" href="#ros-2-msg-message">ROS 2 msg (Message)</a></h2>
<p>ROS 2 Eloquent is the last version of ROS to use the <code>msg</code> command. All of the
commands in <code>msg</code> are mirrored in the <code>interface</code> command. These features are
currently deprecated and will be removed in Foxy.</p>
<h2 id="ros-2-pkg-package"><a class="header" href="#ros-2-pkg-package">ROS 2 pkg (Package)</a></h2>
<p>The ROS 2 package command is a very useful command to understand what ROS
packages are installed on your system, where they are installed, and the
executables contained within each package. These tools are particularly useful
for understanding an existing robot configuration and finding tools that are
only used on occasion. Let's start by taking a look at the help file for the <code>pkg</code> command:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 pkg -h
usage: ros2 pkg [-h] Call `ros2 pkg &lt;command&gt; -h` for more detailed usage. ...

Various package related sub-commands

optional arguments:
  -h, --help            show this help message and exit

Commands:
  create       Create a new ROS2 package
  executables  Output a list of package specific executables
  list         Output a list of available packages
  prefix       Output the prefix path of a package
  xml          Output the XML of the package manifest or a specific tag

  Call `ros2 pkg &lt;command&gt; -h` for more detailed usage.
</code></pre>
<p>This command has a variety of sub commands, many of which should look fairly
familiar at this point. The <code>list</code> sub command acts in a manner very similar to
<code>list</code> sub commands we have discussed previously, but this one only lists the
installed system packages. This sub command is often used with <code>grep</code> to help you
find out if a particular package is installed.</p>
<p>Once you have located an installed package you can then have it list the
executables contained by the package using the <code>executables</code> command. This is
much more practical than finding the executables manually. The sub command takes
in a single argument which is the package name. The executables command has a
single optional argument, <code>--full-path</code>, which will output the full path to all
the executable programs. The example below shows how to use these
commands to check the path for all of the turtlesim executables:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 pkg list | grep turtle
turtlesim
$ ros2 pkg executables turtlesim --full-path
/opt/ros/eloquent/lib/turtlesim/draw_square
/opt/ros/eloquent/lib/turtlesim/mimic
/opt/ros/eloquent/lib/turtlesim/turtle_teleop_key
/opt/ros/eloquent/lib/turtlesim/turtlesim_node
</code></pre>
<p>If you just wanted to know the path to the turtlesim executables you could use
the <code>prefix</code> sub command, which returns the path for a given package's
executables.</p>
<p>Each ROS package contains an XML file that contains metadata for the package,
including information such as the license, maintainer, and its dependencies. ROS
pkg has a handy <code>xml</code> sub command to print these files to the screen, saving you
the hassle of locating and opening the file. You can use <code>grep</code> on the output of
this command to get just the info you need. Below is an example of <code>xml</code> and <code>prefix</code> used to find
the directory of turtlesim, its maintainer, and its license:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 pkg prefix turtlesim
/opt/ros/eloquent
$ ros2 pkg xml turtlesim | grep maintainer
  &lt;maintainer email=&quot;dthomas@osrfoundation.org&quot;&gt;Dirk Thomas&lt;/maintainer&gt;
$ ros2 pkg xml turtlesim | grep license
  &lt;license&gt;BSD&lt;/license&gt;
kscottz@kscottz-ratnest:~$

</code></pre>
<p>The last sub command in the <code>pkg</code> command is <code>create</code>. <code>create</code> is a tool to help
you create a ROS package. We'll use this sub command later in the chapter to
create a new ROS package. The short of it is that you feed the command your
package name and all of the relevant information for your package as optional
arguments.</p>
<h2 id="ros-2-security"><a class="header" href="#ros-2-security">ROS 2 Security</a></h2>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/ros2_cli.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="the-ros-api"><a class="header" href="#the-ros-api">The ROS API</a></h1>
<p>ROS comprises many software libraries that provide a wide array of
functionality useful when building robot applications. The libraries
you need will depend on the details of your project. In this section we will
introduce two core libraries that you are likely to interact with
frequently when developing with ROS:</p>
<ul>
<li><code>rclpy</code> : Python client library</li>
<li><code>rclcpp</code> : C++ client library</li>
</ul>
<p>A ROS <em>client library</em> provides the data structures, functions, and
syntactic sugar that make it convenient to develop in a particular
programming language. Here we will cover just the Python and C++
libraries because they're the most widely used. But you can find ROS
client libraries for many other languages, from Ada to JavaScript to
Rust, and beyond.</p>
<div style="border: 1px; border-style: solid; padding: 1em">
<b>Note</b>: In this section we aim for a gentle and efficient introduction
to the ROS API. In service of that goal, we will purposefully ignore
and/or violate various conventions and patterns.
</div>
<h2 id="publishing-and-subscribing-to-topics-in-python"><a class="header" href="#publishing-and-subscribing-to-topics-in-python">Publishing and Subscribing to Topics in Python</a></h2>
<p>Publishing data with ROS is easy. Here is a complete Python program that
publishes string messages:</p>
<pre><code class="language-{.sourceCode .py}">from time import sleep
import rclpy
from std_msgs.msg import String

rclpy.init()
node = rclpy.create_node('my_publisher')
pub = node.create_publisher(String, 'chatter', 10)
msg = String()
i = 0
while rclpy.ok():
    msg.data = f'Hello World: {i}'
    i += 1
    print(f'Publishing: &quot;{msg.data}&quot;')
    pub.publish(msg)
    sleep(0.5)
</code></pre>
<p>Try it out yourself. (Make sure that in every shell used you have
sourced your ROS setup file as we discussed in the previous chapter; e.g., <code>source /opt/ros/foxy/setup.bash</code>.) Copy the code block above into a file, call
it <code>talker.py</code>, then feed it to your Python3 interpreter:</p>
<pre><code class="language-{.sourceCode .bash}">$ python3 talker.py
</code></pre>
<p>You should see:</p>
<pre><code>Publishing: &quot;Hello world: 0&quot;
Publishing: &quot;Hello world: 1&quot;
Publishing: &quot;Hello world: 2&quot;
</code></pre>
<p>It prints to console, but is the data going anywhere? We can check
our work using the <code>ros2 topic</code> tool that was introduced earlier. In
another shell (leave your talker running), run:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 topic echo chatter
</code></pre>
<p>You should see the following, though the numbers will vary depending on timing between the two
commands:</p>
<pre><code>data: 'Hello world: 13'
---
data: 'Hello world: 14'
---
data: 'Hello world: 15'
</code></pre>
<p>So we have a working talker. Now we can add our own listener to use in
place of <code>ros2 topic</code>. Here is a complete Python program that subscribes
to string messages and prints them to console:</p>
<pre><code class="language-{sourceCode .py}">import rclpy
from std_msgs.msg import String

def cb(msg):
    print(f'I heard: &quot;{msg.data}&quot;')

rclpy.init()
node = rclpy.create_node('my_subscriber')
sub = node.create_subscription(String, 'chatter', cb, 10)
rclpy.spin(node)
</code></pre>
<p>Try it out yourself. Copy the code block above into a file and call it
<code>listener.py</code>. With your talker still running in one shell, start up your
listener in another shell:</p>
<pre><code class="language-{sourceCode .bash}">$ python3 listener.py
</code></pre>
<p>You should see (again, numbers will vary depending on timing):</p>
<pre><code>I heard: &quot;Hello world: 35&quot;
I heard: &quot;Hello world: 36&quot;
I heard: &quot;Hello world: 37&quot;
</code></pre>
<h3 id="digging-into-the-python-code"><a class="header" href="#digging-into-the-python-code">Digging into the Python Code</a></h3>
<p>Now that we know these programs work, we can dig into their code. Both
programs start with the same preamble:</p>
<pre><code class="language-{sourceCode .py}">import rclpy
from std_msgs.msg import String
</code></pre>
<p>We need to import the <code>rclpy</code> client library, which gives us
much of what we need to write ROS applications in Python. But we also need
to specifically import the ROS message type(s) that we will use. In this
case we are using the simple <code>std_msgs/String</code> message, which contains a
single field called <code>data</code>, of type <code>string</code>. If we wanted to use the
<code>sensor_msgs/Image</code> message, which represents camera images, then we
would write <code>from sensor_msgs.msg import Image</code>.</p>
<p>After the imports, both programs perform common initialization:</p>
<pre><code class="language-{sourceCode .py}">rclpy.init()
node = rclpy.create_node('my_node_name')
</code></pre>
<p>We initialize the <code>rclpy</code> library and then call into it to create a
<code>Node</code> object, giving it a name. Subsequently we will operate on that
<code>Node</code> object.</p>
<p>In the talker, we use the <code>Node</code> object to create a <code>Publisher</code> object:</p>
<pre><code class="language-{sourceCode .py}">pub = node.create_publisher(String, 'chatter', 10)
</code></pre>
<p>We declare the type of data we will publish (<code>std_msgs/String</code>), the
name of the topic on which we will publish (<code>chatter</code>), and the maximum
number of outbound messages to locally queue up (10). That last
argument comes into play when we are publishing faster than subscribers
are consuming the data.</p>
<p>The equivalent step in the listener is to create a <code>Subscription</code>
object:</p>
<pre><code class="language-{sourceCode .py}">sub = node.create_subscription(String, 'chatter', cb, 10)
</code></pre>
<p>The type (<code>String</code>) and topic name (<code>chatter</code>) arguments have the same meaning
as the <code>create_publisher()</code> call, and the final argument (10) is
setting an analogous maximum queue size for inbound messages. The key
difference is the <code>cb</code> argument, which refers to this <em>callback</em>
function that we also defined in the listener:</p>
<pre><code class="language-{sourceCode .py}">def cb(msg):
    print(f'I heard: &quot;{msg.data}&quot;')
</code></pre>
<p>That function will be called whenever the listener receives a message,
and the received message will be passed in as an argument. In this case
we simply print the content to console.</p>
<p>With the callback defined and the <code>Subscription</code> created, the rest of
the listener is one line:</p>
<pre><code class="language-{sourceCode .py}">rclpy.spin(node)
</code></pre>
<p>This call hands control over to <code>rclpy</code> to wait for new messages to
arrive (and more generally for events to occur) and invoke our callback.</p>
<p>Back in the talker, we create a simple loop to use our <code>Publisher</code>:</p>
<pre><code class="language-{sourceCode .py}">msg = String()
i = 0
while rclpy.ok():
    msg.data = f'Hello World: {i}'
    i += 1
    print(f'Publishing: &quot;{msg.data}&quot;')
    pub.publish(msg)
    sleep(0.5)
</code></pre>
<p>These steps are clear enough: we create a message object and then on
each iteration of the loop, we update the message content and publish
it, sleeping briefly between iterations.</p>
<h2 id="publishing-and-subscribing-to-topics-in-c"><a class="header" href="#publishing-and-subscribing-to-topics-in-c">Publishing and Subscribing to Topics in C++</a></h2>
<p>Now we will write the same talker and listener pair, this time in C++.</p>
<p>Here is a complete C++ program that publishes string messages:</p>
<pre><code class="language-{sourceCode .cpp}">#include &lt;unistd.h&gt;
#include &lt;iostream&gt;
#include &quot;rclcpp/rclcpp.hpp&quot;
#include &quot;std_msgs/msg/string.hpp&quot;

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);
  auto node = rclcpp::Node::make_shared(&quot;minimal_publisher&quot;);
  auto pub = node-&gt;create_publisher&lt;std_msgs::msg::String&gt;(&quot;chatter&quot;, 10);
  std_msgs::msg::String message;
  auto i = 0;
  while (rclcpp::ok()) {
    message.data = &quot;Hello world: &quot; + std::to_string(i++);
    std::cout &lt;&lt; &quot;Publishing: &quot; &lt;&lt; message.data &lt;&lt; std::endl;
    pub-&gt;publish(message);
    usleep(500000);
  }
  return 0;
}
</code></pre>
<p>Of course, as for all C++, we need to compile this program. Managing the
compilation arguments for C++ is cumbersome, so we use CMake to help.
Here is the complete CMake code that allows us to build the talker
example:</p>
<pre><code>cmake_minimum_required(VERSION 3.5)
project(talker_listener)

find_package(rclcpp REQUIRED)
find_package(std_msgs REQUIRED)

add_executable(talker talker.cpp)
target_include_directories(talker PRIVATE ${rclcpp_INCLUDE_DIRS} ${std_msgs_INCLUDE_DIRS})
target_link_libraries(talker ${rclcpp_LIBRARIES} ${std_msgs_LIBRARIES})
</code></pre>
<p>Try it out yourself. Copy the C++ code into a file called <code>talker.cpp</code>
and the CMake code into a file called <code>CMakeLists.txt</code>. Have them
side-by-side in a directory and then invoke <code>cmake</code> followed by <code>make</code>:</p>
<pre><code class="language-{sourceCode .bash}">$ cmake .
$ make
</code></pre>
<p>You should end up with a compiled executable called <code>talker</code>. Run it:</p>
<pre><code class="language-{sourceCode .bash}">$ ./talker
</code></pre>
<p>You should see:</p>
<pre><code>Publishing: &quot;Hello world: 0&quot;
Publishing: &quot;Hello world: 1&quot;
Publishing: &quot;Hello world: 2&quot;
</code></pre>
<p>Keep the talker running and another shell try <code>ros2 topic</code> to listen
in:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 topic echo chatter
</code></pre>
<p>You should see (numbers will vary depending on timing between the two
commands):</p>
<pre><code>data: 'Hello world: 13'
---
data: 'Hello world: 14'
---
data: 'Hello world: 15'
</code></pre>
<p>Now we can write our own listener to use in place of <code>ros2 topic</code>. Here
is a complete C++ program that subscribes to string messages and prints
them to console:</p>
<pre><code class="language-{sourceCode .cpp}">#include &quot;rclcpp/rclcpp.hpp&quot;
#include &quot;std_msgs/msg/string.hpp&quot;

void cb(const std_msgs::msg::String::SharedPtr msg)
{
  std::cout &lt;&lt; &quot;I heard: &quot; &lt;&lt; msg-&gt;data &lt;&lt; std::endl;
}

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);
  auto node = rclcpp::Node::make_shared(&quot;my_subscriber&quot;);
  auto sub = node-&gt;create_subscription&lt;std_msgs::msg::String&gt;(&quot;chatter&quot;, 10, cb);
  rclcpp::spin(node);
  return 0;
}
</code></pre>
<p>Copy the code block into a file called <code>talker.cpp</code>. To arrange for it
to be compiled, we also need to add some corresponding CMake code to the
bottom of our <code>CMakeLists.txt</code> file from earlier:</p>
<pre><code>add_executable(listener listener.cpp)
target_include_directories(listener PRIVATE ${rclcpp_INCLUDE_DIRS} ${std_msgs_INCLUDE_DIRS})
target_link_libraries(listener ${rclcpp_LIBRARIES} ${std_msgs_LIBRARIES})
</code></pre>
<p>Configure and build again:</p>
<pre><code class="language-{sourceCode .bash}">$ cmake .
$ make
</code></pre>
<p>Now you should have also have a <code>listener</code> executable. With your talker
still running in one shell, start up your listener in another shell:</p>
<pre><code class="language-{sourceCode .bash}">$ ./listener
</code></pre>
<p>You should see (again, numbers will vary depending on timing):</p>
<pre><code>I heard: &quot;Hello world: 35&quot;
I heard: &quot;Hello world: 36&quot;
I heard: &quot;Hello world: 37&quot;
</code></pre>
<h3 id="digging-into-the-c-code"><a class="header" href="#digging-into-the-c-code">Digging into the C++ Code</a></h3>
<p>Now that we know these programs work, we can dig into their code. Both
programs start with the same preamble:</p>
<pre><code class="language-{sourceCode .cpp}">#include &quot;rclcpp/rclcpp.hpp&quot;
#include &quot;std_msgs/msg/string.hpp&quot;
</code></pre>
<p>We always need to include the <code>rclcpp</code> client library, which gives us
much of what we need to write ROS applications in C++. But we also need to
specifically import the ROS message type(s) that we will use. In this
case we are using the simple <code>std_msgs/String</code> message, which contains a
single field called <code>data</code>, of type <code>string</code>. If we wanted to use the
<code>sensor_msgs/Image</code> message, which represents camera images, then we
would <code>#include &quot;sensor_msgs/msg/image.hpp&quot;</code>.</p>
<p>After the imports, both programs perform common initialization:</p>
<pre><code class="language-{sourceCode .cpp}">  rclcpp::init(argc, argv);
  auto node = rclcpp::Node::make_shared(&quot;my_node_name&quot;);
</code></pre>
<p>We initialize the <code>rclcpp</code> library and then call into it to create a
<code>Node</code> object, giving it a name. Subsequently we will operate on that
<code>Node</code> object.</p>
<p>In the talker, we use the <code>Node</code> object to create a <code>Publisher</code> object:</p>
<pre><code class="language-{sourceCode .cpp}">  auto pub = node-&gt;create_publisher&lt;std_msgs::msg::String&gt;(&quot;chatter&quot;, 10);
</code></pre>
<p>We declare via template the type of data we will publish (<code>std_msgs/String</code>), the
name of the topic on which we will publish (<code>chatter</code>), and the maximum
number of outbound messages to locally queue up (10). That last
argument comes into play when we are publishing faster than subscribers
are consuming the data.</p>
<p>The equivalent step in the listener is to create a <code>Subscription</code>
object:</p>
<pre><code class="language-{sourceCode .cpp}">  auto sub = node-&gt;create_subscription&lt;std_msgs::msg::String&gt;(&quot;chatter&quot;, 10, cb);
</code></pre>
<p>The type (<code>String</code>) and topic name (<code>chatter</code>) arguments have the same meaning
as for the <code>create_publisher()</code> call, and the numerical argument (10) is
setting an analogous maximum queue size for inbound messages. The key
difference is the <code>cb</code> argument, which refers to this <em>callback</em>
function that we also defined in the listener:</p>
<pre><code class="language-{sourceCode .cpp}">void cb(const std_msgs::msg::String::SharedPtr msg)
{
  std::cout &lt;&lt; &quot;I heard: &quot; &lt;&lt; msg-&gt;data &lt;&lt; std::endl;
}
</code></pre>
<p>That function will be called whenever the listener receives a message,
and the received message will be passed in as an argument. In this case
we simply print the content to console.</p>
<p>With the callback defined and the <code>Subscription</code> created, the rest of
the listener is one line:</p>
<pre><code class="language-{sourceCode .cpp}">  rclcpp::spin(node);
</code></pre>
<p>This call hands control over to <code>rclcpp</code> to wait for new messages to
arrive (and more generally for events to occur) and invoke our callback.</p>
<p>Back in the talker, we create a simple loop to use our <code>Publisher</code>:</p>
<pre><code class="language-{sourceCode .cpp}">  std_msgs::msg::String message;
  auto i = 0;
  while (rclcpp::ok()) {
    message.data = &quot;Hello world: &quot; + std::to_string(i++);
    std::cout &lt;&lt; &quot;Publishing: &quot; &lt;&lt; message.data &lt;&lt; std::endl;
    pub-&gt;publish(message);
    usleep(500000);
  }
</code></pre>
<p>In these steps we create a message object, and then on
each iteration of the loop we update the message content and publish
it, sleeping briefly between iterations.</p>
<h2 id="where-to-go-from-here"><a class="header" href="#where-to-go-from-here">Where to Go From Here</a></h2>
<p>That was a very brief introduction and we only covered topics, not
services, actions, parameters, or the many other facets of ROS. Luckily,
the online <a href="https://index.ros.org/doc/ros2/Tutorials">ROS tutorials</a> are
an excellent resource for learning about the rest of ROS. We
specifically recommend the <a href="https://index.ros.org/doc/ros2/Tutorials/#beginner-client-libraries">Beginner: Client
Libraries</a>
collection as a natural next step after reading this chapter.</p>
<h2 id="regarding-the-shortcuts"><a class="header" href="#regarding-the-shortcuts">Regarding the Shortcuts</a></h2>
<p>In this section we have presented the simplest, shortest example ROS
programs that we could come up with. Such programs are easy to
understand and learn from, as they do not have unnecessary structure or
decoration. But in exchange such programs are not easily extensible,
composable, or maintainable.</p>
<p>The techniques that we used in the example code in this section are
useful for prototyping and experimentation (an important aspect of any
good robotics project!), but we do not recommend them for serious work.
As you go through the <a href="https://index.ros.org/doc/ros2/Tutorials">ROS
tutorials</a> and start reading
existing ROS code, you will learn about a number of concepts, patterns,
and conventions, such as:</p>
<ul>
<li>organizing your code into <em>packages</em></li>
<li>organizing your packages into a <em>workspace</em></li>
<li>managing <em>dependencies</em> among packages</li>
<li>using the <code>colcon</code> tool to build code in multiple packages in dependency order</li>
<li>using the <code>ament</code> module in your <code>CMakeLists.txt</code> files</li>
<li>structuring your code to allow run-time control of how nodes maps to processes</li>
<li>using the client libraries' console-logging routines for output to screen and elsewhere</li>
</ul>
<p>These techniques will serve you well when you start building your own ROS
applications, especially when you want to share your code with others, whether
on your team or out in the world.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/ros2_api.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="traffic-editor-1"><a class="header" href="#traffic-editor-1">Traffic Editor</a></h1>
<p>This section describes the traffic-editor GUI and simulation tools.</p>
<h2 id="introduction-and-objectives"><a class="header" href="#introduction-and-objectives">Introduction and Objectives</a></h2>
<p>Traffic management of heterogeneous robot fleets is non-trivial. One of the
challenges with coordinated management arises from varying semantics in
information models used across fleets. Representations of waypoints, lanes,
charging/docking stations, restricted zones, infrastructure  systems such as
doors &amp; lifts, among others, are subject to vendor's discretion. However,
standardized conventions that convey the capabilities and intentions of fleets
in a shared facility are quintessential for planning. Multi-agent participants
in other modes of transportation such as roadways collectively adhere to a set
of rules and conventions which minimize chaos. More importantly, they allow for
a new participant to readily integrate into the system by following the
prescribed rules. Existing agents can accommodate the new participant as its
behavior is apparent.</p>
<p>Traffic conventions for multi-robot systems do not exist.
The objective of the <code>traffic_editor</code> is to fill this gap by expressing the
intentions of various fleets in a standardized, vendor neutral manner through a
graphical interface. Collated traffic information from different fleets can then
be exported for planning and control. A secondary objective and benefit of the
<code>traffic_editor</code> is to facilitate generation of 3D simulation worlds which
accurately reflect physical environments.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The <code>traffic_editor</code> <a href="https://github.com/open-rmf/rmf_traffic_editor">repository</a> is home to the <code>traffic_editor</code> GUI and tools to auto-generate simulation worlds from GUI output.
The GUI is an easy-to-use interface which can create and annotate 2D floor plans with robot traffic along with building infrastructure information.
Often times, there are existing floor plans of the environment, such as architectural drawings, which simplify the task and provide a &quot;reference&quot; coordinate system for vendor-specific maps.
For such cases, <code>traffic-editor</code> can import these types of &quot;backgroud images&quot; to serve as a canvas upon which to draw the intended robot traffic maps, and to make it easy to trace the important wall segments required for simulation.</p>
<p>The <code>traffic_editor</code> GUI projects are stored as <code>yaml</code> files with <code>.building.yaml</code> file extensions.
Although the typical workflow uses the GUI and does not require hand-editing the <code>yaml</code> files directly, we have used a <code>yaml</code> file format to make it easy to parse using custom scripting if needed.
Each <code>.building.yaml</code> file includes several attributes for each level in the site as annotated by the user.
An empty <code>.building.yaml</code> file appears below.
The GUI tries to make it easy to add and update content to these file.</p>
<pre><code class="language-yaml">levels:
  L1:
    doors:
      - []
    drawing:
      filename:
    fiducials:
    elevation: 0
    flattened_x_offset: 0
    flattened_y_offset: 0
    floors:
      - parameters: {}
        vertices: []
    lanes:
      - []
    layers:
      {}
    measurements:
      - []
    models:
      -{}
    vertices:
      {}
    walls:
      {}
lifts:
  {}
name: building

</code></pre>
<h2 id="gui-layout"><a class="header" href="#gui-layout">GUI Layout</a></h2>
<p>The layout of the <code>traffic_editor</code> includes a <code>Toolbar</code>, a <code>Working Area</code> and a <code>Sidebar</code> as seen in the figure below:</p>
<p><img src="images/traffic_editor/layout.png" alt="Traffic Editor GUI" /></p>
<p>The toolbar contains a variety of tools to support actions such as setting the scale of the drawing, aligning levels for multi-level scenarios, adding virtual models to simulated environments, adding robot traffic lanes, simulated flooring, and so on.</p>
<p>As usual in a modern GUI, the top Toolbar contains a variety of tools to interact with items in the main Working Area.
This document will introduce and explain the tools as an example project is created.
However, the first three tools in the toolbar are commonly found in 2D drawing tools, and should behave as expected:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Icon</th><th style="text-align: center">Name</th><th style="text-align: center">Shortkey</th><th style="text-align: center">Function</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="images/traffic_editor/icons/select.svg" alt="Select icon" /></td><td style="text-align: center">Select</td><td style="text-align: center"><code>Esc</code></td><td style="text-align: center">Select an entity in the <code>Working Area</code></td></tr>
<tr><td style="text-align: center"><img src="images/traffic_editor/icons/move.svg" alt="Move icon" /></td><td style="text-align: center">Move</td><td style="text-align: center"><code>m</code></td><td style="text-align: center">Move an entity in the <code>Working Area</code></td></tr>
<tr><td style="text-align: center"><img src="images/traffic_editor/icons/rotate.svg" alt="Rotate icon" /></td><td style="text-align: center">Rotate</td><td style="text-align: center"><code>r</code></td><td style="text-align: center">Rotate an entity in the <code>Working Area</code></td></tr>
</tbody></table>
</div>
<p>The <code>Working Area</code> is where the levels, along with their annotations, are rendered.
The user is able to zoom via the mouse scroll wheel, and pan the view by pressing the scroll wheel and moving the mouse cursor.</p>
<p>The <code>Sidebar</code> on the right side of the window contains multiple tabs with various functionalities:</p>
<ul>
<li><strong>levels:</strong> to add a new level to the building. This can be done from scratch or by importing a floor plan image file.</li>
<li><strong>layers:</strong> to overlap other images such as lidar maps over the level</li>
<li><strong>lifts:</strong> to configure and add lifts to the building</li>
<li><strong>traffic:</strong> to select which &quot;navigation graph&quot; is currently being edited, and toggle which graph(s) are being rendered.</li>
</ul>
<h2 id="annotation-guide"><a class="header" href="#annotation-guide">Annotation Guide</a></h2>
<p>This section walks through the process of annotating facilities while highlighting the capabilities of the <code>traffic_editor</code> GUI.</p>
<p>To create a new traffic editor <code>Building</code> file, launch the traffic editor from a terminal window (first sourcing the workspace if <code>traffic-editor</code> is built from source).
Then, click <code>Building -&gt; New...</code> and choose a location and filename for your <code>.building.yaml</code> file.</p>
<h3 id="adding-a-level"><a class="header" href="#adding-a-level">Adding a level</a></h3>
<p>A new level in the building can be added by clicking the <code>Add</code> button in the <code>levels</code> tab of the <code>Sidebar</code>.
The operation will open a dialog box where the <code>name</code>, <code>elevation</code> (in meters) and path to a 2D <code>drawing</code> file (<code>.png</code>) can be specified.
In most use cases, the floor plan for the level is used as the drawing.
If unspecified, the user may explicitly enter dimensions of the level in the fields provided.</p>
<p><img src="images/traffic_editor/add_level.png" alt="Add a level dialog" /></p>
<p>In the figure above, a new level <code>L1</code> at <code>0m</code> elevation and a floor plan have been added as reflected in the <code>levels</code> tab.
A default scale <code>1px = 5cm</code> is applied.
The actual scale can be set by adding a measurement.
Any offsets applied to align levels will be reflected in the <code>X</code> and <code>Y</code> columns.
Saving the project will update the <code>tutorial.building.yaml</code> files as seen below:</p>
<pre><code class="language-yaml">levels:
  L1:
    drawing:
      filename: office.png
    elevation: 0
    flattened_x_offset: 0
    flattened_y_offset: 0
    layers:
      {}
lifts:
  {}
name: building
</code></pre>
<h3 id="adding-a-vertex"><a class="header" href="#adding-a-vertex">Adding a vertex</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Icon</th><th style="text-align: center">Shortkey</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="images/traffic_editor/icons/vertex.svg" alt="Vertex icon" /></td><td style="text-align: center"><code>v</code></td></tr>
</tbody></table>
</div>
<p>A vertex is a fundamental component of multiple annotations.
Walls, measurements, doors, floor polygons and traffic lanes are created from two or more vertices.
To create a vertex, click on the vertex icon in the <code>Toolbar</code> and then click anywhere on the canvas.
The default attributes of a vertex are its coordinates along with an empty name field.
Additional attributes may be added by first selecting the vertex (which will turn it red), and then clicking the <code>Add</code> button in the figure.
Short descriptions of these are presented below:</p>
<ul>
<li><strong>is_holding_point:</strong> if true and if the waypoint is part of a traffic lane,
the <code>rmf_fleet_adapter</code> will treat this as a <em>holding point</em> during path
planning, i.e., the robot is allowed to wait at this waypoint for an indefinite
period of time.</li>
<li><strong>is_parking_spot:</strong> robot's parking spot. <a href="https://github.com/open-rmf/rmf_traffic/blob/40023b0f9b5d79a4781f6105f0368d74c1dfc443/rmf_traffic/include/rmf_traffic/agv/Graph.hpp#L73-L76">Definition</a></li>
<li><strong>is_passthrough_point:</strong> waypoint which the robot shouldnt stop. <a href="https://github.com/open-rmf/rmf_traffic/blob/40023b0f9b5d79a4781f6105f0368d74c1dfc443/rmf_traffic/include/rmf_traffic/agv/Graph.hpp#L63-L68">Definition</a></li>
<li><strong>is_charger:</strong> if true and if the waypoint is part of a traffic lane, the
<code>rmf_fleet_adapter</code> will treat this as a charging station.</li>
<li><strong>is_cleaning_zone</strong> indicate if current waypoint is a cleaning zone, specifically for <code>Clean</code> Task.</li>
<li><strong>dock_name:</strong> if specified and if the waypoint is part of a traffic lane, the
<code>rmf_fleet_adapter</code> will issue an <code>rmf_fleet_msgs::ModeRequest</code> message with
<code>MODE_DOCKING</code> and <code>task_id</code> equal to the specified name to the robot as it approaches this waypoint. This is used when the robot is executing their custom docking sequence (or custom travel path).</li>
<li><strong>spawn_robot_type:</strong> the name of the robot model to spawn at this waypoint in
simulation. The value must match the model's folder name in the assets
repository. More details on the robot model and plugin required for simulation
can be found in <a href="simulation.html">Simulation</a></li>
<li><strong>spawn_robot_name:</strong> a unique identifier for the robot spawned at this
waypoint. The <code>rmf_fleet_msgs::RobotState</code> message published by this robot
will have <code>name</code> field equal to this value.</li>
<li><strong>pickup_dispenser</strong> name of the dispenser workcell for <code>Delivery</code> Task, typically is the name of the model. See the [Workcell section] (https://osrf.github.io/ros2multirobotbook/simulation.html#workcells) of the Simulation Chapter for more details.</li>
<li><strong>dropoff_ingestor</strong> name of the ingestor workcell for <code>Delivery</code> Task, typically is the name of the model. See the [Workcell section] (https://osrf.github.io/ros2multirobotbook/simulation.html#workcells) of the Simulation Chapter for more details.</li>
<li><strong>human_goal_set_name</strong> The <code>goal_sets.set_area</code> name, used by crowd simulation. For more info about <code>crowd_sim</code>, please see the [Crowdsim section] (https://osrf.github.io/ros2multirobotbook/simulation.html#crowdsim) of the Simulation Chapter for more details.</li>
</ul>
<p><img src="images/traffic_editor/add_vertex.png" alt="Vertex attributes" /></p>
<p>Each vertex is stored in the <code>tutorial.building.yaml</code> file as a list of x-coordinate, y-coordinate, elevation, vertex_name and a set of additional parameters.</p>
<pre><code class="language-yaml">  vertices:
    - [1364.76, 1336.717, 0, magni1_charger, {is_charger: [4, true], is_parking_spot: [4, true], spawn_robot_name: [1, magni1], spawn_robot_type: [1, Magni]}]
</code></pre>
<h3 id="adding-a-measurement"><a class="header" href="#adding-a-measurement">Adding a measurement</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Icon</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="images/traffic_editor/icons/measurement.svg" alt="Measurement icon" /></td></tr>
</tbody></table>
</div>
<p>Adding a measurement sets the scale of the imported 2D drawing, which is essential for planning and simulation accuracy.
Scalebars or reference dimensions in the floor plan aid with the process. Often, you can draw the measurement line directly on top of a reference scale bar in a drawing.
With the editor in <em>Building</em> mode, select the <em>Add Measurement</em> tool and click on two points with known dimensions.
A pink line is rendered on the map with two vertices at its ends at the selected points.</p>
<p>Note:
A measurement line may be drawn by clicking on existing vertices.
In this scenario, no additional vertices are created at its ends.</p>
<p>Selecting the line populates various parameters in the Properties window of the <code>Sidebar</code>.
Setting the <code>distance</code> parameter to the physical distance between the points (in meters) will then update the <code>Scale</code> for the level.
Currently, you must save the project and restart <code>traffic-editor</code> to see the changes reflected (todo: fix this...).</p>
<p><img src="images/traffic_editor/add_measurement.png" alt="Measurement properties" /></p>
<p>The above process adds two <code>vertices</code> and a <code>measurement</code> field to the <code>tutorial.building.yaml</code> file as seen below.
For the measurement field, the first two elements represent the indices of vertices representing the ends of
the line.
The <code>distance</code> value is stored in a sub-list of parameters.</p>
<pre><code class="language-yaml">levels:
  L1:
    drawing:
      filename: office.png
    elevation: 0
    flattened_x_offset: 0
    flattened_y_offset: 0
    layers:
      {}
    measurements:
      - [1, 0, {distance: [3, 8.409]}]
    vertices:
      - [2951.728, 368.353, 0, &quot;&quot;]
      - [2808.142, 1348.9, 0, &quot;&quot;]

lifts:
  {}
name: building
</code></pre>
<h3 id="adding-a-wall"><a class="header" href="#adding-a-wall">Adding a wall</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Icon</th><th style="text-align: center">Shortkey</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="images/traffic_editor/icons/wall.svg" alt="Wall icon" /></td><td style="text-align: center"><code>w</code></td></tr>
</tbody></table>
</div>
<p>To annotate walls in the map, select the <em>Add Wall</em> icon from the <code>Toolbar</code> and click on consecutive vertices that represent the corners of the wall.
The process of adding wall segments is continuous, and can be exited by pressing the <code>Esc</code> key.
Blue lines between vertices are rendered on the map which represent the drawn walls.
If the corner vertices are not present, they will automatically be created when using this tool.
Meshes of the annotated walls are automatically generated during 3D world generation using <code>building_map_generator</code>.
By default, the walls are of thickness of 10cm and height 2.5m.
The <code>wall_height</code> and <code>wall_thickness</code> attributes may be
modified <a href="https://github.com/open-rmf/rmf_traffic_editor/blob/main/rmf_building_map_tools/building_map/wall.py#L16-L17">in the source code</a>.</p>
<p>Wall texture options are available <a href="https://github.com/open-rmf/rmf_traffic_editor/tree/main/rmf_building_map_tools/building_map_generator/textures">here</a> in the source code.</p>
<p><img src="images/traffic_editor/add_wall.png" alt="Annotating walls" /></p>
<p>Walls are stored in the <code>tutorial.building.yaml</code> file as a list with indices of start and end vertices of the wall segment along with an empty parameter set.</p>
<pre><code class="language-yaml">    walls:
      - [3, 4, {}]
      - [4, 5, {}]
      - [5, 6, {}]
      - [6, 7, {}]
      - [6, 8, {}]
      - [8, 9, {}]
</code></pre>
<h3 id="adding-a-floor"><a class="header" href="#adding-a-floor">Adding a floor</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Icon</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="images/traffic_editor/icons/floor.svg" alt="Floor icon" /></td></tr>
</tbody></table>
</div>
<p>Flooring is essential for simulations as it provides a ground plane for the robots to travel over.
Floors are annotated using the <em>Add floor polygon</em> tool from the <code>Main Toolbar</code> in <em>Building</em> edit mode.
To define a floor, select consecutive vertices to create a polygon that accurately represents the flooring area as seen below.
These vertices will need to be added manually prior to this step.
Once created, save the project and reload.
Selecting the defined floor highlights its texture attributes. Similarly, <a href="https://github.com/open-rmf/rmf_traffic_editor/tree/main/rmf_building_map_tools/building_map_generator/textures">default list of available textures</a> is available in the source code.</p>
<p><img src="images/traffic_editor/add_floor.png" alt="Highlighting floor's textures" /></p>
<p>Certain scenarios may call for floors with cavities, for example, to represent elevator shafts.
The <em>Add hole polygon</em> tool may be used for this purpose.
Additionally, the shape of a drawn polygon (floor or hole) may be modified using the <em>Edit polygon</em> tool.
Clicking on the tool after selecting an existing polygon enables the user to modify vertices of the polygon.</p>
<p>Each polygon is stored in the <code>tutorial.building.yaml</code> file in the format below:</p>
<pre><code class="language-yaml">    floors:
      - parameters: {texture_name: [1, blue_linoleum], texture_rotation: [3, 0], texture_scale: [3, 1]}
        vertices: [11, 10, 14, 15, 13, 12]
</code></pre>
<h3 id="adding-a-door"><a class="header" href="#adding-a-door">Adding a door</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Icon</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="images/traffic_editor/icons/door.svg" alt="Door icon" /></td></tr>
</tbody></table>
</div>
<p>A door between two vertices can be added in <em>Building</em> edit mode by selecting the <em>Add door</em> tool from the <code>Main Toolbar</code>, and clicking on vertices representing the ends of the door.
Selecting an annotated door highlights its properties as seen in the figure below.
Presently, four door <code>types</code> are supported: &quot;hinged&quot;, &quot;double_hinged&quot;, &quot;sliding&quot; and &quot;double_sliding&quot;.
The <code>motion_degrees</code> parameter specifies the range of motion in the case of hinged doors while the <code>motion_direction</code> dictates the direction of swing.
In order for the door to work in simulation, a <code>name</code> must be given to the door.</p>
<p><img src="images/traffic_editor/add_door.png" alt="Door type properties" /></p>
<p>Doors are stored in the <code>tutorial.building.yaml</code> file as a list with indices of start and end vertices along with the set of parameters that describes the door.</p>
<pre><code class="language-yaml"> doors:
      - [24, 25, {motion_axis: [1, start], motion_degrees: [3, 90], motion_direction: [2, 1], name: [1, D001], type: [1, double_sliding]}]
</code></pre>
<h3 id="adding-a-traffic-lane"><a class="header" href="#adding-a-traffic-lane">Adding a traffic lane</a></h3>
<p>One of the most important tools in the <code>traffic_editor</code> GUI is the <em>Add lane</em> tool.
The allowable motions of each fleet operating in the facility is conveyed through its respective Graph which consists of waypoints and connecting lanes.
In this approach, we assume that robots travel along effectively straight-line paths between waypoints.
While this may be perceived as an oversimplification of paths taken by robots that are capable of autonomous navigation, in practice the assumption holds fairly well given that these robots mostly travel along corridors or hallways and seldom in unconstrained open spaces.
For example, even in theoretically unconstrained spaces like building lobbies or shopping-mall atriums, it is likely that the site operator would prefer for the robots to operate in a &quot;traffic lane&quot; on the edge of the space, in order to not impede typical human traffic flows.</p>
<p>The <code>traffic</code> tab in the <code>Sidebar</code> has a default of nine Graphs for nine different fleets. To annotate lanes for a graph, say Graph 0, select the Graph from the <code>traffic</code> tab and click the <em>Add lane</em> tool.
Lanes for this graph can be drawn by clicking vertices to be connected.
If a vertex is not present, it will automatically be added. Properties may be assigned to each vertex as described in the preceding section.
To issue tasks to waypoints that require the robot to terminate at any waypoint, a name must be assigned to the waypoint.</p>
<p><img src="images/traffic_editor/add_lane.png" alt="Graphs' lane colors" /></p>
<p>Each Graph has a unique color for its lanes, and their visibility may be toggled using the checkbox in the <code>traffic</code> tab.
A lane that is defined between two waypoints may be configured with these additional properties:</p>
<ul>
<li><strong>bidirectional:</strong> if <code>true</code>, the <code>rmf_fleet_adapter</code> will plan routes for its
robot assuming the lanes can be traversed in both directions. Lanes that are
not bidirectional have arrows indicating their directionality (indigo lanes in
figure above). A handy shortcut is that when a lane segment is selected, you can
press the <code>b</code> key to toggle between unidirectional and bidirectional motion along that lane.</li>
<li><strong>graph_idx</strong>: the Graph number a lane corresponds to</li>
<li><strong>orientation</strong>: constrain the lane to make the robot travel in <code>forward</code> or <code>backward</code> orientation. This can be useful for the final lane segment approaching a docking point or charger, for example.</li>
</ul>
<p>While lifts that move between levels are now supported in the <code>traffic_editor</code>, the <strong>demo_mock_floor_name</strong> and <strong>demo_mock_lift_name</strong> properties were originally engineered to showcase shared lift access in a single floor demonstration environment with a &quot;mock&quot; lift that receives lift commands and transmits lift states but does not actually move between any different floors in a building.
However, as there may be interest in such functionality for testing single-floor hardware setups that seek to emulate multi-floor scenarios, these properties were retained.</p>
<ul>
<li><strong>demo_mock_floor_name</strong>: name of the floor that the robot is on while
traversing the lane</li>
<li><strong>demo_mock_lift_name</strong>: name of the lift that is being entered or exited
while the robot traverses the lane</li>
</ul>
<p>To further explain these properties, consider this representation of a
navigation graph where numbers are waypoints and letters are lanes:</p>
<pre><code>1 &lt;---a---&gt; 2 &lt;---b---&gt; 3

Waypoint 1 is on floor L1
Waypoint 2 is inside the &quot;lift&quot; named LIFT001
Waypoint 3 is on floor L3
The properties of edge &quot;a&quot; are:
    bidirectional: true
    demo_mock_floor_name: L1
    demo_mock_lift_name: LIFT001
The properties of edge &quot;b&quot; are:
    bidirectional: true
    demo_mock_floor_name: L3
    demo_mock_lift_name: LIFT001
</code></pre>
<p>If the robot is to travel from waypoint 1 to waypoint 3, the <code>rmf_fleet_adapter</code> will request for the &quot;mock lift&quot; to arrive at L1 when the robot approaches waypoint 1.
With confirmation of the &quot;lift&quot; at L1 and its doors in &quot;open&quot; state, the robot will be instructed to move into the &quot;lift&quot; to waypoint 2.
Once the &quot;lift&quot; indicates that it has reached L3, the robot will exit along lane b toward waypoint 3.</p>
<p>Note: when annotating graphs, it is highly recommended to follow an ascending sequence of graph indices without skipping intermediate numbers. Drawn lanes can only be interacted with if their associated Graph is first selected in the <code>traffic</code> tab.</p>
<p>The annotated Graphs are eventually exported as <code>navigation graphs</code> using the <code>building_map_generator</code> which are then used by respective <code>rmf_fleet_adapters</code> for path planning.</p>
<p>Lanes are stored in the following format in <code>tutorial.building.yaml</code>.
The data structure is a list with the first two elements representing the indices of the two vertices of the lane and a set of parameters with configured properties.</p>
<pre><code class="language-yaml">    lanes:
      - [32, 33, {bidirectional: [4, true], demo_mock_floor_name: [1, &quot;&quot;], demo_mock_lift_name: [1, &quot;&quot;], graph_idx: [2, 2], orientation: [1, forward]}]
</code></pre>
<h3 id="deriving-coordinate-space-transforms"><a class="header" href="#deriving-coordinate-space-transforms">Deriving coordinate-space transforms</a></h3>
<p>Coordinate spaces are confusing!
For historical reasons, the GUI internally creates traffic maps by annotating images, so the &quot;raw&quot; annotations are actually encoded in pixel coordinates of the &quot;base&quot; floorplan image, in pixel coordinates, with +X=right and +Y=down, with the origin in the upper-left of the base floorplan image.
However, during the building map generation step, the vertical axis is flipped to end up in a Cartesian plane, so the vast majority of RMF (that is, everything downstream of traffic-editor and the building map generators) uses a &quot;normal&quot; Cartesian coordinate system. (As an aside -- the next version of traffic-editor is intended to be more flexible in this respect, and will default to a normal Cartesian coordinate system (not an image-based coordinate system), or even global coordinates (lat/lon). Although preliminary work is underway, there is not a hard schedule for this next-gen editor at time of writing, so the rest of this chapter will describe the existing <code>traffic-editor</code>.)</p>
<p>Although <code>traffic-editor</code> currently uses the upper-left corner of the base floorplan image as the reference frame, maps generated by robots likely will have their origin elsewhere, and will likely be oriented and scaled differently.
It is critical to derive the correct transform between coordinate frames in <code>traffic_editor</code> maps and robot maps as
<code>rmf_fleet_adapters</code> expect all robots to publish their locations in the RMF coordinate system while the <code>rmf_fleet_adapters</code> also issue path requests in the same frame.</p>
<p>To derive such transforms, the <code>traffic_editor</code> GUI allows users to overlay robot maps on a floor plan and apply scale, translation and rotation transformations such that the two maps align correctly.
The user can then apply the same transformations to convert between robot map and RMF coordinates when programming interfaces for their robot.</p>
<p>The robot map can be imported by clicking the <code>Add</code> button from the <code>layers</code> tab in the <code>Sidebar</code>.
A dialog box will then prompt the user to upload the robot map image.
The same box contains fields for setting the scale for the image along with applying translations and rotation.
Through visual feedback, the user can determine appropriate values for these fields.
As seen in the image below, importing the robot-generated map into the GUI has it located and oriented
differently than the floor plan.
With the right transformation values, the two maps can be made to overlap.</p>
<p><img src="images/traffic_editor/coordinate_transform.png" alt="Overlap robot-generated map" /></p>
<h3 id="adding-fiducials"><a class="header" href="#adding-fiducials">Adding fiducials</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Icon</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="images/traffic_editor/icons/fiducial.svg" alt="Fiducial icon" /></td></tr>
</tbody></table>
</div>
<p>For maps with multiple levels, fiducials provide a means to scale and align different levels with respect to a reference level.
This is crucial for ensuring dimensional accuracy of annotations across different levels and aligning the
same for simulation.
Fiducials are reference markers placed at locations which are expected to be vertically aligned between two or more levels.
For example, structural columns may run through multiple floors and their locations are often indicated on floor plans.
With two or more pairs of corresponding markers between a level and a reference level, a geometric transformation (translation, rotation and scale) may be derived between the two levels.
This transformation can then be applied to all the vertices and models in the newly defined level.</p>
<p>To begin, add two or more non-collinear fiducials to the reference level with unique <code>name</code> attributes using the <em>Add fiducial</em> tool (left image in figure below).
In the newly created level, add the same number of fiducials at locations that are expected to be vertically aligned with matching names as the reference level (right image in figure below).
Saving and reloading the project computes the transformation between the levels which is evident from the Scale
and X-Y offsets for the new level as seen in the <code>levels</code> tab.
This level is now ready to be annotated.</p>
<p><img src="images/traffic_editor/add_fiducial.png" alt="Adding fiducials" /></p>
<p>For each level, fiducials are stored in a list of their X &amp; Y coordinates along with their name.</p>
<pre><code class="language-yaml">    fiducials:
      - [936.809, 1323.141, F1]
      - [1622.999, 1379.32, F2]
      - [2762.637, 346.69, F3]
</code></pre>
<h3 id="adding-a-lift"><a class="header" href="#adding-a-lift">Adding a lift</a></h3>
<p>Lifts are integral resources that are shared between humans and robot fleets in multi-level facilities.
To add a lift to a building, click the <code>Add</code> button in the <code>lifts</code> tab in the <code>Sidebar</code>.
A dialog box with various configurable properties will load.
It is essential to specify the Name, Reference level and the X&amp;Y coordinates (pixel units) of its cabin center.
A yaw (radians) may further be added to orient the lift as desired.
The width and depth of the cabin (meters) can also be customized.
Lifts can be designed to have multiple cabin doors which may open at more than one level.
To add a cabin door, click the <code>Add</code> button in the box below the cabin image.
Each cabin door requires a name along with positional and orientational information.
Here, the X&amp;Y coordinates are relative to the cabin center.</p>
<p><img src="images/traffic_editor/add_lift.png" alt="Configuring lift properties" /></p>
<p>The configured lift is stored in the <code>tutorial.building.yaml</code> file as described below:</p>
<pre><code class="language-yaml">lifts:
  LF001:
    depth: 2
    doors:
      door1:
        door_type: 2
        motion_axis_orientation: 1.57
        width: 1
        x: 1
        y: 0
      door2:
        door_type: 2
        motion_axis_orientation: 1.57
        width: 1
        x: -1
        y: 0
    level_doors:
      L1: [door1]
      L2: [door2]
    reference_floor_name: L1
    width: 2
    x: 827
    y: 357.7
    yaw: 1.09
</code></pre>
<p>After adding the lift, we would also wish to let our robots to transverse through the lift.
To achieve that, the user needs to create vertices/waypoints which are located within the lift cabin on each floor.
Once done, connect the waypoint within the lift cabin to other vertices via <strong>add_lane</strong>.</p>
<h3 id="adding-environment-assets"><a class="header" href="#adding-environment-assets">Adding environment assets</a></h3>
<p>Levels may be annotated with thumbnails of models available for simulation using the <strong>Add model</strong> tool in <strong>Building</strong> edit mode.
Selecting this tool opens a dialog box with a list of model names and matching thumbnails which can be imported to the map.
Once on the map, their positions and orientations can be adjusted using the <em>Move</em> and <em>Rotate</em> tools. Sample models are provided <a href="https://github.com/open-rmf/rmf_traffic_editor/tree/main/rmf_traffic_editor_assets/assets/thumbnails/images/cropped/OpenRobotics">here</a></p>
<p>The <a href="https://github.com/open-rmf/rmf_traffic_editor/tree/main/rmf_traffic_editor#generating-custom-thumbnails">thumbnail_generator documentation</a> contains instructions on expanding the list of thumbnails for other models.</p>
<blockquote>
<p>Note: If no models are shown on the <strong>add models</strong> window, Go to &quot;Edit -&gt; Preference&quot;, then indicate the thumbnail path. (<code>e.g. $HOME/rmf_ws/src/rmf/rmf_traffic_editor/rmf_traffic_editor_assets/assets/thumbnails</code>)</p>
</blockquote>
<p><img src="images/traffic_editor/add_model.png" alt="Model name and thumbnails dialog" /></p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>This chapter covered various capabilities of the <code>traffic_editor</code> which are useful for annotating maps of facilities while adhering to a standardized set of semantics.
Examples of other traffic editor projects can be found in the <a href="https://github.com/open-rmf/rmf_demos">rmf_demos</a> repository.
Running physics based simulations with RMF in the annotated sites is described in the <a href="simulation.html">Simulation</a> chapter.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/traffic-editor.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="simulation"><a class="header" href="#simulation">Simulation</a></h1>
<p>This chapter describes how to generate building models from
<code>traffic_editor</code> files, and then simulate fleets of robots in those models.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Simulation environments for testing robotic solutions offer immense value across
various stages of R&amp;D and deployment. More notably, simulations provide the
following benefits:</p>
<ul>
<li>
<p><strong>Time and resource saving:</strong> While testing with hardware is indispensable,
the process can slow development with additional setup time, robot
downtime and reset periods between trials. As the number of participants
scale, so do costs associated with purchasing hardware and consumables for
testing. This is especially true when utilizing a solution such as RMF, which aims to
integrate several mobile/stationary robots together with building systems such as doors
and lifts. Simulations provide a potentially cost-effective and time-saving alternative
for evaluating the behavior of robot systems at scale. More importantly,
simulations can help answer questions prior to deployment such as how many
participants can be supported or how the existing behavior would change with
the introduction of a new fleet, both of which can inform purchasing decisions
for facility owners.</p>
</li>
<li>
<p><strong>Robust testing:</strong> Robots in simulation neither run out of battery nor incur costs when they happen to unfortunately crash into something. Scenarios
can be tested for hours at a stretch, at faster speeds, to fine tune
algorithms and verify their robustness. One consideration about the appropriate amount of scenario testing to run is a decision that depends on how much compute power you want to avail for the simulation. With the introduction of cloud simulation, this limit is then a trade off of cost and speed as well. As scenarios in simulation are
repeatable, fixes for undesirable bugs encountered can be readily validated.
Reaction of the system to edge cases which are rare but have severe
consequences can also be studied through simulation. Data logged from hardware
trials can be used to recreate the scenario in simulation which may be further
helpful for debugging. Lastly, long running simulations can instill confidence
in facility owners prior to deployment.</p>
</li>
</ul>
<p>Physics-based simulators, such as <code>Gazebo</code>, carry the benefit of easily
interfacing with ROS 2 nodes through wrappers provided by <code>gazebo_ros_pkgs</code>.
Gazebo plugins can be developed that accurately emulate the behavior of robots,
sensors and infrastructure systems which enhance the overall fidelity of
simulations. It is worth emphasizing here that the exact same code used to run the simulations
will also be run on the physical system as well without any changes.</p>
<p>However, despite these compelling benefits, simulations are sparingly employed
by developers and system integrators, citing complexity over generating
environments and configuring them with appropriate plugins. In a recent publication &quot;<em>A Study on the Challenges of Using Robotics Simulators for Testing</em>,&quot; by Afsoon Afzal, Deborah S. Katz, Claire Le Goues and Christopher S. Timperley they noted the main reasons participants gave for not using simulation for a particular project and summarized their findings as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Reason for not using simulation</th><th>#</th><th>%</th></tr></thead><tbody>
<tr><td>Lack of time or resources</td><td>15</td><td>53.57%</td></tr>
<tr><td>Not realistic/accurate enough</td><td>15</td><td>53.57%</td></tr>
<tr><td>Lack of expertise or knowledge on how to use software-based simulation</td><td>6</td><td>21.43%</td></tr>
<tr><td>There was no simulator for the robot</td><td>4</td><td>14.29%</td></tr>
<tr><td>Not applicable</td><td>4</td><td>14.29%</td></tr>
<tr><td>Too much time or compute resources</td><td>2</td><td>7.14%</td></tr>
<tr><td>Nobody suggested it</td><td>0</td><td>0.00%</td></tr>
<tr><td>Other</td><td>2</td><td>7.14%</td></tr>
</tbody></table>
</div>
<p>The RMF project aims to address these hurdles by simplifying the process of setting up
simulation environments for multi-fleet traffic control, as we will explain further throughout this section.</p>
<h2 id="building-map-generator"><a class="header" href="#building-map-generator">Building Map Generator</a></h2>
<p><code>traffic_editor</code>, discussed in the previous chapter, is a tool to annotate building
floor plans with fleet-specific traffic information in a vendor neutral manner.
This includes waypoints of interest, traffic lanes and shared resources such as
doorways and lifts. It can also be used to markup the walls and floors and add
thumbnails of artifacts in the environment. The ability to auto-generate a 3D
world using this annotated map is significantly valuable for simplifying the
creation and management of simulations. To this end, the <code>building_map_tools</code>
package in <code>traffic_editor</code> contains an executable <code>building_map_generator</code>. The
executable operates in two modes:</p>
<ol>
<li>Generate a Gazebo/Ignition compliant <code>.world</code> file</li>
<li>Export the fleet specific traffic information in the form
of navigation graphs which are utilized by <code>fleet_adapters</code> for planning</li>
</ol>
<p><img src="images/building_map_generator.png" alt="Building map generator" /></p>
<p>To auto-generate a Gazebo simulation world, the executable takes in the command argument <code>gazebo</code> along with others described below:</p>
<pre><code class="language-bas">usage: building_map_generator gazebo [-h] [-o [OPTIONS [OPTIONS ...]]] [-n]
                                     [-m MODEL_PATH] [-c CACHE]
                                     INPUT OUTPUT_WORLD OUTPUT_MODEL_DIR

positional arguments:
  INPUT                 Input building.yaml file to process
  OUTPUT_WORLD          Name of the .world file to output
  OUTPUT_MODEL_DIR      Path to output the map model files

optional arguments:
  -h, --help            show this help message and exit
  -o [OPTIONS [OPTIONS ...]], --options [OPTIONS [OPTIONS ...]]
                        Generator options
  -n, --no_download     Do not download missing models from Fuel
  -m MODEL_PATH, --model_path MODEL_PATH
                        Gazebo model path to check for models
  -c CACHE, --cache CACHE
                        Path to pit_crew model cache
</code></pre>
<p>The script parses the <code>.building.yaml</code> file and generates meshes for the
flooring and walls for each level. Those meshes are then combined into a <code>model.sdf</code> file in
the <code>OUTPUT_MODEL_DIR/</code> directory. The <code>model.sdf</code> files for each level are
imported into the <code>.world</code> with filepath <code>OUTPUT_WORLD</code>. Model sub-elements for
various static objects annotated in the <code>traffic_editor</code> are included in the
<code>.world</code> as seen in the snippet below:</p>
<pre><code class="language-xml">&lt;include&gt;
  &lt;name&gt;OfficeChairBlack_6&lt;/name&gt;
  &lt;uri&gt;model://OfficeChairBlack&lt;/uri&gt;
  &lt;pose&gt;4.26201267190027 -7.489812761393875 0 0 0 1.1212&lt;/pose&gt;
  &lt;static&gt;True&lt;/static&gt;
&lt;/include&gt;
</code></pre>
<p>Similar blocks for annotated robots are
generated. It is the responsibility of the user to append the environment
variable <code>$GAZEBO_MODEL_PATH</code> with the relevant paths to the models prior to
loading the <code>.world</code> file in Gazebo. This process can be simplified through ROS 2
launch files and will be discussed in later sections.</p>
<p>The parser also includes sdf elements for other dynamic assets such as doors and
lifts. Their mechanisms are discussed in the next section. An Ignition
compatible world can be generated by using the command argument <code>ignition</code>.</p>
<p>Reconfiguring simulation environments becomes as trivial as editing the
annotations on the 2D drawing and re-running the <code>building_map_generator</code>. This
is exceedingly useful to quickly evaluate traffic flow as the spatial
configuration in the facility changes.</p>
<p>To generate navigation graphs for fleet adapters, the <code>building_map_generator</code>
is executed with command argument <code>nav</code>. The navigation graph is generated as
a <code>.yaml</code> file and is parsed during launch by the corresponding fleet adapter.</p>
<pre><code class="language-bash">usage: building_map_generator nav [-h] INPUT OUTPUT_DIR

positional arguments:
  INPUT       Input building.yaml file to process
  OUTPUT_DIR  Path to output the nav .yaml files
</code></pre>
<h2 id="rmf-assets-and-plugins"><a class="header" href="#rmf-assets-and-plugins">RMF Assets and Plugins</a></h2>
<p>Assets play a pivotal role in recreating environments in simulation. Projects
such as RMF, SubT and others have allowed developers to create and open source
3D models of robots, mechanical infrastructure systems and scene objects.
They are available for download on the <a href="https://app.ignitionrobotics.org/OpenRobotics/fuel/collections/">Ignition Fuel app</a>.
Beyond imparting visual accuracy, assets can be dynamic and interface with RMF
core systems through the aid of plugins.</p>
<p>To simulate the behavior of hardware such as robot models and infrastructure
systems, several Gazebo plugins have been architected. These plugins are
derivatives of the <a href="http://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1ModelPlugin.html">ModelPlugin</a>
class and tie in standard ROS 2 and RMF core messages to provide necessary
functionality. The following sections briefly describe some of these plugins.</p>
<h3 id="robots"><a class="header" href="#robots">Robots</a></h3>
<p>As highlighted earlier, several robot models (SESTO, MiR100, Magni, Hospi) have been
open sourced for use in simulation. For these models to emulate the behavior of
their physical counterparts which have been integrated with RMF, they need to 1)
interface with <code>rmf_fleet_adapters</code> and 2) navigate to locations in the
simulated world. These functionalities, for a &quot;<em>full control</em>&quot; robot type, are
achieved through the <code>slotcar</code> <a href="https://github.com/open-rmf/rmf_simulation/blob/main/rmf_robot_sim_gazebo_plugins/src/slotcar.cpp">plugin</a>.
The plugin subscribes to <code>/robot_path_requests</code> and <code>/robot_mode_requests</code>
topics and responds to relevant <code>PathRequest</code> and <code>ModeRequest</code> messages
published by its <code>rmf_fleet_adapter</code>. The plugin also publishes the robot's
state to the <code>/robot_state</code> topic.</p>
<p>To navigate the robot through waypoints in a <code>PathRequest</code> message, a simple
&quot;rail-like&quot; navigation algorithm is utilized which accelerates and decelerates
the robot along a straight line from its current position to the next waypoint.
The plugin relies on these fundamental assumptions:</p>
<ul>
<li>The robot model is a two-wheel differential drive robot</li>
<li>The left and right wheel joints are named  <code>joint_tire_left</code> and <code>joint_tire_right</code> respectively</li>
</ul>
<p>Other parameters, the majority of which are kinematic properties of the robot, are inferred from sdf parameters:</p>
<pre><code class="language-xml">&lt;plugin name=&quot;slotcar&quot; filename=&quot;libslotcar.so&quot;&gt;
  &lt;nominal_drive_speed&gt;0.5&lt;/nominal_drive_speed&gt;
  &lt;nominal_drive_acceleration&gt;0.25&lt;/nominal_drive_acceleration&gt;
  &lt;max_drive_acceleration&gt;0.75&lt;/max_drive_acceleration&gt;
  &lt;nominal_turn_speed&gt;0.6&lt;/nominal_turn_speed&gt;
  &lt;nominal_turn_acceleration&gt;1.5&lt;/nominal_turn_acceleration&gt;
  &lt;max_turn_acceleration&gt;2.0&lt;/max_turn_acceleration&gt;
  &lt;tire_radius&gt;0.1&lt;/tire_radius&gt;
  &lt;base_width&gt;0.3206&lt;/base_width&gt;
  &lt;stop_distance&gt;0.75&lt;/stop_distance&gt;
  &lt;stop_radius&gt;0.75&lt;/stop_radius&gt;
&lt;/plugin&gt;
</code></pre>
<p>During simulation, it is assumed that the robot's path is free of static
obstacles, but the plugin still contains logic to pause the robot's motion if an
obstacle is detected in its path. While it is possible to deploy a sensor based
navigation stack, the approach is avoided to minimize the computational load on
the system from running a navigation stack for each robot in the simulation.
Given the focus on traffic management of heterogeneous fleets and not robot
navigation, the <code>slotcar</code> plugin provides an efficient means to simulate the
interaction between RMF core systems and robots.</p>
<p>The <code>slotcar</code> plugin is meant to serve as a generalized solution. Vendors are
encouraged to develop and distribute plugins that represent the
capabilities of their robot and the level of integration with RMF more accurately.</p>
<h3 id="doors"><a class="header" href="#doors">Doors</a></h3>
<p>Unlike robot models whose geometries are fixed and hence can be directly
included in the generated <code>.world</code> file, doors are custom defined in
<code>traffic_editor</code> and have their own generation pipeline. As seen in the figure
below, an annotated door has several properties which include the location of
its ends, the type of door (hinged, double_hinged, sliding, double_sliding) and
its range of motion (for hinged doors).</p>
<p><img src="images/door_traffic_editor.png" alt="Door properties" /></p>
<p>The <code>building_map_generator gazebo</code> script parses a <code>.building.yaml</code> file for
any doors and automatically generates an sdf sub-element with links and joints
required for the door along with a configured plugin. The sdf sub-element
generated for the door in the figure above is presented below.</p>
<pre><code class="language-xml">&lt;model name=&quot;coe_door&quot;&gt;
  &lt;pose&gt;8.077686357313898 -5.898342045416362 0.0 0 0 1.1560010438234292&lt;/pose&gt;
  &lt;plugin filename=&quot;libdoor.so&quot; name=&quot;door&quot;&gt;
    &lt;v_max_door&gt;0.5&lt;/v_max_door&gt;
    &lt;a_max_door&gt;0.3&lt;/a_max_door&gt;
    &lt;a_nom_door&gt;0.15&lt;/a_nom_door&gt;
    &lt;dx_min_door&gt;0.01&lt;/dx_min_door&gt;
    &lt;f_max_door&gt;500.0&lt;/f_max_door&gt;
    &lt;door left_joint_name=&quot;left_joint&quot; name=&quot;coe_door&quot; right_joint_name=&quot;empty_joint&quot; type=&quot;SwingDoor&quot; /&gt;
  &lt;/plugin&gt;
  &lt;link name=&quot;left&quot;&gt;
    &lt;pose&gt;0 0 1.11 0 0 0&lt;/pose&gt;
    &lt;visual name=&quot;left&quot;&gt;
      &lt;material&gt;
        &lt;ambient&gt;120 60 0 0.6&lt;/ambient&gt;
        &lt;diffuse&gt;120 60 0 0.6&lt;/diffuse&gt;
      &lt;/material&gt;
      &lt;geometry&gt;
        &lt;box&gt;
          &lt;size&gt;0.8766026166317483 0.03 2.2&lt;/size&gt;
        &lt;/box&gt;
      &lt;/geometry&gt;
    &lt;/visual&gt;
    &lt;collision name=&quot;left&quot;&gt;
      &lt;surface&gt;
        &lt;contact&gt;
          &lt;collide_bitmask&gt;0x02&lt;/collide_bitmask&gt;
        &lt;/contact&gt;
      &lt;/surface&gt;
      &lt;geometry&gt;
        &lt;box&gt;
          &lt;size&gt;0.8766026166317483 0.03 2.2&lt;/size&gt;
        &lt;/box&gt;
      &lt;/geometry&gt;
    &lt;/collision&gt;
    &lt;inertial&gt;
      &lt;mass&gt;50.0&lt;/mass&gt;
      &lt;inertia&gt;
        &lt;ixx&gt;20.17041666666667&lt;/ixx&gt;
        &lt;iyy&gt;23.36846728119012&lt;/iyy&gt;
        &lt;izz&gt;3.20555061452345&lt;/izz&gt;
      &lt;/inertia&gt;
    &lt;/inertial&gt;
  &lt;/link&gt;
  &lt;joint name=&quot;left_joint&quot; type=&quot;revolute&quot;&gt;
    &lt;parent&gt;world&lt;/parent&gt;
    &lt;child&gt;left&lt;/child&gt;
    &lt;axis&gt;
      &lt;xyz&gt;0 0 1&lt;/xyz&gt;
      &lt;limit&gt;
        &lt;lower&gt;-1.57&lt;/lower&gt;
        &lt;upper&gt;0&lt;/upper&gt;
      &lt;/limit&gt;
    &lt;/axis&gt;
    &lt;pose&gt;0.44330130831587417 0 0 0 0 0&lt;/pose&gt;
  &lt;/joint&gt;
&lt;/model&gt;
</code></pre>
<p>The door <a href="https://github.com/open-rmf/rmf_simulation/blob/main/rmf_building_sim_common/src/door_common.cpp">plugin</a> responds to <code>DoorRequest</code> messages with <code>door_name</code> matching its <code>model name</code> sdf tag. These messages are published over the <code>/door_requests</code> topic. The plugin is agnostic of the type of door defined and relies on the <code>left_joint_name</code> and <code>right_joint_name</code> parameters to determine which joints to actuate during open and close motions. During these motions, the joints are commanded to their appropriate limits which are specified in the parent element. The joint motions adhere to kinematic constraints specified by sdf parameters while following acceleration and deceleration profiles similar to the <code>slotcar</code>.</p>
<p>To avoid situations where one robot requests a door to close on another robot, a <code>door_supervisor</code> <a href="https://github.com/open-rmf/rmf_ros2/tree/main/rmf_fleet_adapter/src/door_supervisor">node</a> is deployed in practice. The node publishes to <code>/door_requests</code> and subscribes to <code>/adapter_door_requests</code> which the fleet adapters publish to when their robot requires access through a door. The <code>door_supervisor</code> keeps track of requests from all the fleet adapters in the system and relays the request to the door adapters while avoiding aforementioned conflicts.</p>
<h3 id="lifts"><a class="header" href="#lifts">Lifts</a></h3>
<p>The ability to test lift integration is crucial as these systems are often the operational bottlenecks in facilities given their shared usage by both humans and multi robot fleets. As with annotated doors, lifts can be customized in a number of ways in the <code>traffic_editor</code> GUI including the dimension &amp; orientation of the cabin and mapping cabin doors to building levels.</p>
<p><img src="images/lift_traffic_editor.png" alt="Customizing lifts in Traffic Editor" /></p>
<p>The <code>building_map_generator gazebo</code> script parses the <code>.building.yaml</code> file for lift definitions and auto-generates the sdf elements for the cabin, cabin doors and lift shaft doors.
A prismatic joint is defined at the base of the cabin which is actuated by the lift plugin to move the cabin between different levels.
While the cabin doors are part of the cabin structure, the shaft doors are fixed to the building.
Both sets of doors open and close simultaneously at a given level and are controlled by the lift plugin itself.
These doors are created using the same method as other doors in the building and include the door plugin as well.</p>
<p>The <code>building_map_generator</code> also appends a lift plugin (TODO add link element with required parameters to the lift's model sdf block.)</p>
<pre><code class="language-xml">&lt;plugin filename=&quot;liblift.so&quot; name=&quot;lift&quot;&gt;
  &lt;lift_name&gt;Lift1&lt;/lift_name&gt;
  &lt;floor elevation=&quot;0.0&quot; name=&quot;L1&quot;&gt;
    &lt;door_pair cabin_door=&quot;CabinDoor_Lift1_door1&quot; shaft_door=&quot;ShaftDoor_Lift1_L1_door1&quot; /&gt;
  &lt;/floor&gt;
  &lt;floor elevation=&quot;10.0&quot; name=&quot;L2&quot;&gt;
    &lt;door_pair cabin_door=&quot;CabinDoor_Lift1_door1&quot; shaft_door=&quot;ShaftDoor_Lift1_L2_door1&quot; /&gt;
    &lt;door_pair cabin_door=&quot;CabinDoor_Lift1_door2&quot; shaft_door=&quot;ShaftDoor_Lift1_L2_door2&quot; /&gt;
  &lt;/floor&gt;
  &lt;floor elevation=&quot;20.0&quot; name=&quot;L3&quot;&gt;
    &lt;door_pair cabin_door=&quot;CabinDoor_Lift1_door1&quot; shaft_door=&quot;ShaftDoor_Lift1_L3_door1&quot; /&gt;
  &lt;/floor&gt;
  &lt;reference_floor&gt;L1&lt;/reference_floor&gt;
  &lt;v_max_cabin&gt;2.0&lt;/v_max_cabin&gt;
  &lt;a_max_cabin&gt;1.2&lt;/a_max_cabin&gt;
  &lt;a_nom_cabin&gt;1.0&lt;/a_nom_cabin&gt;
  &lt;dx_min_cabin&gt;0.001&lt;/dx_min_cabin&gt;
  &lt;f_max_cabin&gt;25323.0&lt;/f_max_cabin&gt;
  &lt;cabin_joint_name&gt;cabin_joint&lt;/cabin_joint_name&gt;
&lt;/plugin&gt;
</code></pre>
<p>The plugin subscribes to <code>/lift_requests</code> topic and responds to <code>LiftRequest</code> messages with <code>lift_name</code> matching its <code>model name</code> sdf tag.
The displacement between the cabin's current elevation and that of the <code>destination_floor</code> is computed and a suitable velocity is applied to the cabin joint.
Prior to any motion, the cabin doors are closed and only opened at the <code>destination_floor</code> if specified in the <code>LiftRequest</code> message.
As the cabin and shaft doors are configured with the <code>door</code> plugin, they are commanded through <code>DoorRequest</code> messages published by the <code>lift</code> plugin.
Analogous to the <code>door_supervisor</code>, a <code>lift_supervisor</code> <a href="https://github.com/open-rmf/rmf_ros2/tree/main/rmf_fleet_adapter/src/lift_supervisor">node</a> is started in practice to manage requests from different robot fleets.</p>
<h3 id="workcells"><a class="header" href="#workcells">Workcells</a></h3>
<p>A common use case is robots performing deliveries within facilities, so a <code>Delivery</code> task is configured into the <code>rmf_fleet_adapters</code>.
In a delivery task, a payload is loaded onto the robot at one location (pickup waypoint) and unloaded at another (dropoff waypoint).
The loading and unloading of the payload onto and from a robot may be automated by robots/workcells in the facility. These devices are henceforth referred to as dispensers and ingestors respectively.</p>
<p>To replicate the loading and unloading processes in simulation, the <code>TeleportDispenser</code> and <code>TeleportIngestor</code> <a href="https://github.com/open-rmf/rmf_simulation/tree/main/rmf_robot_sim_gazebo_plugins/src">plugins</a> have been designed.
These plugins are attached to the <code>TeleportDispenser</code> and <code>TeleportIngestor</code> <a href="https://github.com/open-rmf/rmf_demos/tree/main/rmf_demos_assets/models">3D models</a>, respectively.
To setup a payload loading station in simulation:</p>
<ul>
<li>Add a <code>TeleportDispenser</code> model beside the pickup waypoint and assign it a
unique <code>name</code></li>
<li>Add the payload model beside the <code>TeleportDispenser</code> model (Coke can in image below)</li>
</ul>
<p>To setup a payload unloading station in simulation:</p>
<ul>
<li>Add a <code>TeleportIngestor</code> model beside the dropoff waypoint and assign it a
unique <code>name</code></li>
</ul>
<p>When a <code>DispenserRequest</code> message is published with <code>target_guid</code> matching the
name of the <code>TeleportDispenser</code> model, the plugin will teleport the payload onto
the nearest robot model. Conversely, when an <code>IngestorRequest</code> message is published
with the <code>target_guid</code> matching the name of the <code>TeleportIngestor</code> model, the
<code>TeleportIngestor</code> plugin will teleport the payload from the robot to its location in
the world. The combinations of these plugins allow delivery requests to be simulated.
In the future, these mechanisms will be replaced by actual workcells or robot arms
but the underlying message exchanges will remain the same.</p>
<p><img src="images/dispensers.png" alt="TeleportDispenser and TeleportIngestor models" /></p>
<h3 id="crowdsim"><a class="header" href="#crowdsim">Crowdsim</a></h3>
<p>Crowd Simulation, aka <code>CrowdSim</code> is an optional feature in RMF simulation. User can
choose to enable crowdsim on <code>rmf_traffic_editor</code>. In RMF, the crowdsim plugin uses
<a href="https://github.com/open-rmf/menge_vendor">menge</a> as the core to control each of
simulated agent in the world.</p>
<p>An example of crowdsim is demonstrated on rmf_demos's <code>airport_world</code>:</p>
<pre><code class="language-bash">ros2 launch rmf_demos_gz airport_terminal.launch.xml use_crowdsim:=1
</code></pre>
<p>For more details on how <code>crowdsim</code> works and how to configure it,
please dive in to <a href="https://github.com/FloodShao/crowd_simulation/blob/master/crowd_simulation_doc/crowd_simulation_usage.md">the detailed guide for using Crowdsim</a>.</p>
<p><img src="images/airport_crowdsim.png" alt="crowdsim example" /></p>
<hr />
<h2 id="creating-simulations-and-running-scenarios"><a class="header" href="#creating-simulations-and-running-scenarios">Creating Simulations and Running Scenarios</a></h2>
<p>The section aims to provide an overview of the various components in the <code>rmf_demos</code> <a href="https://github.com/open-rmf/rmf_demos">repository</a> which may serve as a reference for setting up other simulations and assigning tasks to robots. Here, we will focus on the <code>office</code> world.</p>
<h3 id="map-package"><a class="header" href="#map-package">Map package</a></h3>
<p>The <code>rmf_demos_maps</code> package houses annotated <code>traffic_editor</code> files which will be used for the 3D world generation. Opening the <code>office.project.yaml</code> file in <code>traffic_editor</code> reveals a single level floorplan that has walls, floors, scale measurements, doors, lanes and models annotated. All the robot lanes are set to <code>bidirectional</code> with <code>graph_idx</code> equal to &quot;0&quot;. The latter signifies that all the lanes belong to the same fleet. In the <code>airport</code> world, we have two sets of graphs with indices &quot;0&quot; and &quot;1&quot; which reflect laneways occupiable by two fleets respectively. The figure below highlights properties assigned to a lane and a waypoint that serves as a robot spawn location.</p>
<p><img src="images/rmf_demos_maps.png" alt="Robot spawn location properties" /></p>
<p>To export a 3D world file along with the navigation graphs, the <code>building_map_generator</code> script is used. The <code>CMakeLists.txt</code> file of this package is configured to automatically run the generator scripts when the package is built. The outputs are installed to the <code>share/</code> directory for the package. This allows for the generated files to be easily located and used by other packages in the demo.</p>
<pre><code class="language-cmake">foreach(path ${traffic_editor_paths})

  # Get the output world name
  string(REPLACE &quot;.&quot; &quot;;&quot; list1 ${path})
  list(GET list1 0 name)
  string(REPLACE &quot;/&quot; &quot;;&quot; list2 ${name})
  list(GET list2 -1 world_name)

  set(map_path ${path})
  set(output_world_name ${world_name})
  set(output_dir ${CMAKE_CURRENT_BINARY_DIR}/maps/${output_world_name})
  set(output_world_path ${output_dir}/${output_world_name}.world)
  set(output_model_dir ${output_dir}/models)

  # first, generate the world
  add_custom_command(
    OUTPUT ${output_world_path}
    COMMAND ros2 run rmf_building_map_tools building_map_generator gazebo ${map_path} ${output_world_path} ${output_model_dir}
    DEPENDS ${map_path}
  )

  add_custom_target(generate_${output_world_name} ALL
    DEPENDS ${output_world_path}
  )

  # now, generate the nav graphs
  set(output_nav_graphs_dir ${output_dir}/nav_graphs/)
  set(output_nav_graphs_phony ${output_nav_graphs_dir}/phony)
  add_custom_command(
    OUTPUT ${output_nav_graphs_phony}
    COMMAND ros2 run rmf_building_map_tools building_map_generator nav ${map_path} ${output_nav_graphs_dir}
    DEPENDS ${map_path}
  )

  add_custom_target(generate_${output_world_name}_nav_graphs ALL
    DEPENDS ${output_nav_graphs_phony}
  )

  install(
    DIRECTORY ${output_dir}
    DESTINATION share/${PROJECT_NAME}/maps
  )

endforeach()

</code></pre>
<h3 id="launch-files"><a class="header" href="#launch-files">Launch Files</a></h3>
<p>The <code>rmf_demos</code> package includes all the essential launch files required to bring up the simulation world and start various RMF services. The office simulation is launched using the <code>office.launch.xml</code> file. First, a <code>common.launch.xml</code> file is loaded and starts:</p>
<ul>
<li>The <code>rmf_traffic_schedule</code> node responsible for maintaining the database of robot trajectories and monitoring traffic for conflicts. If a conflict is detected, notifications are sent to relevant fleet adapters which begin the negotiation process to find an optimal resolution.</li>
<li>The <code>building_map_server</code> which publishes a <code>BuildingMap</code> message used by UIs for visualization. The executable takes in the path to the relevant <code>.building.yaml</code> file as an argument. The <code>office.building.yaml</code> file installed by the <code>rmf_demos_maps</code> package is located using the <code>find-pkg-share</code> substitution command and is stored in the <code>config_file</code> argument.</li>
<li>The <code>rmf_schedule_visualizer</code> which is an RViz based UI to visualize the traffic lanes, actual positions of the robots, expected trajectory of robots as reflected in the <code>rmf_traffic_schedule</code> and states of building systems such as door and lifts.</li>
<li>The <code>door_supervisor</code> and <code>lift_supervisor</code> nodes to manage requests submitted by fleet adapter and UIs.</li>
</ul>
<pre><code class="language-xml">&lt;!-- Common launch --&gt;
&lt;include file=&quot;$(find-pkg-share demos)/common.launch.xml&quot;&gt;
  &lt;arg name=&quot;use_sim_time&quot; value=&quot;true&quot;/&gt;
  &lt;arg name=&quot;viz_config_file&quot; value =&quot;$(find-pkg-share demos)/include/office/office.rviz&quot;/&gt;
  &lt;arg name=&quot;config_file&quot; value=&quot;$(find-pkg-share rmf_demos_maps)/office/office.building.yaml&quot;/&gt;
&lt;/include&gt;
</code></pre>
<p>To launch a simulated world in gazebo, a snippet from <a href="https://github.com/open-rmf/rmf_demos/tree/main/rmf_demos_gz">rmf_demos_gz</a>
is shown below. Similarly, user can also choose to run with ignition
simulator, <a href="https://github.com/open-rmf/rmf_demos/tree/main/rmf_demos_ign">rmf_demos_ign</a></p>
<pre><code class="language-xml">  &lt;group&gt;
    &lt;let name=&quot;world_path&quot; value=&quot;$(find-pkg-share rmf_demos_maps)/maps/office/office.world&quot; /&gt;
    &lt;let name=&quot;model_path&quot; value=&quot;$(find-pkg-share rmf_demos_maps)/maps/office/models:$(find-pkg-share rmf_demos_assets)/models:/usr/share/gazebo-9/models&quot; /&gt;
    &lt;let name=&quot;resource_path&quot; value=&quot;$(find-pkg-share rmf_demos_assets):/usr/share/gazebo-9&quot; /&gt;
    &lt;let name=&quot;plugin_path&quot; value=&quot;$(find-pkg-prefix rmf_gazebo_plugins)/lib:$(find-pkg-prefix building_gazebo_plugins)/lib&quot; /&gt;

    &lt;executable cmd=&quot;gzserver --verbose -s libgazebo_ros_factory.so -s libgazebo_ros_init.so $(var world_path)&quot; output=&quot;both&quot;&gt;
      &lt;env name=&quot;GAZEBO_MODEL_PATH&quot; value=&quot;$(var model_path)&quot; /&gt;
      &lt;env name=&quot;GAZEBO_RESOURCE_PATH&quot; value=&quot;$(var resource_path)&quot; /&gt;
      &lt;env name=&quot;GAZEBO_PLUGIN_PATH&quot; value=&quot;$(var plugin_path)&quot; /&gt;
      &lt;env name=&quot;GAZEBO_MODEL_DATABASE_URI&quot; value=&quot;&quot; /&gt;
    &lt;/executable&gt;
    &lt;executable cmd=&quot;gzclient --verbose $(var world_path)&quot; output=&quot;both&quot;&gt;
      &lt;env name=&quot;GAZEBO_MODEL_PATH&quot; value=&quot;$(var model_path)&quot; /&gt;
      &lt;env name=&quot;GAZEBO_RESOURCE_PATH&quot; value=&quot;$(var resource_path)&quot; /&gt;
      &lt;env name=&quot;GAZEBO_PLUGIN_PATH&quot; value=&quot;$(var plugin_path)&quot; /&gt;
    &lt;/executable&gt;
  &lt;/group&gt;
</code></pre>
<p>Lastly, instances of the &quot;full control&quot; <code>rmf_fleet_adapter</code> are launched for each robot type annotated in the map. The navigation graphs for each fleet as generated by the <code>building_map_generator</code> script is passed via the <code>nav_graph_file</code> argument. For the office map, a single fleet of <code>Magni</code> robots is defined. Hence, a single <code>magni_adapter.launch.xml</code> file configured with the kinematic properties of this robot type along with spatial thresholds used for planning, is launched. Along with the fleet adapter, a <code>robot_state_aggregator</code> node is started. This node aggregates <code>RobotState</code> messages with <code>RobotState.name</code> containing the <code>robot_prefix</code> argument and publishes the aggregate to <code>/fleet_states</code> with <code>FleetState.name</code> specified by the <code>fleet_name</code> argument.</p>
<pre><code class="language-xml">&lt;group&gt;
  &lt;let name=&quot;fleet_name&quot; value=&quot;magni&quot;/&gt;
  &lt;include file=&quot;$(find-pkg-share rmf_demos)/include/adapters/magni_adapter.launch.xml&quot;&gt;
    &lt;arg name=&quot;fleet_name&quot; value=&quot;$(var fleet_name)&quot;/&gt;
    &lt;arg name=&quot;use_sim_time&quot; value=&quot;$(var use_sim_time)&quot;/&gt;
    &lt;arg name=&quot;nav_graph_file&quot; value=&quot;$(find-pkg-share rmf_demos_maps)/maps/office/nav_graphs/0.yaml&quot; /&gt;
  &lt;/include&gt;
  &lt;include file=&quot;$(find-pkg-share rmf_fleet_adapter)/robot_state_aggregator.launch.xml&quot;&gt;
    &lt;arg name=&quot;robot_prefix&quot; value=&quot;magni&quot;/&gt;
    &lt;arg name=&quot;fleet_name&quot; value=&quot;$(var fleet_name)&quot;/&gt;
    &lt;arg name=&quot;use_sim_time&quot; value=&quot;true&quot;/&gt;
  &lt;/include&gt;
&lt;/group&gt;
</code></pre>
<p>When testing RMF with hardware, the same launch files can be used, with the exception of starting <code>Gazebo</code>.
More information on running demos with hardware can be found <a href="integration.html">the chapter on Integration</a>.</p>
<h3 id="task-requests"><a class="header" href="#task-requests">Task Requests</a></h3>
<p>RMF supports various tasks out of the box. For more information see <a href="./task.html">Tasks in RMF</a>
A web-based dashboard is provided to allow users to send commands to RMF.
Once the <a href="https://github.com/open-rmf/rmf_demos/blob/0d4265a6c81a24e2bbfe6378b4060e94f50066a9/rmf_demos/launch/common.launch.xml#L67-L72">dashboard server</a> is launched, it can be accessed at https://open-rmf.github.io/rmf-panel-js/.</p>
<p><img src="https://github.com/open-rmf/rmf_demos/raw/media/RMF_Panel.png?raw=true" alt="Custom RMF web panel" /></p>
<p>Alternatively several scripts exist in <code>rmf_demos_tasks</code> to assist users with submitting requests from the terminal. Presently the <code>dispatch_loop.py</code>, <code>dispatch_delivery.py</code> and <code>dispatch_clean.py</code> scripts can be used to submit <code>Loop</code>, <code>Delivery</code> and <code>Clean</code> requests.</p>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>This chapter covered the utilization of the <code>traffic_editor</code> tool to create annotated maps that allow the auto-generation of 3D worlds for simulations.
It also covered the assets used within simulations and the corresponding plugins necessary for ROS 2 and RMF to interface with them.
A working example of these components running together, in the form of the <code>rmf_demos_maps</code> package, was provided as a reference for how to actualize a custom system.
The next chapter will introduces the basic concept behind RMF.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/simulation.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="rmf-core-overview"><a class="header" href="#rmf-core-overview">RMF Core Overview</a></h1>
<p>This chapter describes RMF, an umbrella term for a wide range of open specifications and software
tools that aim to ease the integration and interoperability of robotic systems,
building infrastructure, and user interfaces. <code>rmf_core</code> consists of:</p>
<ul>
<li><a href="https://github.com/open-rmf/rmf_traffic">rmf_traffic</a>: Core scheduling and traffic management systems</li>
<li><a href="https://github.com/open-rmf/rmf_ros2/tree/main/rmf_traffic_ros2">rmf_traffic_ros2</a>: rmf_traffic for ros2</li>
<li><a href="https://github.com/open-rmf/rmf_task">rmf_task</a>: Task planner for rmf</li>
<li><a href="https://github.com/open-rmf/rmf_battery">rmf_battery</a>: rmf battery estimation</li>
<li><a href="https://github.com/open-rmf/rmf_ros2">rmf_ros2</a>: ros2 adapters and nodes and python bindings for rmf_core</li>
<li><a href="https://github.com/open-rmf/rmf_utils">rmf_utils</a>: utility for rmf</li>
</ul>
<h2 id="traffic-deconfliction"><a class="header" href="#traffic-deconfliction">Traffic deconfliction</a></h2>
<p>Avoiding mobile robot traffic conflicts is a key functionality of <code>rmf_core</code>.
There are two levels to traffic deconfliction: (1) prevention, and (2)
resolution.</p>
<h3 id="prevention"><a class="header" href="#prevention">Prevention</a></h3>
<p>Preventing traffic conflicts whenever possible is the best-case scenario.
To facilitate traffic conflict prevention, we have implemented a
platform-agnostic Traffic Schedule Database. The traffic schedule is a living
database whose contents will change over time to reflect delays, cancellations,
or route changes. All fleet managers that are integrated into an RMF deployment must
report the expected itineraries of their vehicles to the traffic schedule. With
the information available on the schedule, compliant fleet managers can plan
routes for their vehicles that avoid conflicts with any other vehicles, no
matter which fleet they belong to. <code>rmf_traffic</code> provides a
<a href="https://github.com/open-rmf/rmf_traffic/blob/main/rmf_traffic/include/rmf_traffic/agv/Planner.hpp"><code>Planner</code></a>
class to help facilitate this for vehicles that behave like standard AGVs (Automated Guided Vehicles),
rigidly following routes along a pre-determined grid. In the future
we intend to provide a similar utility for AMRs (Autonomous Mobile Robots) that can perform ad hoc motion
planning around unanticipated obstacles.</p>
<h3 id="negotiation"><a class="header" href="#negotiation">Negotiation</a></h3>
<p>It is not always possible to perfectly prevent traffic conflicts.
Mobile robots may experience delays because of unanticipated obstacles in their
environment, or the predicted schedule may be flawed for any number of reasons.
In cases where a conflict does arise, <code>rmf_traffic</code> has a Negotiation scheme.
When the Traffic Schedule Database detects an upcoming conflict between two or
more schedule participants, it will send a conflict notice out to the relevant
fleet managers, and a negotiation between the fleet managers will begin. Each
fleet manager will submit its preferred itineraries, and each will respond with
itineraries that can accommodate the others. A third-party judge (deployed by
the system integrator) will choose the set of proposals that is considered
preferable and notify the fleet managers about which itineraries they should
follow.</p>
<p>There may be situations where a sudden, urgent task needs to take place
(for example, a response to an emergency), and the current traffic schedule does not
accommodate it in a timely manner. In such a situation, a traffic participant
may intentionally post a traffic conflict onto the schedule and force a
negotiation to take place. The negotiation can be forced to choose an itinerary
arrangement that favors the emergency task by implementing the third-party
judge to always favor the high-priority participant.</p>
<h2 id="traffic-schedule"><a class="header" href="#traffic-schedule">Traffic Schedule</a></h2>
<p>The traffic schedule is a centralized database of all the intended robot traffic
trajectories in a facility. Note that it contains the intended trajectories; it is
looking into the future. The job of the schedule is to identify conflicts in
the intentions of the different robot fleets and notify the fleets when a
conflict is identified. Upon receiving the notification, the fleets will begin
a traffic negotiation, as described above.</p>
<p><img src="images/rmf_core/schedule_and_fleet_adapters.png" alt="Schedule and Fleet Adapters" /></p>
<h2 id="fleet-adapters"><a class="header" href="#fleet-adapters">Fleet Adapters</a></h2>
<p>Each robot fleet that participates in an RMF deployment is expected to have a
fleet adapter that connects its fleet-specific API to the interfaces
of the core RMF traffic scheduling and negotiation system. The fleet adapter is
also responsible for handling communication between the fleet and the various
standardized smart infrastructure interfaces, e.g. to open doors, summon lifts,
and wake up dispensers.</p>
<p>Different robot fleets have different features and capabilities, dependent on
how they were designed and developed. The traffic scheduling and negotiation system
does not postulate assumptions about what the capabilities of the fleets will be.
However, to minimize the duplication of integration effort, we have identified 4
different broad categories of control that we expect to encounter among various
real-world fleet managers.</p>
<ul>
<li>
<p><strong>Full Control</strong> <em>(API available)</em> - RMF is provided with live status updates and full control over the paths that each individual mobile robot uses when navigating through the environment. This control level provides the highest overall efficiency and compliance with RMF, which allows RMF to minimize stoppages and deal with unexpected scenarios gracefully.</p>
</li>
<li>
<p><strong>Traffic Light</strong> <em>(API available)</em> - RMF is given the status as well as pause/resume control over each mobile robot, which is useful for deconflicting traffic schedules especially when sharing resources like corridors, lifts and doors.</p>
</li>
<li>
<p><strong>Read Only</strong> <em>(Preliminary API available)</em> - RMF is not given any control over the mobile robots but is provided with regular status updates. This will allow other mobile robot fleets with higher control levels to avoid conflicts with this fleet. <em>Note that any shared space is allowed to have a maximum of just one &quot;Read Only&quot; fleet in operation. Having none is ideal.</em></p>
</li>
<li>
<p><strong>No Interface</strong> <em>(Not compatible)</em> - Without any interface to the fleet, other fleets cannot coordinate with it through RMF, and will likely result in deadlocks when sharing the same navigable environment or resource. This level will not function with an RMF-enabled environment.</p>
</li>
</ul>
<p>In short, the more collaborative a fleet is with RMF, the more harmoniously all of the fleets and systems are able to operate together.
Note again that there can only ever be one &quot;Read Only&quot; fleet in a shared space, as any two or more of such fleets will make avoiding deadlock or resource conflict nearly impossible.</p>
<p>Currently we provide a reusable C++ API (as well as Python bindings) for integrating the <strong>Full Control</strong> category of fleet management.
A preliminary ROS 2 message API is available for the <strong>Read Only</strong> category, but that API will be deprecated in favor of a C++ API 
(with <a href="https://github.com/open-rmf/rmf_ros2/tree/main/rmf_fleet_adapter_python/">Python bindings</a> available) in a future release.
The <strong>Traffic Light</strong> control category is compatible with the core RMF scheduling system, but we have not yet implemented a reusable API for it.
To implement a <strong>Traffic Light</strong> fleet adapter, a system integrator would have to use the core traffic schedule and negotiation APIs directly, as well as implement the integration with the various infrastructure APIs (e.g. doors, lifts, and dispensers).</p>
<p>The API for the <strong>Full Control</strong> category is described in the <a href="./integration_fleets.html">Mobile Robot Fleets</a> section of the Integration chapter, and the <strong>Read Only</strong> category is described in the <a href="./integration_read-only.html">Read Only Fleets</a> section of the Integration chapter.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/rmf-core.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h1>
<h3 id="why-is-this-traffic-management-system-so-complicated"><a class="header" href="#why-is-this-traffic-management-system-so-complicated">Why is this traffic management system so complicated?</a></h3>
<p>RMF has a number of system design constraints that create unique challenges for
traffic management. The core goal of RMF is to facilitate system integration
for heterogeneous mobile robot fleets that may be provided by different vendors
and may have different technical capabilities.</p>
<p>Vendors tend to want to keep their computing systems independent from other
vendors. Since vendors are often responsible for ensuring uptime and
reliability on their computing infrastructure, they may view it as an
unacceptable liability to share computing resources with another vendor. This
means that the traffic management system must be able to function while being
distributed across different machines on a network.</p>
<p>Different robot platforms may have different capabilities. Many valuable AGV
platforms that are currently deployed are not able to change their itineraries
dynamically. Some AGV platforms can change course when instructed to, as long
as they stick to a predefined navigation graph. Some AMR platforms can
dynamically navigate themselves around unanticipated obstacles in their
environment. Since RMF is meant to be an enabling technology, it is important
that we design a system that can maximize the utility of all these different
types of systems without placing detrimental constraints on any of them.</p>
<p>These considerations led to the current design of distributed conflict
prevention and distributed schedule negotiation. There is plenty of space
within the design to create simpler and more efficient subsets for categories
of mobile robots that fit certain sets of requirements, but these optimizations
can be added later, building on top of the existing completely generalized
framework.</p>
<h3 id="who-opens-and-closes-doors-and-operates-the-lifts-the-robot-or-rmf-or-both"><a class="header" href="#who-opens-and-closes-doors-and-operates-the-lifts-the-robot-or-rmf-or-both">Who opens and closes doors and operates the lifts? The robot or RMF? Or both?</a></h3>
<p>The responsibility of knowing when a door needs to be opened and then sending
the command to open it belongs to the &quot;fleet adapter&quot;. The basic design is:</p>
<ul>
<li>The fleet adapter keeps track of the robot's progress</li>
<li>When the robot needs to go through a door, the fleet adapter will recognize this</li>
<li>The fleet adapter will send a signal to the door to open</li>
<li>Once the door is open, the fleet adapter will command the robot to proceed</li>
<li>Once the robot is through the door, the fleet adapter will command the robot wait until the door is closed</li>
<li>The fleet adapter will command the door to close</li>
<li>Once the door is closed, the fleet adapter will command the robot to proceed</li>
</ul>
<p>The way a fleet adapter knows about the doors is by parsing the navigation
graph that is provided to it. The navigation graph is a required parameter for
the <code>full_control</code> type of fleet adapter. <code>rmf_demos</code> shows an example of
providing a navigation graph to the fleet adapter.</p>
<p>The recommended way to construct a navigation graph is to use the
<code>traffic-editor</code> tool. The <code>rmf_demos</code> repos shows some examples of
<code>traffic-editor</code> project files.</p>
<p>However, it's entirely possible to construct your own navigation graphs. They
use YAML format.</p>
<h3 id="are-lifts-supported"><a class="header" href="#are-lifts-supported">Are lifts supported?</a></h3>
<p>Proper lift support (meaning, specifying an actual lift that can move between
floors, and exporting that information into the navigation graph) is not
something that has been developed yet.</p>
<p>However, for testing and demonstration purposes, there are two special
navigation graph edge properties that can allow a RMF fleet adapter to emulate
lift usage. This is meant for demo scenarios where a &quot;mock lift&quot; has been
created that receives lift commands and transmits lift states but does not
actually move between any different floors in a building. For example, tape
on the floor of a lab to indicate the &quot;lift cabin&quot; box, to allow development
and testing without occupying the actual building lift.</p>
<p>These properties were initially included for demonstration purposes, but they
are proving useful enough that we might make them officially supported
properties. Due to the cost and scarcity of &quot;real&quot; lifts, there seems to be
broad interest in having single-floor hardware test setups that emulate
multi-floor scenarios.</p>
<p>The edge properties are:</p>
<ul>
<li><code>demo_mock_floor_name</code>: The name of the floor that the robot is on while traversing the edge</li>
<li><code>demo_mock_lift_name</code>: The name of the lift that is being entered or exited while the robot traverses the edge</li>
</ul>
<p>The idea is that if you have a single floor demonstration environment but want
to demonstrate interaction with a lift, then you can set up a mock &quot;lift&quot; and
imagine that each side of the &quot;lift&quot; opens to a different floor, and the robot
is only allowed to enter/exit that side of the &quot;lift&quot; when the &quot;lift&quot; believes
it is on that floor. This emulates lift cabins with two sets of doors.</p>
<p>To make this idea more concrete, imagine you have a single-floor hardware
testing area, and a box is drawn on the ground with an LED display next to it
that reads off pretend floor names. The mock lift will transmit lift state
messages that match up with whatever floor the LED is displaying. There is also
some indication of whether the lift doors are open or closed. You can further
imagine that entering or exiting from west side of the &quot;lift&quot; is only allowed
when the lift believes it is on floor L1 whereas entering or exiting the &quot;lift&quot;
from the east side is only allowed when it believes it is on floor L3.</p>
<p>In that setup, for a robot to &quot;correctly&quot; navigate from a waypoint on L1 to a
waypoint on L3, the robot needs to:</p>
<ul>
<li>Approach the &quot;lift&quot; from the west side</li>
<li>Call the &quot;lift&quot; down to L1</li>
<li>Wait until the lift state has it on floor L1 with the doors open</li>
<li>Move into the &quot;lift&quot; (i.e. the box drawn on the ground) and request that it &quot;moves&quot; to L3</li>
<li>Wait until the &quot;lift&quot; indicates that it has reached L3 and that its doors are open</li>
<li>Exit the &quot;lift&quot; on the east side</li>
</ul>
<p>A rough ASCII diagram would look like this (numbers are waypoints and letters
are edges):</p>
<pre><code>1 &lt;---a---&gt; 2 &lt;---b---&gt; 3
</code></pre>
<ul>
<li>Waypoint 1 is on floor L1</li>
<li>Waypoint 2 is inside the &quot;lift&quot; named LIFT001</li>
<li>Waypoint 3 is on floor L3</li>
<li>The properties of edge <code>a </code>are:
<ul>
<li>bidirectional: true</li>
<li>demo_mock_floor_name: L1</li>
<li>demo_mock_lift_name: LIFT001</li>
</ul>
</li>
<li>The properties of edge <code>b</code> are:
<ul>
<li>bidirectional: true</li>
<li>demo_mock_floor_name: L3</li>
<li>demo_mock_lift_name: LIFT001</li>
</ul>
</li>
</ul>
<h3 id="if-multiple-fleets-can-do-the-same-task-which-one-is-one-chosen"><a class="header" href="#if-multiple-fleets-can-do-the-same-task-which-one-is-one-chosen">If multiple fleets can do the same task, which one is one chosen?</a></h3>
<p>Though not implemented yet, there is a design worked out for a bidding system
where a task request will be converted to a bid request. The bid request will
be sent to each fleet adapter, and each fleet adapter that can perform the task
will report its best estimate for how soon it would be able to have the task
finished. The fleet adapter that offers the lowest bid will be assigned the
task.</p>
<p>The API and implementation are awaiting finalization of some critical components.</p>
<h3 id="can-some-robots-have-priority-over-other-robots"><a class="header" href="#can-some-robots-have-priority-over-other-robots">Can some robots have priority over other robots?</a></h3>
<p>The negotiation system concept does support prioritization for which robot will
accommodate the other robot(s). Any arbitrary metric or weighting system can be
used when resolving a negotiation. But in the current implementation that we
are using, we treat all vehicles as equal and choose the resolution
that minimizes the net delay across all the robots, without any prioritization
or weighting.</p>
<p>Since this codebase is open source, you can easily fork the code and modify it
to use any prioritization system that you'd like. Specifically, replace
<code>rmf_traffic::schedule::QuickestFinishEvaluator()</code> with your own
<code>Negotiation::Evaluator</code> class that behaves in whatever way you would like.</p>
<h3 id="what-distance-is-maintained-between-two-robots"><a class="header" href="#what-distance-is-maintained-between-two-robots">What distance is maintained between two robots?</a></h3>
<p>This is configurable. There are two relevant parameters: <code>footprint_radius</code> and
<code>vicinity_radius</code>. The <code>footprint_radius</code> represents an estimate of the
vehicle's physical footprint. The <code>vicinity_radius</code> represents an estimate of
the region which the robot needs other vehicles to stay clear of. A &quot;schedule
conflict&quot; is defined as an instance where one vehicle's &quot;footprint&quot; is
scheduled to enter another vehicle's &quot;vicinity&quot;. The job of the negotiation
system is to come up with a fix to the schedule that keeps all vehicles'
&quot;footprints&quot; out of all other vehicles' &quot;vicinities&quot;.</p>
<h3 id="how-is-job-dispatching-accomplished"><a class="header" href="#how-is-job-dispatching-accomplished">How is job dispatching accomplished?</a></h3>
<p>The Dispatch Planner module is currently a work-in-progress.
So far, the demo platforms that have been developed for RMF did not require a planner to dispatch tasks to different fleets, because in all demo platforms done thus far (late 2020), each task type could only be performed by one (and only one) robot fleet.
So the task dispatching has been trivial: the task gets assigned to whatever fleet is capable of performing the task, while the rest of the fleets just ignore the task request.
We are currently working on a true dispatch planner and formal task bidding system which we're aiming to include in release 1.2.0, slated for end of December 2020.
The idea is that every fleet that can perform a task request will offer a bid for how much it would &quot;cost&quot; them to perform a task, and the bid with the lowest &quot;cost&quot; will be the winner.
The &quot;cost&quot; will be determined by two factors:</p>
<ul>
<li>How quickly the task is finished</li>
<li>How much other tasks get delayed if the new task needs to preempt them</li>
</ul>
<h3 id="what-is-rmf_traffic-"><a class="header" href="#what-is-rmf_traffic-">What is <code>rmf_traffic</code> ?</a></h3>
<p><code>rmf_traffic</code> provides a middleware-neutral implementation of the core traffic scheduling algorithms and utilities. It does not use or depend on ROS 2.</p>
<h3 id="what-is-rmf_traffic_ros2-"><a class="header" href="#what-is-rmf_traffic_ros2-">What is <code>rmf_traffic_ros2</code> ?</a></h3>
<p><code>rmf_traffic_ros2</code> provides convenient wrappers for using the <code>rmf_traffic</code> as part of a distributed ROS 2 system.</p>
<h3 id="where-is-the-costmap"><a class="header" href="#where-is-the-costmap">Where is the costmap?</a></h3>
<p>There is no costmap representation in <code>rmf_core</code>.
Costmaps are one method that is typically used for representing volume occupancy for autonomous navigation planning.
While it's true that the traffic utilities deal with navigation planning, they are principally concerned about identifying conflicts between the intended routes of autonomous vehicles.
The traffic utilities are not responsible for the &quot;local&quot; navigation of vehicles around static obstacles in their environment.</p>
<p>Different robot platforms often have different representations of costmaps or other navigation algorithms, many of which may be proprietary.
On top of that, different robot platforms with the same costmap representations may still require different costmap values because of differences in robot footprints.
Because of these factors, we leave it to the robot platforms themselves to determine how they represent their costmaps. If it's important for a system integrator to take a robot's costmap into account when performing traffic planning, they can implement a custom <code>rmf_traffic::agv::RouteValidator</code> that uses the robot's custom costmap when determining whether a candidate route is valid.</p>
<h3 id="what-is-the-core-algorithm-behind-rmf_traffic-"><a class="header" href="#what-is-the-core-algorithm-behind-rmf_traffic-">What is the core algorithm behind <code>rmf_traffic</code> ?</a></h3>
<p>Conflict avoidance for AGV's in <code>rmf_traffic</code> is implemented with time-dependent extension to <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A* search</a>
This search takes time into account so that it can find paths through space and time that account for the motions of other agents that are in the traffic schedule.</p>
<h3 id="during-negotiation-how-do-fleets-compute-their-proposals"><a class="header" href="#during-negotiation-how-do-fleets-compute-their-proposals">During negotiation, how do fleets compute their proposals?</a></h3>
<p>Because the system is designed to be extensible and adaptable to a wide variety of scenarios and robot vendor combinations, including many that do not currently exist, it has many pieces and hooks for expansion. The sequence of computing a traffic proposal is as follows:</p>
<ul>
<li>First, the fleet adapter node will receive a conflict notification which tells it that it needs to participate in a negotiation to resolve a space-time conflict. This notification is received by the <code>rmf_traffic_ros2::schedule::Negotiation</code> class.</li>
<li>For this to happen, the fleet adapter creates a negotiation-notification subscription, so that it will be told whenever a particular robot under its control needs to respond to a negotiation notification.</li>
<li>When a robot needs to repond to a negotiation, its implementation gets triggered.</li>
<li>This implementation will launch a multi-threaded <code>Negotiate</code> service, whose main implementation can be found <a href="https://github.com/osrf/rmf_core/blob/master/rmf_fleet_adapter/src/rmf_fleet_adapter/services/detail/impl_Negotiate.hpp">here</a></li>
</ul>
<p>Every step in the multi-party negotiation is using the <code>Negotiate</code> service the exact same way.
The only difference between the various steps is what constraints they need to deal with.
Those constraints are described by the <code>rmf_traffic::schedule::Negotiation::Table::Viewer</code> object that gets passed to the <code>respond(~)</code> function.
Because the same object can be used to describe the constraints of all the different blocks in the diagram, we can use the same code to solve every block.</p>
<p>There are also <code>reject</code> and <code>forfeit</code> code paths that may be invoked as necessary:</p>
<ul>
<li>The &quot;rejection&quot; mechanism is used when it's impossible for one of the fleets to accommodate a proposal that came from another.
When a rejection is performed, the rejecting fleet will provide a set of feasible trajectories (usually anywhere from 10-200 trajectories) and the fleet that receives the rejection should try once again to find an ideal proposal for itself, but that ideal proposal must accommodate at least one of the trajectory alternatives that were provided with the rejection.</li>
<li>The &quot;forfeit&quot; mechanism is used when the planner is having an inordinately difficult time finding any kind of solution.
This can happen when the negotiation has numerous participants that are all actively on the move, which can lead to situations that are seemingly impossible to resolve due to inconsistencies across time.
Typically, when a forfeit is used, there will be another feasible combination of accommodations that gets found by the negotiation.
In the worst case scenario, if negotiations keep failing, the robots may experience a real-life deadlock.
When a deadlock happens, the participants will be sitting still so the negotiation will reach a steady state and will not be negatively affected by async inconsistencies.
When that happens, a successful resolution is practically assured.</li>
</ul>
<p>The preceeding explanation describes the &quot;Full Control&quot; style of fleet adapter. The implementation for the &quot;Read Only&quot; and &quot;Traffic Light&quot; APIs are a bit different.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/rmf-core_faq.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="tasks-in-rmf"><a class="header" href="#tasks-in-rmf">Tasks in RMF</a></h1>
<p>RMF simplifies task allocation and management across multi-fleet systems.
When a user submits a new task request, RMF will intelligently assign it to the robot in the fleet that can best perform the task. When </p>
<p>RMF supports three types of task requests out of the box:</p>
<ul>
<li>Clean: For robots capable of cleaning floor spaces in facilities</li>
<li>Delivery: For robots capable of delivering items between locations in facilities</li>
<li>Loop: For robots capable to navigating back and forth between locations in facilities</li>
</ul>
<blockquote>
<p>Note: A single robot may be capable of performing one of more of the above tasks and fleet adapters can be configured to reflect the capability of its robots.
For more information on the supported task types, <a href="./task_types.html">click here</a></p>
</blockquote>
<p>In RMF version 21.04 and above, tasks are awarded to robot fleets based on the outcome of a bidding process that is orchestrated by a Dispatcher node, <code>rmf_dispatcher_node</code>.
When the Dispatcher receives a new task request from a dashboard or terminal, it sends out a <code>rmf_task_msgs/BidNotice</code> message to all the fleet adapters. If a fleet adapter is able to process that request, it submits a <code>rmf_task_msgs/BidProposal</code> message back to the Dispatcher with a cost to accommodate the task. An instance of <code>rmf_task::agv::TaskPlanner</code> is used by the fleet adapters to determine how best to accommodate the new request. For more information on the task planner, <a href="./task_planner.html">click here</a></p>
<p>The Dispatcher then compares all the <code>BidProposals</code> received and submits a <code>rmf_task_msgs/DispatchRequest</code> message with the fleet name of the robot that the bid is awarded to. There are a couple different ways the Dispatcher evaluates the proposals such as fastest to finish, lowest cost, etc which can be configured.</p>
<p>Battery recharging is tightly integrated with the new task planner. <code>ChargeBattery</code> tasks are optimally injected into a robot's schedule when the robot has insufficient charge to fulfill a series of tasks. Currently we assume each robot in the map has a dedicated charging location as annotated with the <code>is_charger</code> option in the traffic editor map.</p>
<p><img src="images/rmf_core/rmf_bidding.png" alt="RMF Bidding Diagram" /></p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/task.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="rmf-task-allocation-planner"><a class="header" href="#rmf-task-allocation-planner">RMF Task Allocation Planner</a></h1>
<p>Coming soon...</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/task_planner.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="supported-tasks-in-rmf"><a class="header" href="#supported-tasks-in-rmf">Supported Tasks in RMF</a></h1>
<h2 id="clean-task"><a class="header" href="#clean-task">Clean Task:</a></h2>
<p><img src="images/cleaning_robots.png" alt="" /></p>
<p>Cleaning robots are becoming increasingly popular in various facilities. While there are many ways of cleaning (vacuuming, mopping, disinfecting, etc) and hence many varieties of cleaning robots, the workflow remains identical across them all. Floor space in facilities is divided into a number of “zones” or sub-regions for cleaning. Each zone has a start and finish location for the robot. In-between these locations, the robot traverses along a special path while performing the cleaning operation.</p>
<p>RMF fully supports the integration of various cleaning robots. Further, RMF can intelligently assign cleaning jobs to available cleaning robots based on capability and available resources, while optimizing overall productivity. Most cleaning robots have a pre-configured cleaning routine for each zone that can be run from a given starting point. RMF’s goal is to guide the robot to this starting point, trigger the execution of the cleaning routine and then guide the robot to a holding waypoint once the cleaning is complete. A <code>Clean</code> Task has been designed in RMF to orchestrate this behavior.</p>
<p>The rest of this section provides an overview of the steps necessary to integrate cleaning robots with RMF. The <code>airport_terminal</code> example in <code>rmf_demos</code> is a useful reference. It showcases the integration of two brands of cleaning robots: <code>CleanerBotA</code> and <code>CleanerBotE</code> which operate on navigation graphs <code>Graph 0</code> and <code>Graph 4</code> respectively.</p>
<h4 id="step-1-defining-waypoints-for-cleaning-in-traffic-editor"><a class="header" href="#step-1-defining-waypoints-for-cleaning-in-traffic-editor">Step 1: Defining waypoints for cleaning in Traffic Editor</a></h4>
<p>Two waypoints need to be added to the navigation graph of the robot. The first is the waypoint where the robot should initiate its cleaning routine. In the image below, this point is labelled as <code>zone_1_start</code>. Once the robot finishes its cleaning routine, RMF will guide the robot back to this waypoint. Connected to this waypoint, is waypoint <code>zone_1</code> that has the <code>dock_name</code> property set to its name. This is the waypoint where the robot ends up after its cleaning routine is completed. In the current implementation, it is important to have the names of these waypoints as <code>&lt;zone_name&gt;_start</code> and <code>&lt;zone_name&gt;</code> respectively. When a robot enters the lane from <code>zone_1_start</code> to <code>zone_1</code>, the fleet adapter will request the robot to initiate its docking (in this case cleaning) routine. Setting the <code>dock_name</code> parameter to <code>zone_1</code> will result in the fleet adapter triggering the <code>RobotCommandHandle::dock()</code> function. Thus, the user’s implementation of this function should in-turn make an API call to the robot to begin cleaning the specified zone. Once the cleaning process is completed, the <code>RobotCommandHandle</code> should trigger the <code>docking_finished_callback()</code>.</p>
<p><img src="images/clean_traffic_editor.png" alt="" /></p>
<blockquote>
<p>Note: In order to trigger the <code>DockPhase</code>, the direction of the lane is required to be from <code>&lt;zone_name&gt;_start</code> to <code>&lt;zone_name&gt;</code>.</p>
</blockquote>
<h4 id="step-2-publish-docksummary-message"><a class="header" href="#step-2-publish-docksummary-message">Step 2: Publish DockSummary message</a></h4>
<p>To estimate the resource drain from the cleaning process which is essential for optimal task allocation planning, the fleet adapters require the list of waypoints that the robot will traverse while cleaning.
This information can be summarized in a <a href="https://github.com/open-rmf/rmf_internal_msgs/blob/main/rmf_fleet_msgs/msg/DockSummary.msg">DockSummary</a> message published to <code>/dock_summary</code> topic.
The <a href="https://github.com/open-rmf/rmf_demos/blob/283af6d418f5c8d315cc4ca97c95885a12b15f94/rmf_demos/launch/airport_terminal.launch.xml#L97-L102">mock_docker</a> node is responsible for publishing this information. 
It accepts a <code>yaml</code> configuration file containing the lists of waypoints for each zone for each fleet which is used to populate the <code>DockSummary</code> message.
For the <code>airport_terminal</code> demo the file is located <a href="https://github.com/open-rmf/rmf_demos/blob/main/rmf_demos_tasks/rmf_demos_tasks/airport_docker_config.yaml">here</a></p>
<h4 id="step-3-configure-fleet-adapter-to-accept-clean-tasks"><a class="header" href="#step-3-configure-fleet-adapter-to-accept-clean-tasks">Step 3: Configure fleet adapter to accept clean tasks</a></h4>
<p>The fleet adapter needs to be configured to accept <code>Clean</code> type of task. Else, it will not submit a bid for this task to the dispatcher node during task bidding.
If the legacy <code>full_control</code> adapter is being used, the <a href="https://github.com/open-rmf/rmf_demos/blob/283af6d418f5c8d315cc4ca97c95885a12b15f94/rmf_demos/launch/include/adapters/cleanerBotA_adapter.launch.xml#L52">perform_cleaning</a> parameter needs to be set to <code>true</code> in the adapter launch file.
For newer fleet adapters, the <a href="https://github.com/open-rmf/rmf_ros2/blob/2fe08e328f543fe6a4e0853a60607b5b52015f2a/rmf_fleet_adapter/include/rmf_fleet_adapter/agv/FleetUpdateHandle.hpp#L134">FleetUpdateHandle::accept_task_requests()</a> method should be called with an <a href="https://github.com/open-rmf/rmf_ros2/blob/2fe08e328f543fe6a4e0853a60607b5b52015f2a/rmf_fleet_adapter/include/rmf_fleet_adapter/agv/FleetUpdateHandle.hpp#L123-L124">AcceptTaskRequest</a> callback that returns <code>true</code> if a request with TaskProfile.Description.TaskType.TYPE_CLEAN is received.</p>
<h4 id="step-4-send-a-clean-request"><a class="header" href="#step-4-send-a-clean-request">Step 4: Send a Clean request</a></h4>
<p>If the above steps are done correctly, a request to clean a zone can be submitted to RMF via the terminal or RMF_Demo_Panel.
To send a clean request from the terminal, source the workspace with RMF and then:</p>
<pre><code>ros2 run rmf_demos_tasks dispatch_clean -cs zone_1 -st 0 --use_sim_time
</code></pre>
<p>This will submit a request to RMF to clean <code>zone_1</code>. The <code>--use_sim_time</code> argument is only required when testing in simulation. For more information on sending a clean request:</p>
<pre><code>ros2 run rmf_demos_tasks dispatch_clean -h
</code></pre>
<h2 id="delivery-task"><a class="header" href="#delivery-task">Delivery Task:</a></h2>
<p>Another common application for mobile robots is performing deliveries within facilities.
A delivery typically involves the robot heading to a pickup location where it gets loaded with items and then navigating to a dropoff location where the items are unloaded.
At the pickup and dropoff sites, the mobile robot may have to interface with robotic arms, conveyors or other automation systems. We term systems that load items as <code>dispensers</code> and those that unload as <code>ingestors</code>. </p>
<p>To integrate these systems with RMF core systems, a set of <a href="https://github.com/open-rmf/rmf_internal_msgs/tree/main/rmf_dispenser_msgs/msg">dispenser</a> and <a href="https://github.com/open-rmf/rmf_internal_msgs/tree/main/rmf_ingestor_msgs/msg">ingestor</a> messages are defined.
Despite their names, these messages are sufficiently general enough to be used by any other system that perform similar actions.</p>
<p>A <code>Delivery</code> task is designed in RMF which guides the mobile robot to the pickup location where the dispenser is located. Once here, its <code>rmf_fleet_adapter</code> publishes a <code>DispenserRequest</code> message which the workcell receives and begins processing.
When the loading is successful, the dispenser publishes a <code>DispenserResult</code> message with <code>SUCCESS</code> status.
The <code>rmf_fleet_adapter</code> then guides the robot to the dropoff waypoint where the ingestor is located. 
Here, a similar exchange of messages ensures. The <code>rmf_fleet_adapter</code> publishes an <code>IngestorRequest</code> message which instructs the ingestor to unload its payload. Upon completion, it publishes an <code>IngestorResult</code> message with a <code>SUCCESS</code> status.</p>
<p>To learn how to setup a simulation with dispensers and ingestors, see <a href="./simulation.html">Simulation</a></p>
<p>The fleet adapter needs to be configured to accept <code>Delivery</code> type of task. Else, it will not submit a bid for this task to the dispatcher node during task bidding.
If the legacy <code>full_control</code> adapter is being used, the <a href="https://github.com/open-rmf/rmf_demos/blob/283af6d418f5c8d315cc4ca97c95885a12b15f94/rmf_demos/launch/include/adapters/deliveryRobot_adapter.launch.xml#L45">perform_deliveries</a> parameter needs to be set to <code>true</code> in the adapter launch file.
For newer fleet adapters, the <a href="https://github.com/open-rmf/rmf_ros2/blob/2fe08e328f543fe6a4e0853a60607b5b52015f2a/rmf_fleet_adapter/include/rmf_fleet_adapter/agv/FleetUpdateHandle.hpp#L134">FleetUpdateHandle::accept_task_requests()</a> method should be called with an <a href="https://github.com/open-rmf/rmf_ros2/blob/2fe08e328f543fe6a4e0853a60607b5b52015f2a/rmf_fleet_adapter/include/rmf_fleet_adapter/agv/FleetUpdateHandle.hpp#L123-L124">AcceptTaskRequest</a> callback that returns <code>true</code> if a request with TaskProfile.Description.TaskType.TYPE_DELIVERY is received.</p>
<p>To submit a <code>Delivery</code> request, the <code>dispatch_delivery</code> script in <code>rmf_demos_tasks</code> can be utilized.</p>
<pre><code>ros2 run rmf_demos_tasks dispatch_delivery -h
usage: dispatch_delivery [-h] -p PICKUP -pd PICKUP_DISPENSER -d DROPOFF -di DROPOFF_INGESTOR
                         [-st START_TIME] [-pt PRIORITY] [--use_sim_time]

optional arguments:
  -h, --help            show this help message and exit
  -p PICKUP, --pickup PICKUP
                        Start waypoint
  -pd PICKUP_DISPENSER, --pickup_dispenser PICKUP_DISPENSER
                        Pickup dispenser name
  -d DROPOFF, --dropoff DROPOFF
                        Finish waypoint
  -di DROPOFF_INGESTOR, --dropoff_ingestor DROPOFF_INGESTOR
                        Dropoff ingestor name
  -st START_TIME, --start_time START_TIME
                        Start time from now in secs, default: 0
  -pt PRIORITY, --priority PRIORITY
                        Priority value for this request
  --use_sim_time        Use sim time, default: false
</code></pre>
<h2 id="loop-task"><a class="header" href="#loop-task">Loop Task:</a></h2>
<p>A <code>Loop</code> task can be submitted to request a robot to navigate back and forth between two waypoints for a given number of iterations (loops).
As with <code>Clean</code> and <code>Delivery</code> tasks, the fleet adapter must be configured to accept <code>Loop</code> requests.</p>
<p>To submit a <code>Loop</code> request, the <code>dispatch_loop</code> script in <code>rmf_demos_tasks</code> can be utilized.</p>
<pre><code>ros2 run rmf_demos_tasks dispatch_loop -h
usage: dispatch_loop [-h] -s START -f FINISH [-n LOOP_NUM] [-st START_TIME] [-pt PRIORITY]
                     [--use_sim_time]

optional arguments:
  -h, --help            show this help message and exit
  -s START, --start START
                        Start waypoint
  -f FINISH, --finish FINISH
                        Finish waypoint
  -n LOOP_NUM, --loop_num LOOP_NUM
                        Number of loops to perform
  -st START_TIME, --start_time START_TIME
                        Start time from now in secs, default: 0
  -pt PRIORITY, --priority PRIORITY
                        Priority value for this request
  --use_sim_time        Use sim time, default: false
</code></pre>
<h2 id="chargingtask"><a class="header" href="#chargingtask">ChargingTask</a></h2>
<p>This is an self-generated task, self generated by RMF fleet adapter. The robot will get directed back to the charging station when charging condition is met.
User can set a valid charging station by setting <code>is_parking_spot</code> to <code>true</code> in <code>traffic_editor</code>.</p>
<p>User can configure the charging condition in the <code>fleet_adapter.launch.xml</code> by:</p>
<ul>
<li>Recharge Threshold: <code>&lt;arg name=&quot;recharge_threshold&quot; value=&quot;0.2&quot;/&gt;</code></li>
<li>Finishing Request: <code>&lt;arg name=&quot;finishing_request&quot; value=&quot;charge&quot;/&gt;</code></li>
</ul>
<p>Note that currently <code>finishing_request</code> arg also supports: <code>[charge, park, nothing]</code>. These are considered as autogenerated tasks.</p>
<h2 id="debugging"><a class="header" href="#debugging">Debugging</a></h2>
<p>There are a few scenarios where the dispatcher will not receive any bids from a fleet adapter when a task request is submitted:</p>
<ol>
<li>
<p>The fleet adapter is not configured to accept the submitted task type as determined by <a href="https://github.com/open-rmf/rmf_ros2/blob/2fe08e328f543fe6a4e0853a60607b5b52015f2a/rmf_fleet_adapter/include/rmf_fleet_adapter/agv/FleetUpdateHandle.hpp#L134">this</a> function. If you're using the <code>full_control</code> implementation, you should indicate which task types are doable using these <a href="https://github.com/open-rmf/rmf_demos/blob/283af6d418f5c8d315cc4ca97c95885a12b15f94/rmf_demos/launch/include/adapters/tinyRobot_adapter.launch.xml#L44-L49">parameters</a> in your launch file. Else, the fleet adapter will simply not bid for the submitted task. A message should be published in the terminal indicating this: <code>[full_control-15] [INFO] [1617245135.071996222] [tinyRobot_fleet_adapter]: Fleet [tinyRobot] is configured to not accept task [Clean0]</code>. If you're using a custom fleet adapter, make sure you're calling <code>FleetUpdateHandle::accept_task_requests()</code>.</p>
</li>
<li>
<p>The fleet adapter is unable to process the request due to invalid fields in the request. If for example a <code>loop</code> request is submitted with start or finish waypoints that do not exist on the robot's nav graph, a bid will not be submitted. An explanatory message will be printed in the terminal such as <code>[full_control-15] [INFO] [1617245206.473805336] [tinyRobot_fleet_adapter]: Fleet [tinyRobot] does not have a named waypoint [bad_waypoint] configured in its nav graph. Rejecting BidNotice with task_id:[Loop1]</code></p>
</li>
<li>
<p>The duration for which the dispatcher accepts bids is smaller than the time taken by the fleet adapters to compute and submit a bid. The duration parameter is specified <a href="https://github.com/open-rmf/rmf_demos/blob/283af6d418f5c8d315cc4ca97c95885a12b15f94/rmf_demos/launch/common.launch.xml#L53">here</a>. If this is the case, you should still see some printouts in the terminal highlighting that a bid was computed and submitted by the fleet adapter:
<code>[full_control-15] [INFO] [1617245621.881365568] [tinyRobot_fleet_adapter]: Generated Loop request for task_id:[Loop2] [full_control-15] [INFO] [1617245621.881432804] [tinyRobot_fleet_adapter]: Planning for [2] robot(s) and [1] request(s) [full_control-15] [INFO] [1617245621.886230967] [tinyRobot_fleet_adapter]: Submitted BidProposal to accommodate task [Loop2] by robot [tinyRobot2] with new cost [45.222308]</code></p>
</li>
</ol>
<p><a href="./task_new.html">Click here</a> to learn how to develop support for a custom task.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/task_types.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="supporting-a-new-task-in-rmf"><a class="header" href="#supporting-a-new-task-in-rmf">Supporting a new Task in RMF</a></h1>
<p>With the release of <a href="https://github.com/open-rmf/rmf_task/pull/39">RMF Task V2</a>, users can now construct custom tasks according to their specific needs. Different combination or sequence of robotic tasks can be dispatched to a specified robot or to the best available fleet based on the users' preferences.</p>
<p>The new flexible task system introduces the concept of a Phase. A task is an object that generates phases. In other words, a task is typically made up of a series or combination of phases as its building blocks. For example, a delivery task would require a robot to complete the following steps:</p>
<ol>
<li>Move from its current waypoint to a pick-up location</li>
<li>Pick up the delivery payload</li>
<li>Move from the pick up location to the drop-off location</li>
<li>Drop off the payload</li>
<li>Move back to the initial starting waypoint</li>
</ol>
<p>Each of these steps can be considered a Phase. Users can use the following public API phases to construct their own tasks:</p>
<ul>
<li><a href="https://github.com/open-rmf/rmf_ros2/blob/main/rmf_fleet_adapter/schemas/event_description__go_to_place.json"><code>GoToPlace</code></a></li>
<li><a href="https://github.com/open-rmf/rmf_ros2/blob/main/rmf_fleet_adapter/schemas/event_description__pickup.json"><code>PickUp</code></a></li>
<li><a href="https://github.com/open-rmf/rmf_ros2/blob/main/rmf_fleet_adapter/schemas/event_description__dropoff.json"><code>DropOff</code></a></li>
<li><a href="https://github.com/open-rmf/rmf_ros2/blob/main/rmf_fleet_adapter/schemas/event_description__perform_action.json"><code>PerformAction</code></a></li>
</ul>
<p>Additional phase descriptions, including those supporting the public API phases, are defined and listed <a href="https://github.com/open-rmf/rmf_ros2/tree/main/rmf_fleet_adapter/schemas">here</a>. They will be useful for building your own custom task.</p>
<p>Certain tasks may require specific phases that are not mentioned above. For example, if a delivery task involves the robot moving from the first to second level, it would require a <code>RequestLift</code> phase. Such phases are used by RMF internally and automatically added to a task when necessary, so users do not need to worry about them when creating their custom tasks.</p>
<h2 id="building-a-custom-task"><a class="header" href="#building-a-custom-task">Building a Custom Task</a></h2>
<p>Users can build and send their own tasks by publishing <a href="https://github.com/open-rmf/rmf_internal_msgs/blob/main/rmf_task_msgs/msg/ApiRequest.msg"><code>ApiRequest</code></a> messages. You will need to fill in the <code>request_id</code> and <code>json_msg</code> fields according to the types of phases that make up the task, as well as whether the task is intended for a specific robot or the best available fleet. You may follow these steps to construct your own task:</p>
<ol>
<li>Create an <code>ApiRequest</code> publisher that sends task requests via the <code>/task_api_requests</code> topic.</li>
<li>Fill in the <code>request_id</code> field with a unique string ID that can be used to identify the task.</li>
<li>For the <code>json_msg</code> field,
<ul>
<li>Use the <a href="https://github.com/open-rmf/rmf_api_msgs/blob/main/rmf_api_msgs/schemas/robot_task_request.json"><code>robot_task_request</code></a> schema and fill in the JSON payload type with <code>&quot;robot_task_request&quot;</code> to send a task request to a specific robot</li>
<li>Use the <a href="https://github.com/open-rmf/rmf_api_msgs/blob/main/rmf_api_msgs/schemas/dispatch_task_request.json"><code>dispatch_task_request</code></a> schema and fill in the JSON payload type with <code>&quot;dispatch_task_request&quot;</code> to send a task request to the best available fleet</li>
<li>The <code>request</code> fields for these objects follow the <a href="https://github.com/open-rmf/rmf_api_msgs/blob/main/rmf_api_msgs/schemas/task_request.json"><code>task_request</code></a> schema</li>
</ul>
</li>
<li>Populate the object fields with the required information.
<ul>
<li>The <code>category</code> and <code>description</code> fields under the <code>task_request</code> schema take in the string name of the task and the task description respectively. The JSON schema for these descriptions can be found <a href="https://github.com/open-rmf/rmf_ros2/tree/main/rmf_fleet_adapter/schemas">here</a>. There are currently four task descriptions available:
<ul>
<li><a href="https://github.com/open-rmf/rmf_ros2/blob/main/rmf_fleet_adapter/schemas/task_description__clean.json"><strong>Clean</strong></a>: create your own clean task, requires the <a href="https://github.com/open-rmf/rmf_ros2/blob/main/rmf_fleet_adapter/schemas/event_description__clean.json"><code>Clean</code></a> phase description</li>
<li><a href="https://github.com/open-rmf/rmf_ros2/blob/main/rmf_fleet_adapter/schemas/task_description__compose.json"><strong>Compose</strong></a>: create your own custom task that may comprise of a sequence of phases, requires descriptions for the relevant phases</li>
<li><a href="https://github.com/open-rmf/rmf_ros2/blob/main/rmf_fleet_adapter/schemas/task_description__delivery.json"><strong>Delivery</strong></a>: create your own delivery task, requires the <a href="https://github.com/open-rmf/rmf_ros2/blob/main/rmf_fleet_adapter/schemas/event_description__pickup.json"><code>PickUp</code></a> and <a href="https://github.com/open-rmf/rmf_ros2/blob/main/rmf_fleet_adapter/schemas/event_description__dropoff.json"><code>DropOff</code></a> phase descriptions</li>
<li><a href="https://github.com/open-rmf/rmf_ros2/blob/main/rmf_fleet_adapter/schemas/task_description__patrol.json"><strong>Patrol</strong></a>: create your own patrol task, requires the <a href="https://github.com/open-rmf/rmf_ros2/blob/main/rmf_fleet_adapter/schemas/place.json"><code>Place</code></a> description to indicate where you would like your robot to go to</li>
</ul>
</li>
</ul>
</li>
<li>Publish the <code>ApiRequest</code>!</li>
</ol>
<h4 id="examples-of-json-task-requests"><a class="header" href="#examples-of-json-task-requests">Examples of JSON Task Requests</a></h4>
<p>For a <strong>Clean</strong> <code>dispatch_task_request</code>:</p>
<pre><code>{
  &quot;type&quot;: &quot;dispatch_task_request&quot;,
  &quot;request&quot;: {
    &quot;unix_millis_earliest_start_time&quot;: start_time,
    &quot;category&quot;: &quot;clean&quot;,
    &quot;description&quot;: {
      &quot;zone&quot;: &quot;clean_lobby&quot;
    }
  }
}
</code></pre>
<p>For a <strong>Compose</strong> <code>robot_task_request</code> that commands a specific robot to go to a place, followed by performing a <code>teleop</code> action:</p>
<pre><code>{
  &quot;type&quot;: &quot;robot_task_request&quot;,
  &quot;robot&quot;: &quot;tinyRobot1&quot;,
  &quot;fleet&quot;: &quot;tinyRobot&quot;,
  &quot;request&quot;: {
    &quot;category&quot;: &quot;compose&quot;,
    &quot;description&quot;: {
      &quot;category&quot;: &quot;teleop&quot;,
      &quot;phases&quot;: [
        {&quot;activity&quot;: {
          &quot;category&quot;: &quot;sequence&quot;,
          &quot;description&quot;: {
            &quot;activities&quot;: [
              {&quot;category&quot;: &quot;go_to_place&quot;,
               &quot;description&quot;: &quot;coe&quot;
              },
              {&quot;category&quot;: &quot;perform_action&quot;,
                &quot;description&quot;: {&quot;category&quot;: &quot;teleop&quot;, &quot;description&quot;: &quot;coe&quot;}
              }
            ]
          }
        }}
      ]
    }
  }
}
</code></pre>
<p>For a <strong>Delivery</strong> <code>dispatch_task_request</code>:</p>
<pre><code>{
  &quot;type&quot;: &quot;dispatch_task_request&quot;,
  &quot;request&quot;: {
    &quot;category&quot;: &quot;delivery&quot;,
    &quot;description&quot;: {
      &quot;pickup&quot;: {
        &quot;place&quot;: &quot;pantry&quot;,
        &quot;handler&quot;: &quot;coke_dispenser&quot;,
        &quot;payload&quot;: [
          {&quot;sku&quot;: &quot;coke&quot;,
           &quot;quantity&quot;: 1}
        ]
      },
      &quot;dropoff&quot;: {
        &quot;place&quot;: &quot;hardware_2&quot;,
        &quot;handler&quot;: &quot;coke_ingestor&quot;,
        &quot;payload&quot;: [
          {&quot;sku&quot;: &quot;coke&quot;,
           &quot;quantity&quot;: 1}
        ]
      }
    }
  }
}
</code></pre>
<p>For a <strong>Patrol</strong> <code>robot_task_request</code>:</p>
<pre><code>{
  &quot;type&quot;: &quot;robot_task_request&quot;,
  &quot;robot&quot;: &quot;tinyRobot1&quot;,
  &quot;fleet&quot;: &quot;tinyRobot&quot;,
  &quot;request&quot;: {
    &quot;category&quot;: &quot;patrol&quot;,
    &quot;description&quot;: {
      &quot;places&quot;: [&quot;pantry&quot;, &quot;lounge&quot;],
      &quot;rounds&quot;: 2
    }
  }
}
</code></pre>
<p>Some examples of composed task requests can be found <a href="https://github.com/open-rmf/rmf_demos/pull/122">here</a> as reference. They can be used with <code>rmf_demos</code>. Feel free to modify these files according to your own application.</p>
<h2 id="task-management-control"><a class="header" href="#task-management-control">Task Management Control</a></h2>
<p>You may take additional control over your tasks by sending requests to RMF to cancel a task or skip a phase. A full list of JSON schemas for such requests are defined <a href="https://github.com/open-rmf/rmf_api_msgs/tree/main/rmf_api_msgs/schemas">here</a>.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/task_new.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="soss"><a class="header" href="#soss">SOSS</a></h1>
<p>This chapter describes the system-of-systems synthesizer (SOSS), a tool which provides protocol translation between different subsystems.
Such composite systems can be called The ROS-SOSS.
To see the current implementation status, see the <a href="https://github.com/osrf/soss">SOSS repository</a>.</p>
<h2 id="motivation-and-introduction"><a class="header" href="#motivation-and-introduction">Motivation and Introduction</a></h2>
<p>The ecosystem of different message passing systems is vast and diverse.
Without any one single system that is unanimously considered the best for all applications, we are left to consider how we can tie together disparate message passing systems to bridge the gap between the different kinds of applications that all play a critical role in a modern, intelligent robotics solution.
The best protocols to use for inter-robot communication might not be the best for remote operator communication or for end-user communication.</p>
<p>This creates a scalability problem.
If there are <code>N</code> different message passing frameworks being used in a robot deployment with <code>M</code> different message types being passed between them, then manually creating inter-compatibility bridges between them could become an <code>O(MN^2)</code> complexity problem.
This motivates us to use a highly modular, user-friendly integration system that allows the interoperability to be as automatic as possible for as many different message-passing frameworks as we can tie together.
The <code>O(MN^2)</code> problem can be reduced to <code>O(N)</code> complexity, where a plugin is written for each <code>N</code> framework, and all <code>M</code> message types are automatically converted between their <code>N</code> different representations.</p>
<p>The integration service we use for this is called System-of-Systems Synthesizer, or SOSS.
The base SOSS package is simply some abstract interfaces defined in a C++ library, along with a single <code>soss</code> application.
Each different message-passing system will have its own plugin library, e.g. DDS-SOSS, Websocket-SOSS, ROS-SOSS, that implements the abstract interfaces of the base SOSS.
When you run the <code>soss</code> application, you provide a single configuration file that describes how you want your different message-passing systems to bridge with each other.
The <code>soss</code> application can then find plugins that meet the requirements of your configuration file and load those plugins as it starts up.
When messages start to move within each message-passing system, the <code>soss</code> application will grab, translate, and push the messages across the different system boundaries according to the configuration file that was given to it.
Any number of <code>soss</code> instances can be run at once, but they will run independently of each other, so it is important to make sure that their configurations do not overlap.</p>
<p>The base SOSS package also provides some CMake tools to help with auto-generating message definitions for message-passing systems that require static message definitions at compile-time.
For message-passing systems with dynamic message types, the plugin can automatically take care of the translation at runtime, so auto-generation is unnecessary.</p>
<p>For a deeper look at how to use SOSS, we recommend reading <a href="https://integration-service.docs.eprosima.com/en/latest/index.html">the documentation provided by eProsima</a>.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/soss.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><!-- # Requirements -->
<!-- robot, door, lift, workcell, etc. integration with RMF

    I have a door door
    I have an elevator / I have a lift arrow_up_down
    I have a workcell robot mechanical_arm
    I have a loose mobile robot and would like to use FreeFleet (F5)
        robot runs ROS 1
        robot runs ROS 2
        robot runs something that I wrote
        robot runs something somebody else wrote and I can't change
    I have some mobile robots with their own fleet manager(s)
        it has a REST API or some other formal API (XMLRPC)
        it has some other communication mechanism (SQL database, etc.) -->
<h1 id="integration"><a class="header" href="#integration">Integration</a></h1>
<p>This chapter describes the requirements and basic steps to integrate hardware with RMF. These include <a href="https://osrf.github.io/ros2multirobotbook/integration_fleets.html">mobile robots</a>, <a href="https://osrf.github.io/ros2multirobotbook/integration_doors.html">doors</a>, <a href="https://osrf.github.io/ros2multirobotbook/integration_lifts.html">elevators</a> and <a href="https://osrf.github.io/ros2multirobotbook/integration_workcells.html">workcells</a>.
In each section, we will go through how to build and use the necessary ROS 2 packages and interfaces, as well as possible scenarios where such interactions occur.</p>
<p>RMF uses ROS 2 messages and topic interfaces to communicate between different components in the overall RMF system.
In most cases we use components called Adapters to bridge between the hardware-specific interfaces and the general purpose interfaces of RMF.
This chapter will discuss how to develop an RMF Adapter for different types of hardware components.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/integration.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="route-map-data-requirements-for-integration-with-rmf"><a class="header" href="#route-map-data-requirements-for-integration-with-rmf">Route Map Data Requirements for Integration with RMF</a></h1>
<h2 id="motivation-1"><a class="header" href="#motivation-1">Motivation</a></h2>
<p>RMF uses robot route maps to predict the navigation paths of robots working in the environment. RMF generates path predictions for all active robots in the environment which can be used to proactively avoid conflicts between the various robot path plans. This is often referred to as &quot;traffic management&quot; in RMF. Along with the traffic management, RMF can help enable multi-fleet visualization to building/robot operations staff, improve scheduling of resources (such as lifts and corridors), reduce robot deadlock and more.</p>
<p>Robot route maps in large buildings are complex and may evolve over time in response to customer requests and building renovations. As a result, RMF works best when scripts can automatically import robot route maps, and re-import them in the future after changes are made.</p>
<h2 id="minimum-map-information-required"><a class="header" href="#minimum-map-information-required">Minimum Map Information Required</a></h2>
<ul>
<li>list of waypoints or nodes
<ul>
<li>name of waypoint</li>
<li>level name (B1, L1, L2, etc.)</li>
<li>(x, y) location in meters within the level</li>
<li>any special properties or flags, such as:
<ul>
<li>is this a dropoff/pickup parking point?</li>
<li>is this a charger?</li>
<li>is this a safe parking spot during an emergency alarm?</li>
</ul>
</li>
</ul>
</li>
<li>list of edges or &quot;travel lanes&quot; between nodes
<ul>
<li>(start, end) waypoint names</li>
<li>two-way or one-way traffic?
<ul>
<li>if one-way, identify direction of travel</li>
</ul>
</li>
<li>any other information, such as speed limit along this segment</li>
</ul>
</li>
</ul>
<h2 id="format-requirements"><a class="header" href="#format-requirements">Format Requirements</a></h2>
<p>We can write import scripts to handle virtually any &quot;open&quot; file format that contains the required information. This includes, in order of preference:</p>
<ul>
<li>YAML</li>
<li>XML</li>
<li>plain text (space or comma-separated ASCII, etc.)</li>
<li>DXF</li>
<li>DWG</li>
<li>SVG</li>
</ul>
<p>Note that if the map data is provided in textual form, screenshots are helpful for &quot;sanity-checking&quot; the coordinate system and alignment with building features.</p>
<h2 id="traffic-editor-2"><a class="header" href="#traffic-editor-2">Traffic Editor</a></h2>
<p>If the robot route map does not exist yet, then the <a href="./traffic-editor.html">traffic editor tool</a> can be used to help create one. The traffic editor tool will also export the route map in an RMF-friendly format.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/integration_nav-maps.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="mobile-robot-fleet-integration"><a class="header" href="#mobile-robot-fleet-integration">Mobile Robot Fleet Integration</a></h1>
<p>Here we will cover integrating a mobile robot fleet that offers the <strong>Full Control</strong> category of fleet adapter, as discussed in the <a href="./rmf-core.html">RMF Core Overview</a> chapter.
This means we assume the mobile robot fleet manager allows us to specify explicit paths for the robot to follow, and that the path can be interrupted at any time and replaced with a new path.
Furthermore, each robot's position will be updated live as the robots are moving.</p>
<h2 id="route-map"><a class="header" href="#route-map">Route Map</a></h2>
<p>Before such a fleet can be integrated, you will need to procure or produce a route map as described in the <a href="./integration_nav-maps.html">previous section</a>. The fleet adapter uses the route map to plan out feasible routes for the vehicles under its control, taking into account the schedules of all other vehicles. It will also use the route map to decide out how to negotiate with other fleet adapters when a scheduling conflict arises. The adapter will only consider moving the robots along routes that are specified on the route map, so it is important that the route coverage is comprehensive. At the same time, if there are extraneous waypoints on the route map, the adapter might spend more time considering all the possibilities than what should really be needed, so it is a good idea to have a balance of comprehensiveness and leanness.</p>
<h2 id="c-api"><a class="header" href="#c-api">C++ API</a></h2>
<p>The C++ API for <strong>Full Control</strong> automated guided vehicle (AGV) fleets can be found in the <a href="https://github.com/open-rmf/rmf_ros2/tree/main/rmf_fleet_adapter"><code>rmf_fleet_adapter</code></a> package of the <code>rmf_ros2</code> repo. The API consists of four critical classes:</p>
<ul>
<li><a href="https://github.com/open-rmf/rmf_ros2/blob/main/rmf_fleet_adapter/include/rmf_fleet_adapter/agv/Adapter.hpp"><code>Adapter</code></a> - Initializes and maintains communication with the other core RMF systems. Use this to register one or more fleets and receive a <code>FleetUpdateHandle</code> for each fleet.</li>
<li><a href="https://github.com/open-rmf/rmf_ros2/blob/main/rmf_fleet_adapter/include/rmf_fleet_adapter/agv/FleetUpdateHandle.hpp"><code>FleetUpdateHandle</code></a> - Allows you to configure a fleet by adding robots and specifying settings for the fleet (e.g. specifying what types of deliveries the fleet can perform). New robots can be added to the fleet at any time.</li>
<li><a href="https://github.com/open-rmf/rmf_ros2/blob/main/rmf_fleet_adapter/include/rmf_fleet_adapter/agv/RobotUpdateHandle.hpp"><code>RobotUpdateHandle</code></a> - Use this to update the position of a robot and to notify the adapter if the robot's progress gets interrupted.</li>
<li><a href="https://github.com/open-rmf/rmf_ros2/blob/main/rmf_fleet_adapter/include/rmf_fleet_adapter/agv/RobotCommandHandle.hpp"><code>RobotCommandHandle</code></a> - This is a pure abstract interface class. The functions of this class must be implemented to call upon the API of the specific fleet manager that is being adapted.</li>
</ul>
<p>The C++ API for <strong>Traffic Light Control</strong> fleets (i.e. fleets that only allow RMF to pause/resume each mobile robot) can also be found in the <code>rmf_fleet_adapter</code> package of the <code>rmf_ros2</code> repo. The API reuses the <code>Adapter</code> class and requires users to initialize their fleet using either of the APIs <a href="https://github.com/open-rmf/rmf_ros2/blob/9b4b8a8cc38b323f875a55c70f307446584d1639/rmf_fleet_adapter/include/rmf_fleet_adapter/agv/Adapter.hpp#L106-L180">here</a>. The user has the option to integrate via the <a href="https://github.com/open-rmf/rmf_ros2/blob/main/rmf_fleet_adapter/include/rmf_fleet_adapter/agv/TrafficLight.hpp"><code>TrafficLight</code></a> API or for greater convenience, via the <a href="https://github.com/open-rmf/rmf_ros2/blob/main/rmf_fleet_adapter/include/rmf_fleet_adapter/agv/EasyTrafficLight.hpp"><code>EasyTrafficLight</code></a> API.</p>
<p>The basic workflow of developing a fleet adapter is the following:</p>
<ol>
<li>Create an application that links to the <code>rmf_fleet_adapter</code> library.</li>
<li>Have the application read in runtime parameters in whatever way is desired (e.g. command line arguments, configuration file, ROS parameters, REST API calls, environment variables, etc).</li>
<li>Construct a route graph for each fleet that this application is providing the adapter for (a single adapter application can service any number of fleets), and/or parse the route graph from a YAML file using the <a href="https://github.com/open-rmf/rmf_ros2/blob/main/rmf_fleet_adapter/include/rmf_fleet_adapter/agv/parse_graph.hpp"><code>rmf_fleet_adapter::agv::parse_graph</code></a> utility.</li>
<li>Instantiate an <code>rmf_fleet_adapter::agv::Adapter</code> using <code>Adapter::make(~)</code> or <code>Adapter::init_and_make(~)</code>.</li>
<li>Add the fleets that the application will be responsible for adapting, and save the <code>rmf_fleet_adapter::agv::FleetUpdateHandlePtr</code> instances that are passed back.</li>
<li>Implement the <code>RobotCommandHandle</code> class for the fleet manager API that is being adapted.</li>
<li>Add the robots that the adapter is responsible for controlling. The robots can be added based on the startup configuration, or they can be dynamically added during runtime as they are discovered over the fleet manager API (or both).
<ul>
<li>When adding a robot, you will need to create a new instance of the custom <code>RobotCommandHandle</code> that you implemented.</li>
<li>You will also need to provide a callback that will be triggered when the adapter is finished registering the robot. This callback will provide you with a new <code>RobotUpdateHandle</code> for your robot. It is imperative to save this update handle so you can use it to update the robot's position over time.</li>
</ul>
</li>
<li>As new information arrives from the fleet manager API, use the collection of <code>RobotUpdateHandle</code> classes to keep the adapter up-to-date on the robots' positions.</li>
</ol>
<p>An example of a functioning fleet adapter application can be found in the <a href="https://github.com/open-rmf/rmf_ros2/blob/main/rmf_fleet_adapter/src/full_control/main.cpp"><code>full_control</code> backwards-compatibility adapter</a>. This is a fleet adapter whose fleet-side API is the &quot;Fleet Driver API&quot;, which is a deprecated prototype API for the RMF <strong>Full Control</strong> category of fleet adapters. This fleet adapter exists temporarily to maintain backwards compatibility with the old &quot;Fleet Driver&quot; implementations and to serve as an example of how to implement a fleet adapter using the new C++ API.</p>
<h2 id="python-bindings"><a class="header" href="#python-bindings">Python Bindings</a></h2>
<p>You may also choose to use Python to implement your fleet adapter. You can find Python bindings for the C++ API in the <a href="https://github.com/open-rmf/rmf_ros2/tree/main/rmf_fleet_adapter_python">rmf_fleet_adapter_python repo</a>. The Python bindings literally just port the C++ API into Python so that you can develop your fleet adapter using Python instead of C++. The above API and workflow are exactly the same, just in Python instead. This should be very useful for fleets that use REST APIs, because you'll have access to tools like <a href="https://swagger.io/tools/open-source/getting-started/">Swagger</a> which can help you generate client code for the fleet's REST API server.</p>
<h2 id="fleet-adapter-template"><a class="header" href="#fleet-adapter-template">Fleet Adapter Template</a></h2>
<p>To make the process of integrating a robotic fleet with RMF even simpler, we have open-sourced a <strong>Full Control</strong> <a href="https://github.com/open-rmf/fleet_adapter_template">template package</a> where users only need to update certain blocks of code with the API calls to their specific robot/fleet manager. This way, users can integrate RMF while using their preferred APIs between the fleet adapter and their robots. Do note that this template is just one of many ways to integrate fleets with REST or websocket based APIs. The following diagram illustrates how RMF can communicate with fleet robots using the APIs chosen by the user and the robot vendor.</p>
<img src="images/fleet_adapter_flow.png">
<p>This fleet adapter system is also integrated in our demos worlds with simulation robots, which is further elaborated in the next section.</p>
<p>Since the fleet adapter template already applies the C++ API and Python bindings, you can follow these steps to build your fleet adapter on top of the given template:</p>
<ol>
<li>Modify <a href="https://github.com/open-rmf/fleet_adapter_template/blob/main/fleet_adapter_template/fleet_adapter_template/RobotCommandHandle.py"><code>RobotCommandHandle.py</code></a>. As mentioned above, a new instance of <code>RobotCommandHandle</code> will be created for each robot in the fleet. You should look over the code and implement application-specific logic for navigation, arrival estimation and docking.</li>
<li>Create a fleet manager that interfaces with your fleet's robots. Your fleet manager should be able to retrieve state information from and send navigation commands to your robots over your robot vendor's API. This could be ROS messages or any custom API. If you have multiple fleets using different robot APIs, make sure to create separate fleet managers for these fleets. You should also pick an API to communicate with the adapter and design your fleet manager accordingly.</li>
<li>Fill in the missing code in <a href="https://github.com/open-rmf/fleet_adapter_template/blob/main/fleet_adapter_template/fleet_adapter_template/RobotClientAPI.py"><code>RobotClientAPI.py</code></a>. This is the most important part of integration. Depending on the API you choose to interface between the adapter and manager, you will have to format your robot's data accordingly and return the values specified in the template. This is critical as the functions in <code>RobotClientAPI</code> are called from <code>RobotCommandHandle</code> when the adapter is planning tasks or updating traffic schedules.</li>
<li>For <strong>each</strong> robot fleet, create a <a href="https://github.com/open-rmf/fleet_adapter_template/blob/main/fleet_adapter_template/config.yaml"><code>config.yaml</code></a> file to include important fleet parameters. These parameters will be passed to the fleet adapter and configured when initializing the fleet.</li>
</ol>
<p>Once you are done, you can run both the fleet adapter and your custom fleet manager. Remember to parse the configuration file and navigation graph when launching the adapter.</p>
<h2 id="case-study-rmf-demos-fleet-adapter"><a class="header" href="#case-study-rmf-demos-fleet-adapter">Case Study: RMF Demos Fleet Adapter</a></h2>
<p>The Python implementation of the <strong>Full Control</strong> fleet adapter classes is demonstrated in the <a href="https://github.com/open-rmf/rmf_demos/tree/main/rmf_demos_fleet_adapter">demos fleet adapter</a>. Building on top of the fleet adapter template, the demos fleet adapter uses REST API as an interface between the adapter and the simulation robots: the adapter sends out commands to the robots, while the robots update the adapter on their current state information. This is done by creating a <a href="https://github.com/open-rmf/rmf_demos/blob/main/rmf_demos_fleet_adapter/rmf_demos_fleet_adapter/fleet_manager.py"><code>fleet_manager</code></a> node that contains the necessary REST endpoints for <code>RobotClientAPI</code> to interact with.</p>
<img src="images/demo_fleet_adapter_flow.png">
<h3 id="demos-fleet-manager"><a class="header" href="#demos-fleet-manager">Demos Fleet Manager</a></h3>
<p>Whenever a command is ready to be sent from the adapter's <code>RobotCommandHandle</code>, it will call the relevant API function defined in <code>RobotClientAPI</code> and query the corresponding endpoint from the API server in the <code>fleet_manager</code> node. Each function either retrieves specific information about the robot's current state (including but not limited to its last known position, remaining battery level, and whether it has completed a request), or sends a command to the robot to carry out a request. The robot state information is required for the fleet adapter to update the traffic schedule, plan for subsequent tasks, and guide robots across different paths in the environment.</p>
<p>The demos fleet adapter is integrated with the simulation robots which publish their state information via internal ROS2 messages, hence the <code>fleet_manager</code> also serves to consolidate the messages published by different robots from its fleet and sends them to the right robot's <code>RobotCommandHandle</code>. The API endpoints are designed such that the adapter can query information or send commands to a particular robot by specifying the robot's name. The <code>fleet_manager</code> will ensure that the robot exists in the fleet before returning the requested state information or relaying commands to the simulation robot. Additionally, the adapter can retrieve the status of the entire fleet's robots.</p>
<h3 id="fleet-configuration"><a class="header" href="#fleet-configuration">Fleet Configuration</a></h3>
<p>There are four <strong>Full Control</strong> fleets in our demo simulation, each with their own fleet-specific parameters. To better consolidate and set up these configurations upon initializing the fleet, they are stored in a <a href="https://github.com/open-rmf/rmf_demos/blob/main/rmf_demos/config/office/tinyRobot_config.yaml"><code>config.yaml</code></a> file. Paths to the configuration and navigation graph files are required when running the fleet adapter and manager. General fleet settings and capabilities are defined under the <code>rmf_fleet</code> section.</p>
<p>The config file also takes care of robot-specific parameters within the fleet, such as the number of robots in the fleet, each of their names and their starting waypoints. For example, the <code>tinyRobot</code> fleet in Office demo world has two robots, so we append the configurations for each robot to the <code>robots</code> section in the config file.</p>
<p>For users who are operating their robots in a different coordinate frame from RMF, the <code>reference_coordinate</code> section in the config file helps to perform any necessary transformations. Do note that RMF and the slotcar simulation robots share the same coordinate frame, so this transformation is not implemented in the demos fleet adapter.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/integration_fleets.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="free-fleet-1"><a class="header" href="#free-fleet-1">Free Fleet</a></h1>
<p>In the event that the user wishes to integrate a standalone mobile robot which doesn't come with its own fleet management system, the open source fleet management system <code>free_fleet</code> could be used.</p>
<p>The <code>free_fleet</code> system is split into a client and a server. The client is to be run on each of these standalone mobile robots alongside their navigation software and is intended to have direct control over the mobile robot while at the same time monitor its status and report back to the server. The client's base implementation is designed to allow interaction with different configurations of mobile robots yet report to the same server. This way, users are able to use <code>free_fleet</code> to manage a heterogenrous fleet of robots, each using different distributions of ROS, versions of ROS, navigation software, or onboard communication protocols.</p>
<p>The server is run on a central computer and consolidates the incoming status updates from each client to be either visualized using a UI, or relayed upstream to RMF. The server also relays commands from the user via the UI or from RMF down to the clients to be executed. Each server can work with multiple clients at a time, hence it serves the role of a fleet management system. The server can be implemented and used as its own fleet management system or work with larger systems like RMF, bridging the gap between each mobile robot's API and RMF's API and interface.</p>
<p>The communication between the <code>free_fleet</code> server and <code>free_fleet</code> clients is implemented using <code>CycloneDDS</code>, therefore we are not concerned if the mobile robot or central computer is running different versions of ROS.</p>
<p>In this section, we will address 4 different approaches of using <code>free_fleet</code> to integrate with RMF, specifically the navigation stack used by the robot. Each approach maintains a similar systems architecture, which is illustrated in the simple block diagram below, but there are specific examples depending on the software choice for the navigation stack used by the robot developer.</p>
<img src="images/free_fleet_block_diagram.png">
<h2 id="ros-1-navigation-stack"><a class="header" href="#ros-1-navigation-stack">ROS 1 Navigation Stack</a></h2>
<p>An implementation of a <code>free_fleet</code> client that works with a ROS 1 navigation stack can be found in the <a href="https://github.com/open-rmf/free_fleet">free_fleet repository</a>. The implementation expects the transforms of the mobile robot to be fully defined, the mobile robot to accept navigation commands via the <code>move_base</code> action library, as well as publishing its battery status published using the <code>sensor_msgs/BatteryState</code> message.</p>
<p>After following the build instructions on the README on the mobile robot, the user can launch the client as part of their launch script while at the same time define the necessary parameters using <code>rosparam</code>. Below is a small snippet example of how a client can be launched, with its paramters defined,</p>
<pre><code class="language-xml">&lt;node name=&quot;free_fleet_client_node&quot;
    pkg=&quot;free_fleet_client_ros1&quot;
    type=&quot;free_fleet_client_ros1&quot; output=&quot;screen&quot;&gt;

  &lt;!-- These parameters will be used to identify the mobile robots --&gt;
  &lt;param name=&quot;fleet_name&quot; type=&quot;string&quot; value=&quot;example_fleet&quot;/&gt;
  &lt;param name=&quot;robot_name&quot; type=&quot;string&quot; value=&quot;example_bot&quot;/&gt;
  &lt;param name=&quot;robot_model&quot; type=&quot;string&quot; value=&quot;Turtlebot3&quot;/&gt;

  &lt;!-- These are the topics required to get battery and level information --&gt;
  &lt;param name=&quot;battery_state_topic&quot; type=&quot;string&quot; value=&quot;example_bot/battery_state&quot;/&gt;
  &lt;param name=&quot;level_name_topic&quot; type=&quot;string&quot; value=&quot;example_bot/level_name&quot;/&gt;

  &lt;!-- These frames will be used to update the mobile robot's location --&gt;
  &lt;param name=&quot;map_frame&quot; type=&quot;string&quot; value=&quot;example_bot/map&quot;/&gt;
  &lt;param name=&quot;robot_frame&quot; type=&quot;string&quot; value=&quot;example_bot/base_footprint&quot;/&gt;

  &lt;!-- The name of the move_base server for actions --&gt;
  &lt;param name=&quot;move_base_server_name&quot; type=&quot;string&quot; value=&quot;example_bot/move_base&quot;/&gt;

  &lt;!-- These are DDS configurations used between Free Fleet clients and servers --&gt;
  &lt;param name=&quot;dds_domain&quot; type=&quot;int&quot; value=&quot;42&quot;/&gt;
  &lt;param name=&quot;dds_state_topic&quot; type=&quot;string&quot; value=&quot;robot_state&quot;/&gt;
  &lt;param name=&quot;dds_mode_request_topic&quot; type=&quot;string&quot; value=&quot;mode_request&quot;/&gt;
  &lt;param name=&quot;dds_path_request_topic&quot; type=&quot;string&quot; value=&quot;path_request&quot;/&gt;
  &lt;param name=&quot;dds_destination_request_topic&quot; type=&quot;string&quot; value=&quot;destination_request&quot;/&gt;

  &lt;!-- This decides how long the client should wait for a valid transform and action server before failing --&gt;
  &lt;param name=&quot;wait_timeout&quot; type=&quot;double&quot; value=&quot;10&quot;/&gt;

  &lt;!-- These define the frequency at which the client checks for commands and
  publishes the robot state to the server --&gt;
  &lt;param name=&quot;update_frequency&quot; type=&quot;double&quot; value=&quot;10.0&quot;/&gt;
  &lt;param name=&quot;publish_frequency&quot; type=&quot;double&quot; value=&quot;1.0&quot;/&gt;

  &lt;!-- The client will only pass on navigation commands if the destination or first waypoint
  of the path is within this distance away, otherwise it will ignore the command --&gt;
  &lt;param name=&quot;max_dist_to_first_waypoint&quot; type=&quot;double&quot; value=&quot;10.0&quot;/&gt;

&lt;/node&gt;
</code></pre>
<p>The running <code>free_fleet</code> client will communicate with the nodes running on the robot via ROS 1, while publishing its state and subscribing to requests over DDS with the <code>free_fleet</code> server.</p>
<p>The current implementation of the <code>free_fleet</code> server is implemented with ROS 2 and communicates with RMF using the aforementioned ROS 2 message and topic interfaces of an RMF fleet adapter. The ROS 2 build instructions can also be found on the same repository. Similar to the client, a simple ROS 2 wrapper has been implemented, and it can be started using a <code>.launch.xml</code> file like so:</p>
<pre><code class="language-xml">&lt;node pkg=&quot;free_fleet_server_ros2&quot;
    exec=&quot;free_fleet_server_ros2&quot;
    name=&quot;free_fleet_server_node&quot;
    node-name=&quot;free_fleet_server_node&quot;
    output=&quot;both&quot;&gt;

  &lt;!-- Fleet name will be used to identify robots --&gt;
  &lt;param name=&quot;fleet_name&quot; value=&quot;example_fleet&quot;/&gt;

  &lt;!-- These are the ROS2 topic names that will be used to communicate with RMF --&gt;
  &lt;param name=&quot;fleet_state_topic&quot; value=&quot;fleet_states&quot;/&gt;
  &lt;param name=&quot;mode_request_topic&quot; value=&quot;robot_mode_requests&quot;/&gt;
  &lt;param name=&quot;path_request_topic&quot; value=&quot;robot_path_requests&quot;/&gt;
  &lt;param name=&quot;destination_request_topic&quot; value=&quot;robot_destination_requests&quot;/&gt;

  &lt;!-- These are the DDS specific configurations used to communicate with the clients --&gt;
  &lt;param name=&quot;dds_domain&quot; value=&quot;42&quot;/&gt;
  &lt;param name=&quot;dds_robot_state_topic&quot; value=&quot;robot_state&quot;/&gt;
  &lt;param name=&quot;dds_mode_request_topic&quot; value=&quot;mode_request&quot;/&gt;
  &lt;param name=&quot;dds_path_request_topic&quot; value=&quot;path_request&quot;/&gt;
  &lt;param name=&quot;dds_destination_request_topic&quot; value=&quot;destination_request&quot;/&gt;

  &lt;!-- This determines the frequency it checks for incoming state and request messages,
  as well as how often it publishes its fleet state to RMF --&gt;
  &lt;param name=&quot;update_state_frequency&quot; value=&quot;20.0&quot;/&gt;
  &lt;param name=&quot;publish_state_frequency&quot; value=&quot;2.0&quot;/&gt;

  &lt;!-- These transformations are required when the frame of the robot fleet is
  different from that of RMF globally. In order to transform a pose from the RMF
  frame to the free fleet robot frame, it is first scaled, rotated, then
  translated using these parameters --&gt;
  &lt;param name=&quot;scale&quot; value=&quot;0.928&quot;/&gt;
  &lt;param name=&quot;rotation&quot; value=&quot;-0.013&quot;/&gt;
  &lt;param name=&quot;translation_x&quot; value=&quot;-4.117&quot;/&gt;
  &lt;param name=&quot;translation_y&quot; value=&quot;27.26&quot;/&gt;

&lt;/node&gt;
</code></pre>
<p>Furthermore, an example of this configuration can be found in the repository as well, under the packages <code>ff_examples_ros1</code> and <code>ff_exmaples_ros2</code>. This example launches the example simulation <a href="https://emanual.robotis.com/docs/en/platform/turtlebot3/simulation/#ros-1-simulation">from <code>ROBOTIS</code></a>, which has a small simulated world with 3 Turtlebot3 mobile robots, each running its own ROS 1 navigation stack.</p>
<p>After successful builds for both ROS 1 and ROS 2 workspaces, the simulation can be launched following <a href="https://github.com/open-rmf/free_fleet#turtlebot3-simulation">these instructions</a>, which also includes a ROS 2 <code>free_fleet</code> server, publishing fleet state messages and accepting mode and navigation requests over ROS 2 messages and topics.</p>
<h2 id="ros-2-navigation-stack"><a class="header" href="#ros-2-navigation-stack">ROS 2 Navigation Stack</a></h2>
<p>An implementation for a robot using ROS 2 would be similar to a ROS 1 navigation stack described earlier. At this time, the ROS 2 <code>free_fleet</code> client is still under development. This section will be updated once the refactoring, implementation and testing has been completed.</p>
<p>The same ready <code>free_fleet</code> server implementation in the repository will work in this scenario, as the interfaces provided by the fleet adapters are still the same ROS 2 messages and topics.</p>
<p>If required in the meantime, users can implement their own <code>free_fleet</code> client, by working with the <code>free_fleet</code> library that contains the base implementation and API for the DDS communication. This will be further elaborated in the next section, <a href="https://osrf.github.io/ros2multirobotbook/integration_free-fleet.html#developer-navigation-stack">Developer Navigation Stack</a>.</p>
<h2 id="developer-navigation-stack"><a class="header" href="#developer-navigation-stack">Developer Navigation Stack</a></h2>
<p>In this implementation, it is assumed that the software running on the mobile robot was written by the robot developers themselves (or their immediate subcontractors) and the developers fully understand and have access to their robot's internal control software, API's and interfaces. This level of understanding and access will be necessary for implementing your own <code>free_fleet</code> client wrapper. The block diagram below illustrates this configuration:</p>
<img src="images/free_fleet_custom_config.png">
<p>Once the developer's <code>free_fleet</code> client is fully functional, it will be a simple task of launching the same ROS 2 <code>free_fleet</code> server as mentioned earlier in this section to work with the fleet adapters through ROS 2 messages and topics.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/integration_free-fleet.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="read-only-fleet-integration"><a class="header" href="#read-only-fleet-integration">Read-only Fleet Integration</a></h1>
<p>In this section, we will cover the prototype API for integrating the <strong>Read Only</strong> category of mobile robot fleets. This means we assume the mobile robot fleet manager only allows RMF to see updates about where its robots are located and where they intend to go, but it does not offer any control over where the robots are going or how they can move around. This type of adapter is primarily aimed at legacy systems that were developed before RMF and did not anticipate the possibility of a third-party being able to command the robots.</p>
<h2 id="fleet-driver-api"><a class="header" href="#fleet-driver-api">Fleet Driver API</a></h2>
<p>The Fleet Driver API was an experimental API developed in the early stages of the RMF research project. It can still be used for a read-only fleet adapter implementation until an officially supported C++ API comes out to replace it.</p>
<p>The Fleet Driver API uses ROS 2 messages from the <a href="https://github.com/open-rmf/rmf_internal_msgs/tree/main/rmf_fleet_msgs"><code>rmf_fleet_msgs</code></a> package. To use this API, you will want to write a ROS 2 application (using either rclcpp or rclpy) which we will refer to as the <em>Fleet Driver</em>. The job of the Fleet Driver is to transmit <a href="https://github.com/open-rmf/rmf_internal_msgs/blob/main/rmf_fleet_msgs/msg/FleetState.msg"><code>rmf_fleet_msgs/FleetState</code></a> messages out to the <code>fleet_states</code> topic.</p>
<p>Inside the <code>FleetState</code> message is the <code>name</code> field. Be sure to fill in the correct name for your fleet state. There is also a collection of <a href="https://github.com/open-rmf/rmf_internal_msgs/blob/main/rmf_fleet_msgs/msg/RobotState.msg"><code>rmf_fleet_msgs/RobotState</code></a> messages. For integrating a read-only fleet with RMF, the most crucial fields of the <code>RobotState</code> message are:</p>
<ul>
<li><code>name</code> - The name of the robot whose state is being specified.</li>
<li><code>location</code> - The current location of the robot.</li>
<li><code>path</code> - The sequence of locations that the robot will be traveling through.</li>
</ul>
<p>Inside the <a href="https://github.com/open-rmf/rmf_internal_msgs/blob/main/rmf_fleet_msgs/msg/Location.msg"><code>rmf_fleet_msgs/Location</code></a> message, the <code>t</code> field (which represents time) is generally ignored by the read-only fleet adapter. We assume that it is too cumbersome for your Fleet Driver to make timing predictions, so we have the read-only fleet adapter make the predictions for you based on the traits of the vehicle.</p>
<h2 id="configuring-the-read-only-fleet-adapter"><a class="header" href="#configuring-the-read-only-fleet-adapter">Configuring the Read Only Fleet Adapter</a></h2>
<p>For the prototype read-only integration, there are two applications that need to be launched:</p>
<ol>
<li>The Fleet Driver mentioned above which you write specifically for your fleet's custom API</li>
<li>The <code>read_only</code> fleet adapter which must be launched through ROS 2</li>
</ol>
<p>To launch the fleet adapter, you will need to use <code>ros2 launch</code> and include <code>rmf_fleet_adapter/fleet_adapter.launch.xml</code> file with the required parameters filled in. An example of this using the XML front-end of ros2 launch <a href="https://github.com/open-rmf/rmf_demos/blob/main/rmf_demos/launch/include/adapters/caddy_adapter.launch.xml">can be found in <code>rmf_demos</code></a>, copied below:</p>
<pre><code>&lt;?xml version='1.0' ?&gt;

&lt;launch&gt;

  &lt;arg name=&quot;fleet_name&quot; default=&quot;caddy&quot; description=&quot;Name of this fleet of caddy robots&quot;/&gt;

  &lt;group&gt;
    &lt;include file=&quot;$(find-pkg-share rmf_fleet_adapter)/fleet_adapter.launch.xml&quot;&gt;

      &lt;!-- The name and control type of the fleet --&gt;
      &lt;arg name=&quot;fleet_name&quot; value=&quot;$(var fleet_name)&quot;/&gt;
      &lt;arg name=&quot;control_type&quot; value=&quot;read_only&quot;/&gt;

      &lt;!-- The nominal linear and angular velocity of the caddy --&gt;
      &lt;arg name=&quot;linear_velocity&quot; value=&quot;1.0&quot;/&gt;
      &lt;arg name=&quot;angular_velocity&quot; value=&quot;0.6&quot;/&gt;

      &lt;!-- The nominal linear and angular acceleration of the caddy --&gt;
      &lt;arg name=&quot;linear_acceleration&quot; value=&quot;0.7&quot;/&gt;
      &lt;arg name=&quot;angular_acceleration&quot; value=&quot;1.5&quot;/&gt;

      &lt;!-- The radius of the circular footprint of the caddy --&gt;
      &lt;arg name=&quot;footprint_radius&quot; value=&quot;1.5&quot;/&gt;
      &lt;!-- Other robots are not allowed within this radius --&gt;
      &lt;arg name=&quot;vicinity_radius&quot; value=&quot;5.0&quot;/&gt;

      &lt;arg name=&quot;delay_threshold&quot; value=&quot;1.0&quot;/&gt;

    &lt;/include&gt;
  &lt;/group&gt;
</code></pre>
<p>The critical parameters are:</p>
<ul>
<li><code>fleet_name</code>: This must match the <code>name</code> value that the Fleet Driver gives to its <code>FleetState</code> messages.</li>
<li><code>control_type</code>: This must be <code>&quot;read_only&quot;</code>.</li>
<li><code>linear_velocity</code>, <code>angular_velocity</code>, <code>linear_acceleration</code>, and <code>angular_acceleration</code>: These are estimates of the kinematic properties of the vehicles. For the sake of effective scheduling, it is preferable to overestimate these values than underestimate them, so it is best to think of these parameters as upper bounds for the values.</li>
<li><code>footprint_radius</code>: The radius of physical space that the vehicle occupies. This should cover the maximum extent of the physical footprint.</li>
<li><code>vicinity_radius</code>: The radius around the robot in which other robots are forbidden to physically enter. It is assumed that another robot entering this radius will interfere with the ability of this robot to operate.</li>
</ul>
<p>When the launch file and Fleet Driver application are both ready, you can launch them side-by-side and the integration of the read-only fleet adapter will be complete.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/integration_read-only.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h2 id="doors-1"><a class="header" href="#doors-1">Doors</a></h2>
<h3 id="map-requirements"><a class="header" href="#map-requirements">Map Requirements</a></h3>
<p>Before a door can be properly integrated, be sure to draw up the door locations with the correct door names on the navigation graph using <code>traffic_editor</code>. The instructions to do so can be found in the <a href="./traffic-editor.html">Traffic Editor</a> chapter.</p>
<h3 id="integration-1"><a class="header" href="#integration-1">Integration</a></h3>
<p>Door integration is required when integrating RMF into a new environment. For hopefully obvious reasons, only automated doors can be integrated with RMF though it may be possible to trigger an alert to a designated human to open a manual door but this is not recommended. An automated door can be defined as an electronically powered door that is remotely controllable, either using a remote trigger or has been outfitted with a computing unit capable of commanding the door to open and close when needed, using certain interfaces.</p>
<p>Doors can be integrated with RMF using a ROS 2 door node and a door adapter, which we sometimes refer to as a door supervisor. The block diagram below displays the relationship and communication modes between each component:</p>
<img src="images/doors_block_diagram.png">
<p>The door node will have to be implemented based on the make and model of the door that is being integrated in order to address the specific API of the door controller module. The communication protocol will also be dependent on the door and controller model, which might be some form of <code>REST</code>, <code>RPCXML</code>, etc. The door node is in charge of publishing its state and receiving commands over ROS 2, using the messages and topics listed below:</p>
<div class="table-wrapper"><table><thead><tr><th>Message Types</th><th>ROS2 Topic</th><th>Description</th></tr></thead><tbody>
<tr><td><code>rmf_door_msgs/DoorState</code></td><td><code>/door_states</code></td><td>State of the door published by the door node</td></tr>
<tr><td><code>rmf_door_msgs/DoorRequest</code></td><td><code>/door_requests</code></td><td>Direct requests subscribed by the door node and published by the door adapter</td></tr>
<tr><td><code>rmf_door_msgs/DoorRequest</code></td><td><code>/adapter_door_requests</code></td><td>Requests to be sent to the door adapter/supervisor to request safe operation of doors</td></tr>
</tbody></table>
</div>
<p>The door adapter stands in between the rest of the RMF core systems, fleet adapters, and the door node, and acts like a state supervisor ensuring that the doors are not acting on requests that might obstruct an ongoing mobile robot task or accidentally closing on it. It keeps track of the door state from the door node, and receives requests from the <code>adapter_door_requests</code> topic which are published by either fleet adapters or other parts of the RMF core system. Only when the door adapter deems that a request is safe enough to be performed, it will instruct the door node using a request. It should also be noted that direct requests sent to the door node, without going through the door adapter will be negated by the door adapter, to return it to its prior state in order to prevent disruptions during operations with mobile robots.</p>
<h2 id="door-adapter-template"><a class="header" href="#door-adapter-template">Door Adapter Template</a></h2>
<p>To make the process of integrating doors with RMF even simpler, we have open-sourced a <a href="https://github.com/open-rmf/door_adapter_template">template package</a> where users only need to update certain blocks of code with the API calls to their specific door controller.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/integration_doors.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="lifts-ie-elevators"><a class="header" href="#lifts-ie-elevators">Lifts (i.e. Elevators)</a></h1>
<h2 id="map-requirements-1"><a class="header" href="#map-requirements-1">Map requirements</a></h2>
<p>Before a lift can be properly integrated, be sure to draw up the lift locations with the correct lift names and levels on the navigation graph using <code>traffic_editor</code>. The instructions to do so can be found in <a href="./traffic-editor.html">Traffic Editor</a> chapter.</p>
<h2 id="integration-2"><a class="header" href="#integration-2">Integration</a></h2>
<p>Elevator integration will allow RMF to work over multiple levels, resolving conflicts and managing shared resources on a larger scale. Similar to door integration, the basic requirement is that the lift controller accepts commands using a prescribed protocol, <code>OPC</code> is one such example.</p>
<p>The elevators will be integrated in a similar fashion as doors as well, relying on a lift node and a lift adapter. The following block diagram shows how each component works with each other:</p>
<img src="images/lifts_block_diagram.png">
<p>The lift node will act as a driver to work with the lift controller. An example of a lift node can be found in this <a href="https://github.com/sharp-rmf/kone_lift_controller">repository</a>. The node will publish its state and receive lift requests over ROS 2, using the messages and topics listed below.</p>
<div class="table-wrapper"><table><thead><tr><th>Message Types</th><th>ROS2 Topic</th><th>Description</th></tr></thead><tbody>
<tr><td><code>rmf_lift_msgs/LiftState</code></td><td><code>/lift_states</code></td><td>State of the lift published by the lift node</td></tr>
<tr><td><code>rmf_lift_msgs/LiftRequest</code></td><td><code>/lift_requests</code></td><td>Direct requests subscribed by the lift node and published by the lift adapter</td></tr>
<tr><td><code>rmf_lift_msgs/LiftRequest</code></td><td><code>/adapter_lift_requests</code></td><td>Requests to be sent to the lift adapter/supervisor to request safe operation of lifts</td></tr>
</tbody></table>
</div>
<p>A lift adapter subscribes to <code>lift_states</code> while keeping track of the internal and desired state of the lift in order to prevent it from performing any actions that might interrupt mobile robot or normal operations. The lift adapter performs this task by receiving lift requests from the fleet adapters and the RMF core systems and only relaying the instructions to the lift node if it is deemed appropriate. Any requests sent directly to the lift node, without going through the lift adapter, will also be negated by the lift adapter, to prevent unwanted disruption to mobile robot fleet operations.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/integration_lifts.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h2 id="workcells-1"><a class="header" href="#workcells-1">Workcells</a></h2>
<p>Currently RMF has 2 types of sample workcells, namely: <code>Dispenser</code> and <code>Ingestor</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Message Types</th><th>ROS2 Topic</th><th>Description</th></tr></thead><tbody>
<tr><td><code>rmf_dispenser_msgs/DispenserRequest</code></td><td><code>/dispenser_reqeusts</code></td><td>Direct requests subscribed by the dispenser node</td></tr>
<tr><td><code>rmf_dispenser_msgs/DispenserResult</code></td><td><code>/dispenser_results</code></td><td>Result of a dispenser request, published by the dispenser</td></tr>
<tr><td><code>rmf_dispenser_msgs/DispenserState</code></td><td><code>/dispenser_states</code></td><td>State of the dispenser published by the dispenser periodically</td></tr>
<tr><td><code>rmf_ingestor_msgs/IngestorRequest</code></td><td><code>/ingestor_requests</code></td><td>Direct requests subscribed by the ingestor node</td></tr>
<tr><td><code>rmf_ingestor_msgs/IngestorResult</code></td><td><code>/ingestor_results</code></td><td>Result of a ingestor request, published by the ingestor</td></tr>
<tr><td><code>rmf_ingestor_msgs/IngestorState</code></td><td><code>/ingestor_states</code></td><td>State of the dispenser published by the ingestor periodically</td></tr>
</tbody></table>
</div>
<p>In <code>rmf_demos</code> world, both <code>TeleportDispenser</code> and <code>TeleportIngestor</code> 
<a href="https://github.com/open-rmf/rmf_simulation/tree/main/rmf_robot_sim_gazebo_plugins/src">plugins</a> act as workcell adapter nodes.</p>
<p>Workcells currently work alongside with Delivery Task. In <code>fleet_adapter.lauch.xml</code>,
<code>perform_deliveries</code> needs to be <code>true</code> for the robot to accept a delivery task. </p>
<p>A Full Delivery:</p>
<ol>
<li>The robot will first move to the <code>pickup_waypoint</code></li>
<li>Requests a <code>DispenserRequest</code> till receives a <code>DispenserResult</code>. (Done Dispensing)</li>
<li>Continue delivery and moves to <code>dropoff_waypoint</code></li>
<li>Requests a <code>IngestorRequest</code> till receives a <code>IngestorResult</code>. (Done Ingesting)</li>
</ol>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/integration_workcells.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="rmf-web"><a class="header" href="#rmf-web">RMF Web</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>Rmf web is the web application side of RMF. It provides the user with a configurable front end dashboard, along with back end infrastructures.</p>
<p>For more information, please refer to the <code>rmf-web</code> repo.</p>
<p><img src="images/rmf-web-dashboard.png" alt="rmf dashboard" /></p>
<h1 id="related-repositories"><a class="header" href="#related-repositories">Related Repositories</a></h1>
<ul>
<li><a href="https://github.com/open-rmf/rmf-web">rmf-web</a></li>
<li><a href="https://github.com/open-rmf/rmf-web/tree/main/example-deployment">example deployment</a></li>
<li><a href="https://github.com/open-rmf/rmf-cloud-tools">rmf-cloud</a></li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/rmf-web.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="ui"><a class="header" href="#ui">UI</a></h1>
<blockquote>
<p>Certain portion of this doc is deprecated, please refer to <a href="https://github.com/open-rmf/rmf-web">rmf-web</a> for the latest development.</p>
</blockquote>
<h2 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h2>
<p>This chapter describes how we can write end user applications which integrate into RMF. We will briefly go through the requirements of an RMF UI application and provide a tutorial to write a React Webapp that interfaces with RMF.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>The most common way to write a UI application is to make use of a UI framework. There are many available UI frameworks, the following are some of the popular frameworks for reference:</p>
<ul>
<li>Multi-Paradigm
<ul>
<li>Qt</li>
<li>React native</li>
<li>Xamarin</li>
<li>Flutter</li>
</ul>
</li>
<li>Web
<ul>
<li>React</li>
<li>Angular</li>
<li>Vue</li>
</ul>
</li>
<li>Desktop
<ul>
<li>wxWidgets</li>
<li>Gtk</li>
<li>WPF (Windows only)</li>
</ul>
</li>
</ul>
<p>Each framework has pros and cons and we do not feel there is a &quot;best&quot; framework for all use cases. That being said, some frameworks are more suitable to integrate with RMF due to their specific underlying technologies. To understand why, let's take a brief overview at how an RMF UI application would work.</p>
<h2 id="how-does-an-rmf-ui-application-work"><a class="header" href="#how-does-an-rmf-ui-application-work">How Does an RMF UI Application Work?</a></h2>
<p>Imagine a simple UI application with a label that shows the current status of a door and a button that opens/closes the door. Recall that in the door adapter, we publish door states and subscribe to door requests. Here we are doing the reverse; subscribing to door states and publishing door requests. We will be listening to door states coming in from RMF and updating our display to match, and we will also be sending door requests when the user clicks the open or close button.</p>
<p>We need to use a libray to help us do that. In the hardware adapter examples we are using the <code>rclcpp</code> library, but <code>rclcpp</code> isn't the only way to use ROS 2. Here are some libraries that also work well</p>
<ul>
<li>Direct
<ul>
<li>rcl (C)</li>
<li>rclcpp (C++)</li>
<li>rclpy (python)</li>
<li>rclnodejs (nodejs)</li>
</ul>
</li>
<li>Indirect
<ul>
<li>SOSS (websocket)</li>
<li>rosbridge (websocket)</li>
</ul>
</li>
</ul>
<p>A &quot;direct&quot; library is able to send and receive ROS 2 messages directly from the application, in contrast, an indirect library uses a middleman service to forward ROS 2 messages. In general, the &quot;direct&quot; approach is more preferable but sometimes it is not possible on the target platform. In these cases, the indirect approach can be used.</p>
<div style="border: 1px; border-style: solid; padding: 1em">
<b>Note</b>: This is not an exhaustive list, you can find many third-party projects that aim to bring the ROS 2 ecosystem to more platforms, the <code>ros2-dotnet</code> project for example, provides C# bindings for ROS 2. You can also write your own bindings and middlewares!
</div>
<p>Writing an RMF UI application isn't much different from writing any other UI application, the only difference being that we will be sending/receiving ROS 2 data in response to user input and updating the UI's state.</p>
<h1 id="tutorial-react-webapp"><a class="header" href="#tutorial-react-webapp">Tutorial: React WebApp</a></h1>
<p>In this section, we will go through an example of creating a React-based webapp to monitor door states and send door open/close requests. The tutorial will focus on the aspects of communicating with RMF; basic knowledge of React and TypeScript is needed.</p>
<p>Note that this isn't the only way to create a RMF UI application, as mentioned before, you can use any UI toolkit, the only requirement is to be able to send/receive ROS 2 messages.</p>
<p>The code for this tutorial is available <a href="https://github.com/osrf/ros2multirobotbook/tree/master/src/react-app-tutorial">here</a>.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li>nodejs &gt;= 10</li>
<li><a href="https://github.com/osrf/rmf_core">rmf_core</a></li>
<li><a href="https://github.com/osrf/soss">soss</a></li>
<li><a href="https://github.com/osrf/rmf-soss-ros2">rmf-soss-ros2</a></li>
<li><a href="https://github.com/osrf/rmf_demos">rmf_demos</a></li>
</ul>
<p>We will not go through the process of setting up the dependencies, instructions to set them up can be easily found on the web or from their project homepages.</p>
<h2 id="setting-up"><a class="header" href="#setting-up">Setting Up</a></h2>
<p>We will be using an example from <code>rmf_demo</code> as the RMF deployment that we will be interacting with. This is a good time to test if your installation of <code>rmf_demo</code> is working properly, start the demo with the following command:</p>
<pre><code>ros2 launch demos office.launch.xml
</code></pre>
<p>Next let's test if SOSS is working. In order to run SOSS, you need to provide it with a configuration file; you can use <a href="ui-resources/soss.yaml">this</a> template as a start. You would need a certificate for SOSS; refer to various tutorials online to generate one. If you are using a self-signed cert, also make sure your browser is set to accept it for websocket connections. Add the path of your cert and key to the SOSS config and try starting SOSS with:</p>
<pre><code>soss &lt;path_to_config&gt;
</code></pre>
<p>Once the environment is set up, we can then proceed to set up our actual app. First, create a React workspace with:</p>
<pre><code>npx create-react-app react-app-tutorial --template typescript
</code></pre>
<p>Go inside the newly created <code>react-app-tutorial</code> directory and run the following command to install all the JavaScript dependencies we will be using:</p>
<pre><code>npm install @osrf/romi-js-core-interfaces @osrf/romi-js-soss-transport jsonwebtoken @types/jsonwebtoken
</code></pre>
<p>These libraries are not strictly required but they contain helpful functions to use <code>soss</code> and to communicate with RMF. If you are building a JavaScript-based RMF app, it is recommended to make use of them, we will see later how they simplify the communication to RMF.</p>
<div style="border: 1px; border-style: solid; padding: 1em">
<b>Note</b>: Other than <code>@osrf/romi-js-soss-transport</code>, there is also <code>@osrf/romi-js-rclnodejs-transport</code> which is able to send ROS 2 messages directly, however it does not work on the browser. It is preferred if you are writing a Node.js based desktop application using something like Electron, or you are writing a server based application like a REST API provider.
</div>
<h2 id="door-component"><a class="header" href="#door-component">Door Component</a></h2>
<p>First of all, let's start things simple by creating a component to show a door's state along with open and close buttons. Create a new file called <code>Door.tsx</code> in <code>react-app-tutorial/src</code> directory and copy the below snippet into it.</p>
<pre><code class="language-js">import React from 'react';

export interface DoorProps {
  name: string;
  state: string;
  onOpenClick?(e: React.MouseEvent): void;
  onCloseClick?(e: React.MouseEvent): void;
}

export const Door = (props: DoorProps) =&gt; {
  const { name, state, onOpenClick, onCloseClick } = props;
  return (
    &lt;div&gt;
      Door: {name}
      &lt;br /&gt;
      State: {state}
      &lt;br /&gt;
      &lt;button onClick={(e) =&gt; onOpenClick &amp;&amp; onOpenClick(e)}&gt;Open&lt;/button&gt;
      &lt;button onClick={(e) =&gt; onCloseClick &amp;&amp; onCloseClick(e)}&gt;Close&lt;/button&gt;
      &lt;br /&gt;
      &lt;br /&gt;
    &lt;/div&gt;
  );
};

export default Door;
</code></pre>
<p>Nothing much is happening here yet. We are simply rendering the door name, its state and open and a close button.</p>
<p>Let's test things out by running it. Replace <code>App.tsx</code> with this:</p>
<pre><code class="language-js">import React from 'react';
import Door from './Door';

function App() {
  return &lt;Door name=&quot;example_door&quot; state=&quot;Closed&quot; /&gt;;
}

export default App;
</code></pre>
<p>and start it with <code>npm start</code>. You should see something like this:</p>
<p><img src="ui-resources/door.png" alt="Door" /></p>
<p>Great! We now have a base to start implementing the rest of the app.</p>
<h2 id="obtain-list-of-doors"><a class="header" href="#obtain-list-of-doors">Obtain List of Doors</a></h2>
<p>Previously we made a simple door component and tested rendering it with hard-coded values. Obviously this won't work in a proper app, so here we will look at how we can obtain the list of actual doors from RMF.</p>
<p>Start of by adding a React state to track the list of doors:</p>
<pre><code class="language-js">const [doors, setDoors] = React.useState&lt;RomiCore.Door[]&gt;([]);
</code></pre>
<p>RMF has a <code>get_building_map</code> service that we can use to get the list of doors, lifts, levels among many other data, in order to make use of the service we need to do a ROS 2 service call, since there isn't ROS 2 support on the browser, we will be using an &quot;indirect&quot; approach with <code>soss</code>. A websocket connection is made to SOSS which will then act as a middleman and pass our messages to the ROS 2 network.</p>
<p>An easy way to use SOSS is with the <code>@osrf/romi-js-soss-transport</code> package, so let's do it now. Add a react effect hook to your <code>App</code> component</p>
<pre><code class="language-js">  React.useEffect(() =&gt; {
    (async () =&gt; {
      const token = jwt.sign({ user: 'example-user' }, 'rmf', { algorithm: 'HS256' });
      const transport = await SossTransport.connect('example', 'wss://localhost:50001', token);
    })();
  }, []);
</code></pre>
<p>We will need to import <code>SossTransport</code>, so add this to the top of the file:</p>
<pre><code class="language-js">import { SossTransport } from '@osrf/romi-js-soss-transport';
</code></pre>
<p>This performs a websocket connection to the SOSS server. <code>example</code> is the ROS 2 node name that we will be using, and we are connecting to a SOSS server at <code>wss://localhost:50001</code>. The server uses a JWT token signed with a secret specified in the SOSS config. The example config is using <code>rmf</code>. If you changed the secret, be sure to change it here as well.</p>
<div style="border: 1px; border-style: solid; padding: 1em">
<b>Note</b>: This example is only for convenience, you should never reveal the secret to the client. Usually the client would connect to an authentication server which will verify that it is a valid request and return a signed token.
</div>
<p>Now that we have a connection to SOSS, we can call the <code>get_building_map</code> service. Add this to the React effect:</p>
<pre><code class="language-js">const buildingMap = (await transport.call(RomiCore.getBuildingMap, {})).building_map;
setDoors(buildingMap.levels.flatMap((level) =&gt; level.doors));
</code></pre>
<p>It uses <code>RomiCore</code>, so add this to your imports:</p>
<pre><code class="language-js">import * as RomiCore from '@osrf/romi-js-core-interfaces';
</code></pre>
<p>This downloads and parses the building map from RMF. <code>romi-js</code> simplifies a ROS 2 service call with the async <code>call</code> method. If you are familiar with <code>rclnodejs</code>, this is roughly equivalent to:</p>
<pre><code class="language-js">const client = node.createClient(
  'building_map_msgs/srv/GetBuildingMap',
  'get_building_map'
);
client.sendRequest({}, response =&gt; {
  const buildingMap = response.building_map;
  setDoors(buildingMap.levels.flatMap((level) =&gt; level.doors));
});
</code></pre>
<p>Notice that we need to provide it with type of the message (<code>building_map_msgs/srv/GetBuildingMap</code>) and the name of the service (<code>get_building_map</code>), but how do we find out what the service name and type are? We could read the RMF manual or query the ROS 2 system while RMF is running. Another way is with the help of <code>RomiCore</code>; it provides a list of known RMF services and messages so you don't have to go through the trouble of finding them yourself.</p>
<p>In the below statement, we are using <code>RomiCore</code> to call the <code>get_building_map</code> service without needing to know the service name and types:</p>
<pre><code class="language-js">transport.call(RomiCore.getBuildingMap, {})
</code></pre>
<p>Now that we have a list of <code>RomiCore.Door</code>, let's make things simpler by updating <code>Door.tsx</code> to take that in as a prop. While we're at it, let's also have it take in a <code>RomiCore.DoorState</code> as a prop since we will be using it later.</p>
<p>Door.tsx:</p>
<pre><code class="language-js">import * as RomiCore from '@osrf/romi-js-core-interfaces';
import React from 'react';

export interface DoorProps {
  door: RomiCore.Door;
  doorState?: RomiCore.DoorState;
  onOpenClick?(e: React.MouseEvent): void;
  onCloseClick?(e: React.MouseEvent): void;
}

export const Door = (props: DoorProps) =&gt; {
  const { door, doorState, onOpenClick, onCloseClick } = props;
  return (
    &lt;div&gt;
      Door: {door.name}
      &lt;br /&gt;
      State: {doorState ? doorState.current_mode.value : 'Unknown'}
      &lt;br /&gt;
      &lt;button onClick={(e) =&gt; onOpenClick &amp;&amp; onOpenClick(e)}&gt;Open&lt;/button&gt;
      &lt;button onClick={(e) =&gt; onCloseClick &amp;&amp; onCloseClick(e)}&gt;Close&lt;/button&gt;
      &lt;br /&gt;
      &lt;br /&gt;
    &lt;/div&gt;
  );
};

export default Door;
</code></pre>
<p>Now we can test it by passing the doors as props. Your <code>App.tsx</code> component should now look like this:</p>
<pre><code class="language-js">import * as RomiCore from '@osrf/romi-js-core-interfaces';
import { SossTransport } from '@osrf/romi-js-soss-transport';
import * as jwt from 'jsonwebtoken';
import React from 'react';
import Door from './Door';

function App() {
  const [doors, setDoors] = React.useState&lt;RomiCore.Door[]&gt;([]);

  React.useEffect(() =&gt; {
    (async () =&gt; {
      const token = jwt.sign({ user: 'example-user' }, 'rmf', { algorithm: 'HS256' });
      const transport = await SossTransport.connect('example', 'wss://localhost:50001', token);
      const buildingMap = (await transport.call(RomiCore.getBuildingMap, {})).building_map;
      setDoors(buildingMap.levels.flatMap((level) =&gt; level.doors));
    })();
  }, []);

  return (
    &lt;React.Fragment&gt;
      {doors.map((door) =&gt; (
        &lt;Door door={door} /&gt;
      ))}
    &lt;/React.Fragment&gt;
  );
}

export default App;
</code></pre>
<p>Don't worry about the door state for now. If everything goes well, you should see 3 doors that are in the building listed:</p>
<p><img src="ui-resources/building-map-doors.png" alt="Doors" /></p>
<h2 id="listening-for-door-states"><a class="header" href="#listening-for-door-states">Listening for Door States</a></h2>
<p>Previously we managed to render the list of doors in the RMF system, but the building map doesn't tell us the doors' states, so let's fix that. First, let's add a React state to track the door states:</p>
<pre><code class="language-js">const [doorStates, setDoorStates] = React.useState&lt;Record&lt;string, RomiCore.DoorState&gt;&gt;({});
</code></pre>
<p>The door states can be obtained by subscribing to the <code>door_states</code> topic. Add the following to your effect:</p>
<pre><code class="language-js">transport.subscribe(RomiCore.doorStates, (doorState) =&gt;
  setDoorStates((prev) =&gt; ({ ...prev, [doorState.door_name]: doorState })),
);
</code></pre>
<p>This performs a ROS 2 subscription to the <code>RomiCore.doorStates</code> topic. Similar to the service call we did earlier, <code>romi-js</code> abstracts away the ROS 2 topic name and provides type information. The callback will be fired each time a new door state message comes in. In the callback, we simply update the <code>doorStates</code> state.</p>
<p>Now just pass the door state to the door component:</p>
<pre><code class="language-js">&lt;Door door={door} doorState={doorStates[door.name]} /&gt;
</code></pre>
<p>The end result of your <code>App.tsx</code> should look like this:</p>
<pre><code class="language-js">import * as RomiCore from '@osrf/romi-js-core-interfaces';
import { SossTransport } from '@osrf/romi-js-soss-transport';
import * as jwt from 'jsonwebtoken';
import React from 'react';
import Door from './Door';

function App() {
  const [doors, setDoors] = React.useState&lt;RomiCore.Door[]&gt;([]);
  const [doorStates, setDoorStates] = React.useState&lt;Record&lt;string, RomiCore.DoorState&gt;&gt;({});

  React.useEffect(() =&gt; {
    (async () =&gt; {
      const token = jwt.sign({ user: 'example-user' }, 'rmf', { algorithm: 'HS256' });
      const transport = await SossTransport.connect('example', 'wss://localhost:50001', token);
      const buildingMap = (await transport.call(RomiCore.getBuildingMap, {})).building_map;
      setDoors(buildingMap.levels.flatMap((level) =&gt; level.doors));

      transport.subscribe(RomiCore.doorStates, (doorState) =&gt;
        setDoorStates((prev) =&gt; ({ ...prev, [doorState.door_name]: doorState })),
      );
    })();
  }, []);

  return (
    &lt;React.Fragment&gt;
      {doors.map((door) =&gt; (
        &lt;Door door={door} doorState={doorStates[door.name]} /&gt;
      ))}
    &lt;/React.Fragment&gt;
  );
}

export default App;
</code></pre>
<p>And just like that we now have the door states!</p>
<p><img src="ui-resources/with-door-states-number.png" alt="With door states" /></p>
<p>The door states are numbers like <code>0</code>, <code>1</code> and <code>2</code>. This is because RMF uses a constant to represent door states. We could run a simple function to convert these constants into strings:</p>
<pre><code class="language-js">function doorModeString(doorMode: RomiCore.DoorMode): string {
  switch (doorMode.value) {
    case 2:
      return 'Open';
    case 0:
      return 'Closed';
    case 1:
      return 'Moving';
    default:
      return 'Unknown';
  }
}
</code></pre>
<p>But how do we know <code>2</code> means &quot;Open&quot; etc? We can find out by reading the RMF manual or inspecting the ROS 2 message definitions, but we can do better with <code>RomiCore</code>. It provides the list of constants in a more readable form:</p>
<pre><code class="language-js">function doorModeString(doorMode: RomiCore.DoorMode): string {
  switch (doorMode.value) {
    case RomiCore.DoorMode.MODE_OPEN:
      return 'Open';
    case RomiCore.DoorMode.MODE_CLOSED:
      return 'Closed';
    case RomiCore.DoorMode.MODE_MOVING:
      return 'Moving';
    default:
      return 'Unknown';
  }
}
</code></pre>
<p>With this it's obvious what each constant represents so we don't have to refer to anything else to find its meaning.</p>
<p>Go ahead and add this to your <code>Door.tsx</code>. It should look like this now:</p>
<pre><code class="language-js">import * as RomiCore from '@osrf/romi-js-core-interfaces';
import React from 'react';

export interface DoorProps {
  door: RomiCore.Door;
  doorState?: RomiCore.DoorState;
  onOpenClick?(e: React.MouseEvent): void;
  onCloseClick?(e: React.MouseEvent): void;
}

export const Door = (props: DoorProps) =&gt; {
  const { door, doorState, onOpenClick, onCloseClick } = props;
  const modeString = doorState ? doorModeString(doorState.current_mode) : 'Unknown';
  return (
    &lt;div&gt;
      Door: {door.name}
      &lt;br /&gt;
      State: {modeString}
      &lt;br /&gt;
      &lt;button onClick={(e) =&gt; onOpenClick &amp;&amp; onOpenClick(e)}&gt;Open&lt;/button&gt;
      &lt;button onClick={(e) =&gt; onCloseClick &amp;&amp; onCloseClick(e)}&gt;Close&lt;/button&gt;
      &lt;br /&gt;
      &lt;br /&gt;
    &lt;/div&gt;
  );
};

function doorModeString(doorMode: RomiCore.DoorMode): string {
  switch (doorMode.value) {
    case RomiCore.DoorMode.MODE_OPEN:
      return 'Open';
    case RomiCore.DoorMode.MODE_CLOSED:
      return 'Closed';
    case RomiCore.DoorMode.MODE_MOVING:
      return 'Moving';
    default:
      return 'Unknown';
  }
}

export default Door;
</code></pre>
<p>Great! Now we have readable door states instead of cryptic numbers.</p>
<p><img src="ui-resources/with-door-states.png" alt="With door states" /></p>
<h2 id="sending-door-requests"><a class="header" href="#sending-door-requests">Sending Door Requests</a></h2>
<p>As you may have expected by now, all we have to do here is to send door requests to RMF.</p>
<p>First, create a publisher. Add this to the start of the render function:</p>
<pre><code class="language-js">const doorRequestPub = React.useRef&lt;RomiCore.Publisher&lt;RomiCore.DoorRequest&gt; | null&gt;(null);
</code></pre>
<p>Then add this helper function:</p>
<pre><code class="language-js">const requestDoor = (door: RomiCore.Door, mode: number) =&gt; {
  if (doorRequestPub.current) {
    const request: RomiCore.DoorRequest = {
      door_name: door.name,
      request_time: RomiCore.toRosTime(new Date()),
      requested_mode: { value: mode },
      requester_id: 'example-request',
    };
    doorRequestPub.current.publish(request);
  }
};
</code></pre>
<p>It takes in a <code>RomiCore.Door</code> and a number representing the desired mode, and crafts a <code>RomiCore.DoorRequest</code> message and sends it using the publisher. Normally you would have to consult the RMF manual or the ROS 2 definitions to know exactly what you need to send. Again, <code>RomiCore</code> provides the typing information to make it easier to fill in the required fields.</p>
<p>Finally, add this to the props passed to the door component:</p>
<pre><code class="language-js">onOpenClick={() =&gt; requestDoor(door, RomiCore.DoorMode.MODE_OPEN)}
onCloseClick={() =&gt; requestDoor(door, RomiCore.DoorMode.MODE_CLOSED)}
</code></pre>
<p>Your final <code>App.tsx</code> should look like this:</p>
<pre><code class="language-js">import * as RomiCore from '@osrf/romi-js-core-interfaces';
import { SossTransport } from '@osrf/romi-js-soss-transport';
import * as jwt from 'jsonwebtoken';
import React from 'react';
import Door from './Door';

function App() {
  const [doors, setDoors] = React.useState&lt;RomiCore.Door[]&gt;([]);
  const [doorStates, setDoorStates] = React.useState&lt;Record&lt;string, RomiCore.DoorState&gt;&gt;({});
  const doorRequestPub = React.useRef&lt;RomiCore.Publisher&lt;RomiCore.DoorRequest&gt; | null&gt;(null);

  React.useEffect(() =&gt; {
    (async () =&gt; {
      const token = jwt.sign({ user: 'example-user' }, 'rmf', { algorithm: 'HS256' });
      const transport = await SossTransport.connect('example', 'wss://localhost:50001', token);
      const buildingMap = (await transport.call(RomiCore.getBuildingMap, {})).building_map;
      setDoors(buildingMap.levels.flatMap((level) =&gt; level.doors));

      transport.subscribe(RomiCore.doorStates, (doorState) =&gt;
        setDoorStates((prev) =&gt; ({ ...prev, [doorState.door_name]: doorState })),
      );

      doorRequestPub.current = transport.createPublisher(RomiCore.adapterDoorRequests);
    })();
  }, []);

  const requestDoor = (door: RomiCore.Door, mode: number) =&gt; {
    if (doorRequestPub.current) {
      const request: RomiCore.DoorRequest = {
        door_name: door.name,
        request_time: RomiCore.toRosTime(new Date()),
        requested_mode: { value: mode },
        requester_id: 'example-request',
      };
      doorRequestPub.current.publish(request);
    }
  };

  return (
    &lt;React.Fragment&gt;
      {doors.map((door) =&gt; (
        &lt;Door
          door={door}
          doorState={doorStates[door.name]}
          onOpenClick={() =&gt; requestDoor(door, RomiCore.DoorMode.MODE_OPEN)}
          onCloseClick={() =&gt; requestDoor(door, RomiCore.DoorMode.MODE_CLOSED)}
        /&gt;
      ))}
    &lt;/React.Fragment&gt;
  );
}

export default App;
</code></pre>
<p>Try clicking on the open and close buttons now. You should see the door state being updated. You can also see the door opening/closing in Gazebo.
Congratulations, you have just written a simple RMF UI application! Obviously the design leaves much to be desired as we didn't do any CSS styling but that is outside the scope of this tutorial.</p>
<p>Extending this to provide more features like lift control, fleet states, etc. follows the same principle. All the available topics and services exposed by RMF are available in <code>RomiCore</code> and you can find more detailed information by reading the rest of the manual. This also extends to writing UI applications for other platforms and frameworks; at the core you are really just publishing and subscribing to ROS 2 messages so you can apply the same principles to other languages and frameworks.</p>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p>We have just created a minimal RMF UI application that reports the door state and allows a user to control the door. For simplicity, there aren't many features included but this tutorial should provide the basic knowledge of how to create an RMF UI application not only in React but also in any framework that you like.</p>
<p>If you would like more examples of a React RMF application, you can take a look at the official <a href="https://github.com/osrf/romi-dashboard">RoMi dashboard</a>.</p>
<h2 id="extra-extending-romi-js"><a class="header" href="#extra-extending-romi-js">Extra: Extending romi-js</a></h2>
<p>Throughout the tutorial, we used <code>romi-js</code> to simplify the communication to RMF. As you might have noticed <code>romi-js</code> is actually a collection of packages. This design makes it possible to easily extend it with new topics, services and even transports.</p>
<h3 id="adding-topics-and-services"><a class="header" href="#adding-topics-and-services">Adding Topics and Services</a></h3>
<p>Topics and services are defined by the interfaces:</p>
<pre><code class="language-js">export interface RomiTopic&lt;Message&gt; {
  readonly validate: (msg: any) =&gt; Message;
  readonly type: string;
  readonly topic: string;
  readonly options?: Options;
}

export interface RomiService&lt;Request, Response&gt; {
  readonly validateRequest: (msg: any) =&gt; Request;
  readonly validateResponse: (msg: any) =&gt; Response;
  readonly type: string;
  readonly service: string;
  readonly options?: Options;
}
</code></pre>
<p>If you are familiar with ROS 2, the <code>type</code> field specifies the message type that the topic or service expects while <code>topic</code>/<code>service</code> are the topic and service names, respectively. Sometimes a topic or service is expected to use a different QoS option; for example a topic that does not publish when the state changes and expects late subscriptions to make use of transient local QoS to receive the latest state. The <code>options</code> specify the &quot;default&quot; QoS options that should be used. In this way, users do not have to refer to the usage instructions to correctly publish and subscribe to the topic.</p>
<p>The <code>validate*</code> methods are used by the transport to convert an arbitrary object to the expected type of the topic or service. It should check if the object has the correct fields and that the fields are of the correct types. To ensure compatibility with different transports, these methods should be able to convert number arrays to typed arrays and vice versa.</p>
<p>We can create custom topics or services by implementing these interfaces. They can then be passed to the transport's various methods.</p>
<pre><code class="language-js">export const myTopic: RomiTopic&lt;MyMessage&gt; = {
  validate: validateMyMessage(msg), // some function that valides MyMessage
  type: 'my_messages/msg/MyMessage',
  topic: 'my_topic',
};
</code></pre>
<h3 id="adding-transport"><a class="header" href="#adding-transport">Adding Transport</a></h3>
<p>A <code>Transport</code> in <code>romi-js</code> is a class with the interface:</p>
<pre><code class="language-js">export interface Subscription {
  unsubscribe(): void;
}

export interface Publisher&lt;Message&gt; {
  publish(msg: Message): void;
}

export interface Service&lt;Request, Response&gt; {
  start(handler: (req: Request) =&gt; Promise&lt;Response&gt; | Response): void;
  stop(): void;
}

export interface Transport extends TransportEvents {
  readonly name: string;

  createPublisher&lt;Message extends unknown&gt;(
    topic: RomiTopic&lt;Message&gt;,
    options?: Options,
  ): Publisher&lt;Message&gt;;

  subscribe&lt;Message extends unknown&gt;(
    topic: RomiTopic&lt;Message&gt;,
    cb: SubscriptionCb&lt;Message&gt;,
    options?: Options,
  ): Subscription;

  call&lt;Request extends unknown, Response extends unknown&gt;(
    service: RomiService&lt;Request, Response&gt;,
    req: Request,
  ): Promise&lt;Response&gt;;

  createService&lt;Request extends unknown, Response extends unknown&gt;(
    service: RomiService&lt;Request, Response&gt;,
  ): Service&lt;Request, Response&gt;;

  destroy(): void;
}
</code></pre>
<p>There isn't a general guide on how the interface should be implemented since the details would be different for each transport. One thing to note is that it might be tempting to return a type derived from <code>any</code> (e.g. <code>Publisher&lt;any&gt;</code>) to pass the typescript checks but doing so is not recommended. You should call the <code>validate*</code> methods in the topic or service to convert something into a type of <code>Message</code>.</p>
<p>To ensure compatibility with different topics and services, transports must de-serialize the data to a plain old data object. It can use either number arrays or typed arrays. The <code>validate*</code> methods should support converting them to the expected types.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/ui.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="security"><a class="header" href="#security">Security</a></h1>
<p>This chapter describes how to use DDS Security tools to provide authentication,
encryption, and access control to an RMF system. </p>
<p>The security of the RMF system can be divided into two main parts: 
its ROS 2 elements and the dashboard. The security of the ROS 2 
elements is provided by the DDS security tools which help ensure authentication, 
encryption and access control. The dashboard provides the user with an 
instruments panel while ensuring encryption, integrity and authentication of 
the connection to the server through TLS. User authentication and access control 
is made by user/password checking against a database and then 
providing that user with access to the secured ROS 2 network at a level that
corresponds to the role of that user.</p>
<p><img src="images/security/system_infrastructure.png" alt="Security System Infrastructure" /></p>
<p>The <a href="https://github.com/open-rmf/rmf_demos#office-world">RMF Demos Office World</a> repository contains an example of a 
full RMF application using secured ROS 2 communications along with
step by step explanations. </p>
<h2 id="ros-2-security-1"><a class="header" href="#ros-2-security-1">ROS 2 Security</a></h2>
<p>ROS 2 contains tools that help create and load the needed security artifacts 
to enable DDS-security. RMF makes uses of these tools in order to enable 
security on its ROS 2 elements. A brief introduction to these tools and its 
usage is provided here. For a deeper understanding of the whole system, 
please refer to the <a href="https://design.ros2.org/articles/ros2_dds_security.html">ROS 2 DDS-Security integration</a> documentation.</p>
<h3 id="dds-security-overview"><a class="header" href="#dds-security-overview">DDS-Security overview</a></h3>
<p>The <a href="https://www.omg.org/spec/DDS-SECURITY/1.1/PDF">DDS-Security specification</a> expands upon the <a href="https://www.omg.org/spec/DDS/1.4/PDF">DDS specification</a>, 
adding security enhancements by defining a Service Plugin Interface (SPI) 
architecture, a set of builtin implementations of the SPIs, and the security model enforced by the SPIs.
Specifically, there are five SPIs defined:</p>
<ul>
<li><strong>Authentication</strong>: Verify the identity of a given domain participant.</li>
<li><strong>Access control</strong>: Enforce restrictions on the DDS-related operations that can be 
performed by an authenticated domain participant.</li>
<li><strong>Cryptographic</strong>: Handle all required encryption, signing, and hashing operations.</li>
<li><strong>Logging</strong>: Provide the ability to audit DDS-Security-related events.</li>
<li><strong>Data tagging</strong>: Provide the ability to add tags to data samples.</li>
</ul>
<p>ROS 2's security features currently utilize only the first three.
This is due to the fact that neither <strong>Logging</strong> nor <strong>Data Tagging</strong> 
are required in order to be compliant with the <a href="https://www.omg.org/spec/DDS-SECURITY/1.1/PDF">DDS-Security spec</a> 
(see section 2.3), and thus not all DDS implementations support them.</p>
<h3 id="sros-2-tools"><a class="header" href="#sros-2-tools">SROS 2 tools</a></h3>
<p>Since the DDS-Security plugins require a set of security files per domain participant, these 
need to be created beforehand in order to provide authentication, access control and encryption
to the ROS 2 elements of RMF. Domain participants usually map to a context within the 
process in ROS 2, therefore each process will require a set of these files.</p>
<p>Since SROS 2 has no support for launch files yet, each binary needs to be launched separately
on its own terminal. Alternatively we recommend the creation of scripts to automate this process. 
An example of this is the <code>tmux</code> script used in the [Office SROS 2 demo][https://github.com/open-rmf/rmf_demos/blob/main/docs/secure_office_world.md].</p>
<p>The <code>ros2 security</code> command is the way to access the SROS 2 set of tools to create and manage
your DDS-security artifacts. You can get a glimpse at its features by accessing the documentation
through the <code>-h</code> flag:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 security -h
usage: ros2 security [-h] Call `ros2 security &lt;command&gt; -h` for more detailed usage. ...

Various security related sub-commands

optional arguments:
  -h, --help            show this help message and exit

Commands:
  create_key          Create key
  create_keystore     Create keystore
  create_permission   Create permission
  generate_artifacts  Generate keys and permission files from a list of identities and policy files
  generate_policy     Generate XML policy file from ROS graph data
  list_keys           List keys

  Call \`ros2 security &lt;command&gt; -h\` for more detailed usage.
</code></pre>
<h4 id="sros-2-environment-variables"><a class="header" href="#sros-2-environment-variables">SROS 2 environment variables</a></h4>
<p>There are a few environment variables you should be aware of when using SROS 2: </p>
<ul>
<li><strong>ROS_SECURITY_ENABLE</strong> is the SROS 2 enabler variable, it takes a boolean value 
(true or false) and indicates if the security is enabled or not. </li>
<li><strong>ROS_SECURITY_STRATEGY</strong> can be set to <code>Enforce</code> or <code>Permissive</code>, with the first one it 
will fail to run a participant if the security files are not found, whereas with the second one will 
just run the participant in non secure mode if those files are not found. </li>
<li><strong>ROS_SECURITY_KEYSTORE</strong> should point to the root of the keystore directory tree. This will help <code>RCL</code>
find the location of the security artifacts to initialize the ROS 2 security environment.</li>
</ul>
<h4 id="sros-2-security-keystore"><a class="header" href="#sros-2-security-keystore">SROS 2 security keystore</a></h4>
<p>The keystore is the root directory where the DDS security artifacts are stored. <code>RCL</code> will use the 
contents of this directory to provide the DDS security to the ROS 2 network. The 
<code>ROS_SECURITY_KEYSTORE</code> environment variable should by convention point to this directory. In order 
to initalize and populate <code>keystore_storage</code> directory files the following command can be used:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 security create_keystore keystore_storage
creating keystore: keystore_storage
creating new CA key/cert pair
creating governance file: keystore_storage/enclaves/governance.xml
creating signed governance file: keystore_storage/enclaves/governance.p7s
</code></pre>
<p>After creating the keystore, its initial structure would look like this:</p>
<pre><code>keystore_storage
├── enclaves
|   ├── governance.p7s
|   └── governance.xml
├── private
|   ├── ca.key.pem
|   ├── identity_ca.key.pem
|   └── permissions_ca.key.pem
└── public
    ├── ca.key.pem
    ├── identity_ca.key.pem
    └── permissions_ca.key.pem
</code></pre>
<p>The <code>public</code> directory contains anything permissible as public, such as public certificates for 
the identity or permissions Certificate Authorities (CA). As such, this can be given read access to all 
executables. Note that in the default case, both <code>identity_ca</code> and <code>permissions_ca</code> point to the 
same CA certificate.</p>
<p>The <code>private</code> directory contains anything permissible as private, such as private key material for 
aforementioned certificate authorities. This directory should be removed before deploying the 
keystore onto the target device/robot.</p>
<p>The <code>enclaves</code> directory contains the security artifacts associated with individual security enclaves. 
SROS 2 introduces the concept of a security “enclave”, 
where an “enclave” is a process or group of processes that will share the same identity and access 
control rules. The enclaves folder may recursively nest sub-paths for organizing separate enclaves. </p>
<h4 id="sros-2-enclave-keys"><a class="header" href="#sros-2-enclave-keys">SROS 2 enclave keys</a></h4>
<p>Once the <code>keystore</code> has been initialized you may wish to create the security keys for your 
enclaves. This will populate the <code>enclaves</code> directory with the necessary keys and governance
files. As an example, in order to create the security files for our<code>/hospital/rviz</code> enclave the
following command would be issued:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 security create_key keystore_storage /hospital/rviz
creating key for identity: '/hospital/rviz'
creating cert and key
creating permission
</code></pre>
<p>After this, they <code>keystore_storage</code> directory should contain the rviz enclave:</p>
<pre><code>keystore_storage
├── enclaves
|   ├── governance.p7s
|   ├── governance.xml
│   └── hospital
|       ├── rviz
│       |   ├── cert.pem
│       |   ├── key.pem
│       |   ├── governance.p7s
|       |   ├── identity_ca_cert.pem
|       |   ├── permissions_ca.cert.pem
|       |   ├── permissions.p7s
|       |   └── permissions.xml
...     ... 
</code></pre>
<p>Now there is an enclave containing the following files:</p>
<ul>
<li><strong>identity_ca.cert.pem</strong>: The x.509 certificate of the CA trusted by the <strong>Authentication</strong> plugin 
(the &quot;Identity&quot; CA).</li>
<li><strong>cert.pem</strong>: The x.509 certificate of this enclave instance (signed by the Identity CA).</li>
<li><strong>key.pem</strong>: The private key of this enclave instance.</li>
<li><strong>permissions_ca.cert.pem</strong>: The x.509 certificate of the CA trusted by the <strong>Access control</strong> plugin 
(the &quot;Permissions&quot; CA).</li>
<li><strong>governance.p7s</strong>: The XML document that specifies to the <strong>Access control</strong> plugin how the domain 
should be secured  (signed by the Permissions CA).</li>
<li><strong>permissions.p7s</strong>: The XML document that specifies the permissions of this particular enclave 
instance to the <strong>Access control</strong> plugin (also signed by the Permissions CA).</li>
</ul>
<h4 id="sros-2-access-control"><a class="header" href="#sros-2-access-control">SROS 2 access control</a></h4>
<p>In order to provide access control the security permissions need to be added to the permissions files
of the enclave and signed by the CA. In order to do this a policy file following the
<a href="https://design.ros2.org/articles/ros2_access_control_policies.html">SROS 2 policy schema</a> is needed. 
This file specifies the permissions awarded to the enclave within the ROS 2 network.
To create and sign the permissions the <code>create_permission</code> option can be used:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 security create_permission keystore_storage /hospital/rviz policy.xml 
creating permission file for identity: '/hospital/rviz'
creating permission
</code></pre>
<p>After running this command, the <code>permissions.p7s</code> and <code>permissions.xml</code> files for the 
<code>enclave</code> /hospital/rviz will contain the signed permissions specified in policy.xml. 
We will have to specify this enclave through rosargs when starting our process:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 run &lt;package&gt; &lt;executable&gt; --rosargs ---enclave /hospital/rviz
</code></pre>
<h1 id="sros-2-automated-generation"><a class="header" href="#sros-2-automated-generation">SROS 2 automated generation</a></h1>
<p>The process of generating keys and permissions can be sometimes tedious, so SROS 2 provides tools 
to automate this process. An automated way to generate the policy is provided, it can be
triggered by running the following command:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 security generate_policy policy.xml
</code></pre>
<p>This command will take the ROS graph at the point of running and generate the policy.xml file 
that corresponds to it. Note that this, as it only uses the current ROS graph as a source of 
information, might still miss policies for future publishers, subscribers, services or others.</p>
<p>The process and key and permissions generation can also be troublesome, SROS 2 provides a 
command that you can use to generate all of them at once:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 security generate_artifacts -k keystore_storage -p policy.xml
keystore_storage is not a valid keystore, creating new keystore
creating keystore: keystore_storage
creating new CA key/cert pair
creating governance file: keystore_storage/enclaves/governance.xml
creating signed governance file: keystore_storage/enclaves/governance.p7s
all done! enjoy your keystore in keystore_storage
cheers!
creating key for identity: '/hosptial/rviz'
creating cert and key
creating permission
creating permission file for identity: '/hosptical/rviz'
creating permission
...
</code></pre>
<p>Finally SROS 2 also provides a way to easily list the keys of a certain keystorage:</p>
<pre><code class="language-{.sourceCode .bash}">$ ros2 security list_keys keystore_storage
/hospital/building_map_server
/hopsital/building_systems_visualizer
/hospital/door_supervisor
/hospital/fleet_state_visualizer
/hosptial/loop_request_publisher
/hosptial/rviz2
...
</code></pre>
<h2 id="rmf-web-dashboard-security"><a class="header" href="#rmf-web-dashboard-security">RMF Web Dashboard Security</a></h2>
<p>[RMF Web] (https://github.com/open-rmf/rmf-web) is a web application that provides overall visualization and control over the 
RMF system. It is served over TLS to ensure encryption, integrity and authentication of the 
communication with the final user. The server uses <a href="https://openid.net/connect/">openid-connect (OIDC)</a> for 
authentication, an open standard based on <a href="https://oauth.net/2/">oauth 2.0</a> and <a href="https://jose.readthedocs.io/en/latest/">JOSE</a>. Currently the 
dashboard makes use of <a href="https://www.keycloak.org">Keycloack</a>, an open source implementation of OIDC. It provides 
an user management system, which is used to create/delete users. Each user gets assigned a role 
which is reflected on an id token generated on the user. This id token is signed securely 
and sent to the api server which it can then look at the role of the user and act accordingly.
The api server runs a secured ROS 2 node per each role and provides access to them based on 
the id token of each user.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/security.md">Edit this page on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="roadmap-1"><a class="header" href="#roadmap-1">Roadmap</a></h1>
<p>This list describes topics, in no particular order, that we are currently working on and expect to advance in the next 12 months.
We can’t commit to specific development timelines, but community feedback on which topics are of highest interest is one factor that can help influence the prioritization of our work queue.
As in any R&amp;D project, we will react to how things evolve in many dimensions.</p>
<p>RMF is an open-source project.
We will keep developing in the open so that community members can see real-time what is happening.
Let's work on it together!
We encourage (and really love to see!) contributions from the community in addition to our own efforts, so if you see something that interests you, please collaborate with us through GitHub!</p>
<h2 id="topics-under-active-or-near-future-development"><a class="header" href="#topics-under-active-or-near-future-development">Topics under active or near-future development:</a></h2>
<ul>
<li>Deployment Environment
<ul>
<li>add <a href="https://www.redhat.com/en/enterprise-linux-8">Red Hat Enterprise Linux 8 (RHEL 8)</a> support, including binary packaging</li>
<li>Add examples and tooling to simplify instantiating and interacting with RMF running in AWS using WireGuard tunnels to local robots and doors/lifts/chargers</li>
</ul>
</li>
<li><code>rmf_core</code>
<ul>
<li>A turnkey free space planning library that's compatible with the traffic management utilities using <a href="https://github.com/osrf/rmf_core/blob/master/rmf_fleet_adapter/include/rmf_fleet_adapter/agv/FleetUpdateHandle.hpp"><code>RobotFleetAdapterHandle</code></a> (not restricting to <a href="https://github.com/osrf/rmf_core/tree/master/rmf_fleet_msgs/msg"><code>rmf_fleet_msgs</code></a> anymore) which incorporates all predicted future motions of other robots</li>
<li>&quot;Valet&quot;: dynamic allocation of &quot;parking spaces&quot; for idle robots
A reusable library for distributed (multi-fleet) task dispatching based on customizable evaluation criteria</li>
<li>Live task management: support cancellation of running tasks</li>
<li>Many improvements to runtime efficiency, latency, memory usage, etc.</li>
</ul>
</li>
<li>User Interface Toolkit: <a href="https://github.com/osrf/rmf-web"><code>rmf-web</code></a>
<ul>
<li>a browser-based <a href="https://github.com/nomcopter/react-mosaic">tiling/mosaic</a> type user interface framework and a mechanism to create pre-arranged and user-customized panel collections, much like <a href="http://wiki.ros.org/rviz"><code>rviz</code></a> and similar configurable visualization-engine systems</li>
<li>a collection of <a href="https://reactjs.org/">React</a> components for this tiling/mosaic framework:
<ul>
<li>2D map views of current and scheduled robot motions</li>
<li>tables showing statuses of robots / lifts / doors / chargers</li>
<li>task creation, monitoring, and cancellation</li>
<li>emergency alarm monitoring and (for testing) simulated activation</li>
<li>and many more!</li>
</ul>
</li>
<li>a backend in <a href="https://fastapi.tiangolo.com/">FastAPI</a> to feed the frontend and bridge it to the ROS 2 nodes</li>
<li>a user management system with roles, based on <a href="https://www.keycloak.org/">Keycloak</a></li>
<li>examples of how to deploy this UI toolkit to build end-to-end applications</li>
<li>log management frontend and backend</li>
</ul>
</li>
<li>Infrastructure adapters
<ul>
<li>an intelligent lift (elevator) adapter that can optimally coordinate how robots share lifts (with each other and with humans)</li>
<li>documented examples of using OPC-UA <a href="https://en.wikipedia.org/wiki/Programmable_logic_controller">PLC's</a> to control infrastructure such as doors and lifts.</li>
</ul>
</li>
<li>Chargers
<ul>
<li>integration with multi-robot charger hardware</li>
<li>iteration of <code>rmf_charger_msgs</code> as needed</li>
<li>a negotiation system to dynamically allocate multi-robot chargers on demand</li>
</ul>
</li>
<li>Robot fleet adapters
<ul>
<li>adding new types of robots as relevant to our sponsors</li>
<li>customized fleet adapters and map ingestion scripts as needed</li>
<li>continual improvement to the open-source <a href="https://github.com/osrf/fleet_adapter_mir">MiR fleet adapter</a></li>
<li>improving existing robot fleet adapters and generalizing/refactoring those improvements as possible into the open-source libraries</li>
</ul>
</li>
<li>Documentation
<ul>
<li>Improve package-level documentation</li>
<li>Improve the long-form narrative documentation in The Book</li>
</ul>
</li>
<li>Testing
<ul>
<li>Continue to improve unit and end-to-end tests of all components (this task never ends)</li>
</ul>
</li>
</ul>
<h2 id="wish-list"><a class="header" href="#wish-list">Wish list</a></h2>
<p>Beyond that list of topics, we have a giant and ever growing &quot;wish list&quot; of things to work on, pending time and resource availability!
These include (in no particular order):</p>
<ul>
<li>browser-based traffic editor and backend extensions as needed</li>
<li>improvements in how maps are ingested and aligned from existing robot systems</li>
<li>dynamic traffic lane availability (add/remove lane segments from the planning graphs)</li>
<li>dynamic temporary traffic blockout zones/areas for parallel activities (i.e. zone-based cleaning robot activities, temporary construction, etc.)</li>
<li>many more web UI panels</li>
<li><a href="https://github.com/osrf/free_fleet">FreeFleet</a> demonstrations</li>
<li>FreeFleet clients in as many other robotics frameworks as possible</li>
<li>drastic simulation appearance improvement
<ul>
<li>improve world-creation tools (either inside traffic editor or outside of it) using new features in Ignition Gazebo for physically-based rendering (PBR) texture support, lighting models, and so on.</li>
</ul>
</li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/osrf/ros2multirobotbook/edit/main/src/roadmap.md">Edit this page on GitHub.</a></footer>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
